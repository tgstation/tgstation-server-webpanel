{"version":3,"file":"607.592e15ea131f62401699.bundle.js","mappings":"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","sources":["webpack://tgstation-server-control-panel/./src/ApiClient/AdminClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/InstanceClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/InstancePermissionSetClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/JobsClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/ServerClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/TransferClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/UserClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/_base.ts","webpack://tgstation-server-control-panel/./src/ApiClient/generatedcode/generated.ts","webpack://tgstation-server-control-panel/./src/ApiClient/models/ICredentials.ts","webpack://tgstation-server-control-panel/./src/ApiClient/models/InternalComms/InternalError.ts","webpack://tgstation-server-control-panel/./src/ApiClient/models/InternalComms/InternalStatus.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/ConfigController.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/CredentialsProvider.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/JobsController.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/LoginHooks.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/config.ts"],"sourcesContent":["import { ApiClient } from \"./_base\";\nimport type {\n    AdministrationResponse,\n    ErrorMessageResponse,\n    LogFileResponse,\n    PaginatedLogFileResponse,\n    ServerUpdateResponse\n} from \"./generatedcode/generated\";\nimport { DownloadedLog } from \"./models/DownloadedLog\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport TransferClient, { DownloadErrors, ProgressEvent, UploadErrors } from \"./TransferClient\";\nimport configOptions from \"./util/config\";\n\ninterface IEvents {\n    loadAdminInfo: (user: InternalStatus<AdministrationResponse, AdminInfoErrors>) => void;\n}\n\nexport type AdminInfoErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR;\n\nexport type RestartErrors = GenericErrors | ErrorCode.ADMIN_WATCHDOG_UNAVAIL;\n\nexport type UpdateErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_WATCHDOG_UNAVAIL\n    | ErrorCode.ADMIN_VERSION_NOT_FOUND\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR\n    | UploadErrors;\n\nexport type LogsErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport type LogErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport default new (class AdminClient extends ApiClient<IEvents> {\n    private _cachedAdminInfo?: InternalStatus<AdministrationResponse, ErrorCode.OK>;\n    public get cachedAdminInfo() {\n        return this._cachedAdminInfo;\n    }\n    private loadingAdminInfo = false;\n\n    public constructor() {\n        super();\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedAdminInfo = undefined;\n        });\n    }\n\n    public async getAdminInfo(): Promise<InternalStatus<AdministrationResponse, AdminInfoErrors>> {\n        await ServerClient.wait4Init();\n        if (this._cachedAdminInfo) {\n            return this._cachedAdminInfo;\n        }\n\n        if (this.loadingAdminInfo) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<AdministrationResponse, AdminInfoErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadAdminInfo\", resolver);\n                };\n                this.on(\"loadAdminInfo\", resolver);\n            });\n        }\n\n        this.loadingAdminInfo = true;\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.administrationControllerRead();\n        } catch (stat) {\n            const res = new InternalStatus<AdministrationResponse, AdminInfoErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<AdminInfoErrors>\n            });\n            this.emit(\"loadAdminInfo\", res);\n            this.loadingAdminInfo = false;\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const thing = new InternalStatus<AdministrationResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as AdministrationResponse\n                });\n\n                this._cachedAdminInfo = thing;\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 424: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                const thing = new InternalStatus<\n                    AdministrationResponse,\n                    ErrorCode.ADMIN_GITHUB_RATE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 429: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                const thing = new InternalStatus<\n                    AdministrationResponse,\n                    ErrorCode.ADMIN_GITHUB_ERROR\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            default: {\n                const res = new InternalStatus<\n                    AdministrationResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", res);\n                this.loadingAdminInfo = false;\n                return res;\n            }\n        }\n    }\n\n    public async restartServer(): Promise<InternalStatus<null, RestartErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.administrationControllerDelete();\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<RestartErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: null\n                });\n            }\n            case 422: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<null, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async updateServer(\n        newVersion: string\n    ): Promise<InternalStatus<ServerUpdateResponse, UpdateErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.administrationControllerUpdate({\n                newVersion\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<UpdateErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as ServerUpdateResponse\n                });\n            }\n            case 410: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_VERSION_NOT_FOUND,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 422: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 424: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus<ServerUpdateResponse, ErrorCode.ADMIN_GITHUB_RATE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 429: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus<ServerUpdateResponse, ErrorCode.ADMIN_GITHUB_ERROR>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<ServerUpdateResponse, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async uploadVersion(\n        newVersion: string,\n        file: ArrayBuffer\n    ): Promise<InternalStatus<ServerUpdateResponse, UpdateErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.administrationControllerUpdate({\n                newVersion,\n                uploadZip: true\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<UpdateErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                const payload = response.data as ServerUpdateResponse;\n                const upload = await TransferClient.Upload(payload.fileTicket, file);\n                if (upload.code === StatusCode.OK) {\n                    return new InternalStatus({\n                        code: StatusCode.OK,\n                        payload\n                    });\n                }\n\n                return new InternalStatus<ServerUpdateResponse, UpdateErrors>({\n                    code: StatusCode.ERROR,\n                    error: upload.error\n                });\n            }\n            case 410: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_VERSION_NOT_FOUND,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 422: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 424: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus<ServerUpdateResponse, ErrorCode.ADMIN_GITHUB_RATE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 429: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus<ServerUpdateResponse, ErrorCode.ADMIN_GITHUB_ERROR>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<ServerUpdateResponse, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLogs({\n        page = 1,\n        pageSize = configOptions.itemsperpage.value as number\n    }): Promise<InternalStatus<PaginatedLogFileResponse, LogsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.administrationControllerListLogs({\n                pageSize: pageSize,\n                page: page\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<LogsErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedLogFileResponse\n                });\n            }\n            case 409: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLog(\n        logName: string,\n        progressHandler: (progressEvent: ProgressEvent) => void\n    ): Promise<InternalStatus<DownloadedLog, LogErrors | DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.administrationControllerGetLog(logName);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                const logFileResponse = response.data as LogFileResponse;\n                const contents = await TransferClient.Download(\n                    logFileResponse.fileTicket,\n                    progressHandler\n                );\n                if (contents.code === StatusCode.OK) {\n                    //Object.assign() is a funky function but all it does is copy everything from the second object to the first object\n                    const temp: DownloadedLog = Object.assign(\n                        {\n                            content: await contents.payload.text()\n                        },\n                        logFileResponse\n                    );\n                    return new InternalStatus({\n                        code: StatusCode.OK,\n                        payload: temp\n                    });\n                } else {\n                    return new InternalStatus({\n                        code: StatusCode.ERROR,\n                        error: contents.error\n                    });\n                }\n            }\n            case 409: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    InstanceCreateRequest,\n    InstanceResponse,\n    InstanceUpdateRequest,\n    PaginatedInstanceResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type ListInstancesErrors = GenericErrors;\nexport type CreateInstanceErrors = GenericErrors;\nexport type EditInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type GetInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type GrantPermissionsErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type DetachInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\n\ninterface IEvents {\n    instanceChange: (instanceId: number) => void;\n}\n\nexport default new (class InstanceClient extends ApiClient<IEvents> {\n    public async listInstances({\n        page = 1,\n        pageSize = configOptions.itemsperpage.value as number\n    } = {}): Promise<InternalStatus<PaginatedInstanceResponse, ListInstancesErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerList({\n                pageSize: pageSize,\n                page: page\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedInstanceResponse\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async grantPermissions(\n        instance: InstanceUpdateRequest\n    ): Promise<InternalStatus<InstanceResponse, GrantPermissionsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerGrantPermissions(\n                instance.id\n            );\n            this.emit(\"instanceChange\", instance.id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: { id: instance.id } as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async editInstance(\n        instance: InstanceUpdateRequest\n    ): Promise<InternalStatus<InstanceResponse, EditInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerUpdate(instance);\n            this.emit(\"instanceChange\", instance.id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 202: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async detachInstance(id: number): Promise<InternalStatus<null, DetachInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerDelete(id);\n            this.emit(\"instanceChange\", id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: null\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async createInstance(\n        instance: InstanceCreateRequest\n    ): Promise<InternalStatus<InstanceResponse, CreateInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerCreate(instance);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 201: {\n                const instance = response.data as InstanceResponse;\n\n                this.emit(\"instanceChange\", instance.id);\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: instance\n                });\n            }\n            case 409:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.HTTP_DATA_INEGRITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getInstance(\n        instanceid: number\n    ): Promise<InternalStatus<InstanceResponse, GetInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerGetId(instanceid);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    InstancePermissionSetRequest,\n    InstancePermissionSetResponse,\n    PaginatedInstancePermissionSetResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\ninterface IEvents {\n    loadInstancePermissionSet: (\n        user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n    ) => void;\n}\n\nexport type getCurrentInstancePermissionSetErrors = GenericErrors;\nexport type getByPermissionSetIdErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type createInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type updateInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type deleteInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type listInstancePermissionSetErrors = GenericErrors;\n\nexport default new (class InstancePermissionSetClient extends ApiClient<IEvents> {\n    private _cachedInstancePermissionSet: Map<\n        number,\n        InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>\n    > = new Map<number, InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>>();\n\n    private loadingInstancePermissionSetInfo: Map<number, boolean> = new Map<number, boolean>();\n\n    public constructor() {\n        super();\n\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedInstancePermissionSet.clear();\n        });\n    }\n\n    public async listInstancePermissionSets(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<\n        InternalStatus<PaginatedInstancePermissionSetResponse, listInstancePermissionSetErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerList(\n                {\n                    page: page,\n                    pageSize: pageSize\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<\n                    PaginatedInstancePermissionSetResponse,\n                    ErrorCode.OK\n                >({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedInstancePermissionSetResponse\n                });\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<\n                    PaginatedInstancePermissionSetResponse,\n                    GenericErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async getCurrentInstancePermissionSet(\n        instanceid: number,\n        noCache?: boolean\n    ): Promise<\n        InternalStatus<InstancePermissionSetResponse, getCurrentInstancePermissionSetErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        if (!noCache && this._cachedInstancePermissionSet.has(instanceid)) {\n            return this._cachedInstancePermissionSet.get(instanceid)!;\n        }\n\n        if (this.loadingInstancePermissionSetInfo.get(instanceid)) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadInstancePermissionSet\", resolver);\n                };\n                this.on(\"loadInstancePermissionSet\", resolver);\n            });\n        }\n\n        this.loadingInstancePermissionSetInfo.set(instanceid, true);\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerRead({\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadInstancePermissionSet\", res);\n            this.loadingInstancePermissionSetInfo.set(instanceid, false);\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n\n                this._cachedInstancePermissionSet.set(instanceid, res);\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n        }\n    }\n\n    public async getByPermissionSetId(\n        instanceid: number,\n        permissionSetId: number\n    ): Promise<InternalStatus<InstancePermissionSetResponse, getByPermissionSetIdErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerGetId(\n                permissionSetId,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                getByPermissionSetIdErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<getByPermissionSetIdErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    getByPermissionSetIdErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async createInstancePermissionSet(\n        instanceid: number,\n        instancePermissionSet: InstancePermissionSetRequest\n    ): Promise<InternalStatus<InstancePermissionSetResponse, createInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerCreate(\n                instancePermissionSet,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                createInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<createInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 201: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    createInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async updateInstancePermissionSet(\n        instanceid: number,\n        instancePermissionSet: InstancePermissionSetRequest\n    ): Promise<InternalStatus<InstancePermissionSetResponse, updateInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerUpdate(\n                instancePermissionSet,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                updateInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<updateInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    updateInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async deleteInstancePermissionSet(\n        instanceid: number,\n        permissionSetId: number\n    ): Promise<InternalStatus<InstancePermissionSetResponse, deleteInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerDelete(\n                permissionSetId,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                deleteInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<deleteInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: { permissionSetId } as InstancePermissionSetResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    deleteInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    JobResponse,\n    PaginatedJobResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type listJobsErrors = GenericErrors;\nexport type getJobErrors = GenericErrors | ErrorCode.JOB_JOB_NOT_FOUND;\nexport type deleteJobErrors =\n    | GenericErrors\n    | ErrorCode.JOB_JOB_NOT_FOUND\n    | ErrorCode.JOB_JOB_COMPLETE;\n\nexport type PaginatedTGSJobResponse = Omit<PaginatedJobResponse, \"content\"> & {\n    content: TGSJobResponse[];\n};\nexport type TGSJobResponse = JobResponse & {\n    canCancel?: boolean;\n};\n\nexport default new (class JobsClient extends ApiClient {\n    public async listActiveJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, listJobsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerRead(\n                {\n                    page: page,\n                    pageSize: pageSize\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, getJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerGetId(jobid, {\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async deleteJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, deleteJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerDelete(jobid, {\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_COMPLETE, {\n                        void: true\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async listJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, GenericErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerList(\n                {\n                    pageSize,\n                    page\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { AxiosError, AxiosInstance, AxiosResponse } from \"axios\";\nimport { jwtDecode } from \"jwt-decode\";\n\nimport { API_VERSION, VERSION } from \"../definitions/constants\";\nimport { ApiClient } from \"./_base\";\nimport {\n    Api,\n    ErrorMessageResponse,\n    HttpClient,\n    ServerInformationResponse,\n    TokenResponse\n} from \"./generatedcode/generated\";\nimport { CredentialsType, ICredentials } from \"./models/ICredentials\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport { ServerClientRequestConfig } from \"./ServerClientRequestConfig\";\nimport configOptions from \"./util/config\";\nimport CredentialsProvider from \"./util/CredentialsProvider\";\nimport LoginHooks from \"./util/LoginHooks\";\n\ninterface IEvents {\n    //self explainatory\n    logout: () => void;\n    //fired whenever something is denied access, shouldnt really be used\n    accessDenied: () => void;\n    //fired when the server info is first loaded\n    loadServerInfo: (\n        serverInfo: InternalStatus<ServerInformationResponse, ServerInfoErrors>\n    ) => void;\n    //fired when the api is loaded from the json file and loaded\n    initialized: () => void;\n    //purge all caches\n    purgeCache: () => void;\n    //internal event, queues logins\n    loadLoginInfo: (loginInfo: InternalStatus<TokenResponse, LoginErrors>) => void;\n    //internal event fired for wait4Token(), external things should be using LoginHooks#LoginSuccess or a login hook\n    tokenAvailable: (token: TokenResponse) => void;\n}\n\nexport type LoginErrors =\n    | GenericErrors\n    | ErrorCode.LOGIN_DISABLED\n    | ErrorCode.LOGIN_FAIL\n    | ErrorCode.LOGIN_NOCREDS\n    | ErrorCode.LOGIN_BAD_OAUTH\n    | ErrorCode.LOGIN_RATELIMIT;\n\nexport type ServerInfoErrors = GenericErrors;\n\nexport default new (class ServerClient extends ApiClient<IEvents> {\n    private static readonly globalHandledCodes = [400, 401, 403, 406, 409, 426, 500, 501, 503];\n\n    //api\n\n    public apiHttpClient?: HttpClient<unknown>;\n    public apiClient?: Api<unknown>;\n\n    public apiRequestInterceptor = {\n        onFulfilled: async (value: ServerClientRequestConfig) => {\n            //Meta value that means theres no value, used in the github deployed version\n            if (configOptions.apipath.value === \"https://example.org:5000\") {\n                const errorobj = new InternalError(ErrorCode.NO_APIPATH, {\n                    void: true\n                });\n                return Promise.reject(errorobj);\n            }\n\n            //This applies the authorization header, it will wait however long it needs until\n            // theres a token available. It obviously won't wait for a token before sending the request\n            // if its currently sending a request to the login endpoint...\n            if (value.overrideTokenDetection || !(value.url === \"/api\" || value.url === \"/api/\")) {\n                const tok = await this.wait4Token();\n                (value.headers as { [key: string]: string })[\"Authorization\"] = `Bearer ${\n                    tok.bearer || \"\"\n                }`;\n            }\n            return value;\n        },\n        // it is real, we do not know what type though\n        onRejected: (error: unknown) => {\n            return Promise.reject(error);\n        }\n    };\n\n    public apiResponseInterceptor = {\n        onFulfilled: (val: AxiosResponse) => val,\n        // it is real, we do not know what type though\n        onRejected: (error: AxiosError, axiosServer: AxiosInstance): Promise<AxiosResponse> => {\n            //THIS IS SNOWFLAKE KEKW\n            //As the above comment mentions, this shitcode is very snowflake\n            // it tries to typecast the \"response\" we got into an error then tries to check if that \"error\" is\n            // the snowflake no apipath github error, if it is, it rejects the promise to send it to the catch block\n            // all endpoints have which simply returns the error wrapped in a status object\n            const snowflake = (error as unknown) as InternalError<ErrorCode.NO_APIPATH>;\n            if (snowflake?.code === ErrorCode.NO_APIPATH) {\n                return Promise.reject(snowflake);\n            }\n\n            //This was originally an else clause at the bottom but it made it hard to find\n            // if the promise rejected and its not because its a globally handled status code\n            // it means that axios created an error itself for an unknown reason(network failure,\n            // cors failure, user is navigating away, aborting requests, etc). Simply return the error\n            // as a globally handled error.\n            if (\n                !(\n                    error.response &&\n                    error.response.status &&\n                    ServerClient.globalHandledCodes.includes(error.response.status)\n                )\n            ) {\n                const err = error as Error;\n                const errorobj = new InternalError(\n                    ErrorCode.AXIOS,\n                    { jsError: err },\n                    error.response\n                );\n                return Promise.reject(errorobj);\n            }\n\n            //I am sorry, this is the bulk of the shitcode, its a massive switch that handles every single\n            // globally handled status code and sometimes not so globally because one endpoint decided it would be\n            const res = error.response as AxiosResponse<unknown>;\n            switch (error.response.status) {\n                //Error code 400: Bad request, show message to user and instruct them to report it as its probably a bug\n                case 400: {\n                    const errorMessage = res.data as ErrorMessageResponse;\n                    const errorobj = new InternalError(\n                        ErrorCode.HTTP_BAD_REQUEST,\n                        { errorMessage },\n                        res\n                    );\n                    return Promise.reject(errorobj);\n                }\n                //Error code 401: Access Denied, fired whenever a token expires, in that case, attempt to reauthenticate\n                // using the last known working credentials, if that succeeds, reissue the request, otherwise logout the\n                // user and kick them to the login page. Snowflake behaviour: Acts as a failed login for the login endpoint\n                case 401: {\n                    const request = error.config;\n                    if (request.url === \"/api\" || request.url === \"api\") {\n                        return Promise.resolve(error.response);\n                    }\n\n                    if (this.autoLogin) {\n                        return this.login().then(status => {\n                            switch (status.code) {\n                                case StatusCode.OK: {\n                                    return axiosServer.request(error.config);\n                                }\n                                case StatusCode.ERROR: {\n                                    this.emit(\"accessDenied\");\n                                    //time to kick out the user\n                                    this.logout();\n                                    return Promise.reject(status);\n                                }\n                            }\n                        });\n                    } else {\n                        this.emit(\"accessDenied\");\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_ACCESS_DENIED,\n                            { void: true },\n                            res,\n                            true\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                }\n                case 403: {\n                    const request = error.config;\n                    if ((request.url === \"/\" || request.url === \"\") && request.method === \"post\") {\n                        return Promise.resolve(error.response);\n                    } else {\n                        this.emit(\"accessDenied\");\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_ACCESS_DENIED,\n                            { void: true },\n                            res,\n                            true\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                }\n                case 406: {\n                    const errorobj = new InternalError(\n                        ErrorCode.HTTP_NOT_ACCEPTABLE,\n                        { void: true },\n                        res\n                    );\n                    return Promise.reject(errorobj);\n                }\n                case 409: {\n                    const errorMessage = res.data as ErrorMessageResponse;\n\n                    //Thanks for reusing a global erorr status cyber. Log operations can return 409\n                    const request = error.config;\n                    if (request.url === \"/Administration/Logs\" && request.method === \"get\") {\n                        return Promise.resolve(error.response);\n                    }\n\n                    const errorobj = new InternalError(\n                        ErrorCode.HTTP_DATA_INEGRITY,\n                        { errorMessage },\n                        res\n                    );\n                    return Promise.reject(errorobj);\n                }\n                case 426: {\n                    const errorMessage = res.data as ErrorMessageResponse;\n                    const errorobj = new InternalError(\n                        ErrorCode.HTTP_API_MISMATCH,\n                        { errorMessage },\n                        res\n                    );\n                    return Promise.reject(errorobj);\n                }\n                case 500: {\n                    const errorMessage = res.data as ErrorMessageResponse;\n                    const errorobj = new InternalError(\n                        ErrorCode.HTTP_SERVER_ERROR,\n                        { errorMessage },\n                        res\n                    );\n                    return Promise.reject(errorobj);\n                }\n                case 501: {\n                    const errorMessage = res.data as ErrorMessageResponse;\n                    const errorobj = new InternalError(\n                        ErrorCode.HTTP_UNIMPLEMENTED,\n                        { errorMessage },\n                        res\n                    );\n                    return Promise.reject(errorobj);\n                }\n                case 503: {\n                    console.log(\"Server not ready, delaying request\", error.config);\n                    return new Promise(resolve => {\n                        setTimeout(resolve, 5000);\n                    }).then(() => axiosServer.request(error.config));\n                    /*const errorobj = new InternalError(\n                        ErrorCode.HTTP_SERVER_NOT_READY,\n                            {\n                                void: true\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);*/\n                }\n                default: {\n                    const errorobj = new InternalError(\n                        ErrorCode.UNHANDLED_GLOBAL_RESPONSE,\n                        { axiosResponse: res },\n                        res\n                    );\n                    return Promise.reject(errorobj);\n                }\n            }\n        }\n    };\n\n    private initialized = false;\n    private loadingServerInfo = false;\n\n    public constructor() {\n        super();\n        this.getServerInfo = this.getServerInfo.bind(this);\n\n        LoginHooks.addHook(this.getServerInfo);\n        this.on(\"purgeCache\", () => {\n            this._serverInfo = undefined;\n            if (CredentialsProvider.token) {\n                void LoginHooks.runHooks(CredentialsProvider.token);\n            }\n        });\n\n        //Why is this here? Because otherwise it creates an import loop, grrrrr\n        configOptions.apipath.callback = (): void => {\n            console.log(\"API path changed\");\n            window.location.reload();\n        };\n    }\n\n    //serverInfo\n    private _serverInfo?: InternalStatus<ServerInformationResponse, ErrorCode.OK>;\n\n    public get serverInfo() {\n        return this._serverInfo;\n    }\n\n    public autoLogin = true;\n    private loggingIn = false;\n\n    public get defaultHeaders() {\n        return {\n            Accept: \"application/json\",\n            Api: `Tgstation.Server.Api/` + API_VERSION,\n            \"Webpanel-Version\": VERSION\n        };\n    }\n\n    public async initApi(): Promise<boolean> {\n        console.log(\"Initializing API client\");\n        console.time(\"APIInit\");\n\n        this.apiHttpClient = new HttpClient({\n            //Yes this is only initialized once even if the configOption changes, this doesn't\n            baseURL: configOptions.apipath.value as string,\n            withCredentials: false,\n            headers: this.defaultHeaders,\n            //Global errors are handled via the catch clause and endpoint specific response codes are handled normally\n            validateStatus: status => {\n                return !ServerClient.globalHandledCodes.includes(status);\n            }\n        });\n        this.apiHttpClient.instance.interceptors.request.use(\n            this.apiRequestInterceptor.onFulfilled,\n            this.apiRequestInterceptor.onRejected\n        );\n        this.apiHttpClient.instance.interceptors.response.use(\n            this.apiResponseInterceptor.onFulfilled,\n            error => this.apiResponseInterceptor.onRejected(error, this.apiHttpClient!.instance)\n        );\n\n        this.apiClient = new Api(this.apiHttpClient);\n\n        console.timeEnd(\"APIInit\");\n\n        let result = false;\n        // check if there's a token stored\n        const bearer = localStorage.getItem(\"SessionToken\");\n        const expiresAtUnixTimestampStr = localStorage.getItem(\"SessionTokenExpiry\");\n        const defaultToken = localStorage.getItem(\"SessionTokenDefault\") == \"true\";\n        if (bearer && expiresAtUnixTimestampStr) {\n            console.log(\"Found session token\");\n            if (parseInt(expiresAtUnixTimestampStr) * 1000 >= Date.now()) {\n                const storedToken: TokenResponse = { bearer };\n                result = await this.setToken(storedToken, defaultToken, true);\n            } else {\n                console.log(\"But it was expired\");\n            }\n        }\n\n        this.initialized = true;\n        this.emit(\"initialized\");\n        return result;\n    }\n\n    //Utility function that returns a promise which resolves whenever ServerClient#ApiClient becomes valid\n    public wait4Init(): Promise<void> {\n        return new Promise<void>(resolve => {\n            if (this.initialized) {\n                resolve();\n                return;\n            }\n            this.on(\"initialized\", () => resolve());\n        });\n    }\n\n    //Utility function that returns a promise which resolves with the token whenever theres valid credentials(could be immediatly)\n    public wait4Token() {\n        return new Promise<TokenResponse>(resolve => {\n            if (CredentialsProvider.hasToken()) {\n                resolve(CredentialsProvider.token!);\n                return;\n            }\n            this.on(\"tokenAvailable\", token => {\n                resolve(token);\n            });\n        });\n    }\n\n    public async login(\n        newCreds?: ICredentials\n    ): Promise<InternalStatus<TokenResponse, LoginErrors>> {\n        //Shouldn't really happen edge cases\n        await this.wait4Init();\n\n        console.log(\"Attempting login\");\n\n        //Newcreds is optional, if its missing its going to try to reuse the last used credentials,\n        // if newCreds exists, its going to use newCreds\n        let oauthAutoLogin = false;\n        if (newCreds) {\n            CredentialsProvider.credentials = newCreds;\n        } else if (CredentialsProvider.credentials?.type === CredentialsType.OAuth) {\n            // autologin doesn't work with OAuth\n            this.logout();\n            oauthAutoLogin = true;\n        }\n\n        //This is thrown if you try to reuse the last credentials without actually having last used credentials\n        //or you let an oauth login expire\n        if (oauthAutoLogin || !CredentialsProvider.credentials)\n            return new InternalStatus<TokenResponse, ErrorCode.LOGIN_NOCREDS>({\n                code: StatusCode.ERROR,\n                error: new InternalError(ErrorCode.LOGIN_NOCREDS, { void: true })\n            });\n\n        //This block is here to prevent duplication of login requests at the same time, when you start logging in,\n        // it sets loggingIn to true and fires an event once its done logging in, successful or not, if you try to login\n        // while another login request is ongoing, it listens to that event and returns the output normally.\n        //\n        // Basically, make two calls, receive two identical return values, make only one request\n        if (this.loggingIn) {\n            return await new Promise(resolve => {\n                const resolver = (info: InternalStatus<TokenResponse, LoginErrors>) => {\n                    resolve(info);\n                    this.removeListener(\"loadLoginInfo\", resolver);\n                };\n                this.on(\"loadLoginInfo\", resolver);\n            });\n        }\n        this.loggingIn = true;\n\n        let response;\n        let defaulted;\n        try {\n            if (CredentialsProvider.credentials.type == CredentialsType.Password) {\n                defaulted =\n                    CredentialsProvider.credentials.userName.toLowerCase() ==\n                        CredentialsProvider.default.userName.toLowerCase() &&\n                    CredentialsProvider.credentials.password ==\n                        CredentialsProvider.default.password;\n                response = await this.apiClient!.api.apiRootControllerCreateToken({\n                    auth: {\n                        username: CredentialsProvider.credentials.userName,\n                        password: CredentialsProvider.credentials.password\n                    }\n                });\n            } else {\n                defaulted = false;\n                response = await this.apiClient!.api.apiRootControllerCreateToken({\n                    headers: {\n                        OAuthProvider: CredentialsProvider.credentials.provider,\n                        Authorization: `OAuth ${CredentialsProvider.credentials.token}`\n                    }\n                });\n            }\n        } catch (stat) {\n            const res = new InternalStatus<TokenResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadLoginInfo\", res);\n            return res;\n        } finally {\n            this.loggingIn = false;\n        }\n        switch (response.status) {\n            case 200: {\n                console.log(\"Login success\");\n                const token = response.data as TokenResponse;\n\n                await this.setToken(token, defaulted, false);\n                const res = new InternalStatus<TokenResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: token\n                });\n                //Deduplication\n                this.emit(\"loadLoginInfo\", res);\n\n                return res;\n            }\n            case 401: {\n                this.logout();\n                console.log(\"Failed to login\");\n                const res = new InternalStatus<TokenResponse, ErrorCode.LOGIN_FAIL>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_FAIL,\n                        {\n                            void: true\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            case 403: {\n                this.logout();\n                console.log(\"Account disabled\");\n                const res = new InternalStatus<TokenResponse, ErrorCode.LOGIN_DISABLED>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_DISABLED,\n                        {\n                            void: true\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            case 429: {\n                this.logout();\n                console.log(\"rate limited\");\n                const res = new InternalStatus<TokenResponse, ErrorCode.LOGIN_RATELIMIT>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_RATELIMIT,\n                        {\n                            errorMessage: response.data as ErrorMessageResponse\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<TokenResponse, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n        }\n    }\n\n    public logout() {\n        //If theres no token it means theres nothing to clear\n        if (!CredentialsProvider.hasToken()) {\n            return;\n        }\n        console.log(\"Logging out\");\n        CredentialsProvider.credentials = undefined;\n        CredentialsProvider.token = undefined;\n        localStorage.removeItem(\"SessionToken\");\n        localStorage.removeItem(\"SessionTokenExpiry\");\n        //events to clear the app state as much as possible for the next user\n        this.emit(\"purgeCache\");\n        this.emit(\"logout\");\n    }\n\n    public async getServerInfo(\n        _token?: TokenResponse,\n        bypassCache = false\n    ): Promise<InternalStatus<ServerInformationResponse, ServerInfoErrors>> {\n        await this.wait4Init();\n\n        if (this._serverInfo && !bypassCache) {\n            return this._serverInfo;\n        }\n\n        if (this.loadingServerInfo) {\n            return new Promise(resolve => {\n                if (this._serverInfo) {\n                    //race condition if 2 things listen to an event or something\n                    resolve(this._serverInfo);\n                    return;\n                }\n                const resolver = (\n                    info: InternalStatus<ServerInformationResponse, GenericErrors>\n                ) => {\n                    resolve(info);\n                    this.removeListener(\"loadServerInfo\", resolver);\n                };\n                this.on(\"loadServerInfo\", resolver);\n            });\n        }\n\n        this.loadingServerInfo = true;\n\n        let response;\n        try {\n            response = await this.apiClient!.api.apiRootControllerServerInfo();\n        } catch (stat) {\n            const res = new InternalStatus<ServerInformationResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadServerInfo\", res);\n            this.loadingServerInfo = false;\n            return res;\n        }\n        switch (response.status) {\n            case 200: {\n                const info = response.data as ServerInformationResponse;\n                const cache = new InternalStatus<ServerInformationResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: info\n                });\n                this.emit(\"loadServerInfo\", cache);\n                this._serverInfo = cache;\n                this.loadingServerInfo = false;\n                return cache;\n            }\n            default: {\n                const res = new InternalStatus<\n                    ServerInformationResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadServerInfo\", res);\n                this.loadingServerInfo = false;\n                return res;\n            }\n        }\n    }\n\n    private async setToken(\n        token: TokenResponse,\n        defaulted: boolean,\n        validate: boolean\n    ): Promise<boolean> {\n        // CredentialsProvider.token is added to all requests in the form of Authorization: Bearer <token>\n\n        const previousToken = CredentialsProvider.token;\n        const previousDefaulted = CredentialsProvider.defaulted;\n\n        CredentialsProvider.token = token;\n        CredentialsProvider.defaulted = defaulted;\n\n        if (validate) {\n            let failed;\n            try {\n                const response = await this.apiClient!.api.apiRootControllerServerInfo({\n                    overrideTokenDetection: true\n                });\n\n                failed = response.status != 200;\n            } catch (stat) {\n                failed = true;\n            }\n\n            if (failed) {\n                CredentialsProvider.token = previousToken;\n                CredentialsProvider.defaulted = previousDefaulted;\n                console.log(\"Stored token failed to authenticate\");\n                return false;\n            }\n\n            console.log(\"Stored token authenticated\");\n        }\n\n        localStorage.setItem(\"SessionToken\", token.bearer);\n        const jwt = jwtDecode(token.bearer);\n        if (jwt.exp) {\n            localStorage.setItem(\"SessionTokenExpiry\", jwt.exp.toString());\n        }\n\n        localStorage.setItem(\"SessionTokenDefault\", defaulted ? \"true\" : \"false\");\n\n        this.emit(\"tokenAvailable\", token);\n\n        //LoginHooks are a way of running several async tasks at the same time whenever the user is authenticated,\n        // we cannot use events here as events wait on each listener before proceeding which has a noticable performance\n        // cost when it comes to several different requests to TGS,\n        // we cant directly call what we need to run here as it would violate isolation of\n        // ApiClient(the apiclient is independent from the rest of the app to avoid circular dependency\n        // (example: Component requires ServerClient to login and but the ServerClient requires Component to\n        // update it once the server info is loaded))\n        //\n        // TL;DR; Runs shit when you login\n\n        LoginHooks.runHooks(token);\n        return true;\n    }\n})();\n\n//https://stackoverflow.com/questions/40510611/typescript-interface-require-one-of-two-properties-to-exist\n//name describes what it does, makes the passed type only require 1 property, the others being optional\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n    {\n        [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n    }[Keys];\n","import { ApiClient } from \"./_base\";\nimport type { ErrorMessageResponse } from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\n\nexport type DownloadErrors = GenericErrors | ErrorCode.TRANSFER_NOT_AVAILABLE;\nexport type UploadErrors =\n    | GenericErrors\n    | ErrorCode.TRANSFER_NOT_AVAILABLE\n    | ErrorCode.UPLOAD_FAILED;\n\nexport interface ProgressEvent {\n    loaded: number;\n    total: number;\n}\n\nexport default new (class TransferClient extends ApiClient {\n    public async Download(\n        ticket: string,\n        progressHandler: (progressEvent: ProgressEvent) => void\n    ): Promise<InternalStatus<Blob, DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.transferControllerDownload(\n                {\n                    ticket: ticket\n                },\n                {\n                    headers: {\n                        Accept: \"application/json, application/octet-stream\"\n                    },\n                    format: \"blob\",\n                    onDownloadProgress: progressHandler\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as Blob\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.TRANSFER_NOT_AVAILABLE, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async Upload(\n        ticket: string,\n        file: ArrayBuffer\n    ): Promise<InternalStatus<null, UploadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.transferControllerUpload(\n                {\n                    ticket: ticket\n                },\n                (file as unknown) as File,\n                {\n                    headers: {\n                        \"Content-Type\": \"application/octect-stream\"\n                    }\n                }\n            );\n        } catch (e) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: e as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: null\n                });\n            }\n            case 409: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.UPLOAD_FAILED, {\n                        void: true\n                    })\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.TRANSFER_NOT_AVAILABLE, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport {\n    AdministrationRights,\n    ErrorMessageResponse,\n    InstanceManagerRights,\n    PaginatedUserResponse,\n    UserCreateRequest,\n    UserResponse,\n    UserUpdateRequest\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\nimport LoginHooks from \"./util/LoginHooks\";\n\ninterface IEvents {\n    loadUserInfo: (user: InternalStatus<UserResponse, GenericErrors>) => void;\n}\n\nexport type GetCurrentUserErrors = GenericErrors;\nexport type EditUserErrors = GenericErrors | ErrorCode.USER_NOT_FOUND | GetCurrentUserErrors;\nexport type GetUserErrors = GenericErrors | ErrorCode.USER_NOT_FOUND;\nexport type CreateUserErrors = GenericErrors | ErrorCode.USER_NO_SYS_IDENT;\n\nexport default new (class UserClient extends ApiClient<IEvents> {\n    private _cachedUser?: InternalStatus<UserResponse, ErrorCode.OK>;\n    public get cachedUser() {\n        return this._cachedUser;\n    }\n    private loadingUserInfo = false;\n    //If set to true, all created users will default to having all permissions granted, used by the setup\n    public createAllUsersWithAA = false;\n\n    public constructor() {\n        super();\n        this.getCurrentUser = this.getCurrentUser.bind(this);\n\n        LoginHooks.addHook(() => this.getCurrentUser());\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedUser = undefined;\n        });\n    }\n\n    public async editUser(\n        newUser: UserUpdateRequest\n    ): Promise<InternalStatus<UserResponse, EditUserErrors>> {\n        await ServerClient.wait4Init();\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.userControllerUpdate(newUser);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<EditUserErrors>\n            });\n        }\n        // noinspection DuplicatedCode\n        switch (response.status) {\n            case 200: {\n                const current = await this.getCurrentUser();\n                if (current.code == StatusCode.OK) {\n                    if (current.payload.id == newUser.id) {\n                        //if we are editing ourselves, clear cached data to reload permissions on the app\n                        ServerClient.emit(\"purgeCache\");\n                    }\n                } else {\n                    return new InternalStatus({\n                        code: StatusCode.ERROR,\n                        error: current.error\n                    });\n                }\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n            }\n            case 404: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NOT_FOUND, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getCurrentUser(\n        bypassCache?: boolean\n    ): Promise<InternalStatus<UserResponse, GetCurrentUserErrors>> {\n        await ServerClient.wait4Init();\n\n        if (this._cachedUser && !bypassCache) {\n            return this._cachedUser;\n        }\n\n        if (this.loadingUserInfo) {\n            return await new Promise(resolve => {\n                const resolver = (user: InternalStatus<UserResponse, GenericErrors>) => {\n                    resolve(user);\n                    this.removeListener(\"loadUserInfo\", resolver);\n                };\n                this.on(\"loadUserInfo\", resolver);\n            });\n        }\n\n        this.loadingUserInfo = true;\n\n        let response;\n        try {\n            // UserController_Read\n            response = await ServerClient.apiClient!.api.userControllerRead();\n        } catch (stat) {\n            const res = new InternalStatus<UserResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadUserInfo\", res);\n            this.loadingUserInfo = false;\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const thing = new InternalStatus<UserResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n\n                this._cachedUser = thing;\n                this.emit(\"loadUserInfo\", thing);\n                this.loadingUserInfo = false;\n                return thing;\n            }\n            default: {\n                const res = new InternalStatus<UserResponse, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadUserInfo\", res);\n                this.loadingUserInfo = false;\n                return res;\n            }\n        }\n    }\n\n    public async listUsers({\n        page = 1,\n        pageSize = configOptions.itemsperpage.value as number\n    }): Promise<InternalStatus<PaginatedUserResponse, GenericErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.userControllerList({\n                page: page,\n                pageSize: pageSize\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const payload = (response.data as PaginatedUserResponse).content.sort(\n                    (a, b) => a.id - b.id\n                );\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedUserResponse),\n                        content: payload\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getUser(id: number): Promise<InternalStatus<UserResponse, GetUserErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.userControllerGetId(id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        // noinspection DuplicatedCode\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n            }\n            case 404: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NOT_FOUND, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async createUser(\n        newuser:\n            | {\n                  name: string;\n                  password: string;\n                  enabled?: boolean;\n                  instanceManagerRights?: InstanceManagerRights;\n                  administrationRights?: AdministrationRights;\n              }\n            | {\n                  systemIdentifier: string;\n                  enabled?: boolean;\n                  instanceManagerRights?: InstanceManagerRights;\n                  administrationRights?: AdministrationRights;\n              }\n    ): Promise<InternalStatus<UserResponse, CreateUserErrors>> {\n        await ServerClient.wait4Init();\n\n        if (newuser.enabled === undefined) newuser.enabled = true;\n        if (this.createAllUsersWithAA) {\n            newuser.instanceManagerRights = 0;\n            newuser.administrationRights = 0;\n\n            for (const perm of Object.values(InstanceManagerRights)) {\n                if (typeof perm !== \"number\") continue;\n                newuser.instanceManagerRights += perm;\n            }\n\n            for (const perm of Object.values(AdministrationRights)) {\n                if (typeof perm !== \"number\") continue;\n                newuser.administrationRights += perm;\n            }\n        }\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.userControllerCreate(\n                newuser as UserCreateRequest\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 201: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n            }\n            case 410: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NO_SYS_IDENT, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { DefaultListener, ListenerSignature, TypedEmitter } from \"tiny-typed-emitter\";\n\nexport abstract class ApiClient<\n    L extends ListenerSignature<L> = DefaultListener\n> extends TypedEmitter<L> {\n    public constructor() {\n        super();\n        if (window.clients == undefined) {\n            window.clients = {};\n        }\n        console.log(this.constructor.name, this);\n        window.clients[this.constructor.name] = this;\n    }\n}\n","/* eslint-disable */\n/* tslint:disable */\n/*\n * ---------------------------------------------------------------\n * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##\n * ##                                                           ##\n * ## AUTHOR: acacode                                           ##\n * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##\n * ---------------------------------------------------------------\n */\n\n/**\n * Represents administrative server information.\n */\nexport interface AdministrationResponse {\n  /**\n   * The GitHub repository the server is built to receive updates from.\n   * @format uri\n   */\n  trackedRepositoryUrl: string;\n\n  /** The latest available version of the Tgstation.Server.Host assembly from the upstream repository. If System.Version.Major is not equal to 4 the update cannot be applied due to API changes. */\n  latestVersion: string;\n}\n\n/**\n * Administration rights for the server.\n * @format int64\n */\nexport enum AdministrationRights {\n  None = 0,\n  WriteUsers = 1,\n  RestartHost = 2,\n  ChangeVersion = 4,\n  EditOwnPassword = 8,\n  ReadUsers = 16,\n  DownloadLogs = 32,\n  EditOwnOAuthConnections = 64,\n  UploadVersion = 128,\n}\n\n/**\n * Represents a request to update a chat bot.\n */\nexport interface ChatBotCreateRequest {\n  /** Channels the Discord bot should listen/announce in. */\n  channels?: ChatChannel[] | null;\n\n  /** If the connection is enabled. */\n  enabled?: boolean | null;\n\n  /**\n   * The time interval in minutes the chat bot attempts to reconnect if Tgstation.Server.Api.Models.Internal.ChatBotSettings.Enabled and disconnected. Must not be zero.\n   * @format int32\n   * @min 1\n   * @max 4294967295\n   */\n  reconnectionInterval?: number | null;\n\n  /**\n   * The maximum number of Tgstation.Server.Api.Models.ChatChannels the Tgstation.Server.Api.Models.Internal.ChatBotSettings may contain.\n   * @format int32\n   */\n  channelLimit?: number | null;\n\n  /** The Tgstation.Server.Api.Models.ChatProvider used for the connection. */\n  provider: ChatProvider;\n\n  /** The information used to connect to the Tgstation.Server.Api.Models.Internal.ChatBotSettings.Provider. */\n  connectionString: string;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name: string;\n}\n\n/**\n * Represents a chat bot response.\n */\nexport interface ChatBotResponse {\n  /** Channels the Discord bot should listen/announce in. */\n  channels: ChatChannel[];\n\n  /** If the connection is enabled. */\n  enabled: boolean;\n\n  /**\n   * The time interval in minutes the chat bot attempts to reconnect if Tgstation.Server.Api.Models.Internal.ChatBotSettings.Enabled and disconnected. Must not be zero.\n   * @format int32\n   * @min 1\n   * @max 4294967295\n   */\n  reconnectionInterval: number;\n\n  /**\n   * The maximum number of Tgstation.Server.Api.Models.ChatChannels the Tgstation.Server.Api.Models.Internal.ChatBotSettings may contain.\n   * @format int32\n   */\n  channelLimit: number;\n\n  /** The Tgstation.Server.Api.Models.ChatProvider used for the connection. */\n  provider: ChatProvider;\n\n  /** The information used to connect to the Tgstation.Server.Api.Models.Internal.ChatBotSettings.Provider. */\n  connectionString?: string | null;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name: string;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * Rights for chat bots.\n * @format int64\n */\nexport enum ChatBotRights {\n  None = 0,\n  WriteEnabled = 1,\n  WriteProvider = 2,\n  WriteChannels = 4,\n  WriteConnectionString = 8,\n  ReadConnectionString = 16,\n  Read = 32,\n  Create = 64,\n  Delete = 128,\n  WriteName = 256,\n  WriteReconnectionInterval = 512,\n  WriteChannelLimit = 1024,\n}\n\n/**\n * Represents a request to update a chat bot.\n */\nexport interface ChatBotUpdateRequest {\n  /** Channels the Discord bot should listen/announce in. */\n  channels?: ChatChannel[] | null;\n\n  /** If the connection is enabled. */\n  enabled?: boolean | null;\n\n  /**\n   * The time interval in minutes the chat bot attempts to reconnect if Tgstation.Server.Api.Models.Internal.ChatBotSettings.Enabled and disconnected. Must not be zero.\n   * @format int32\n   * @min 1\n   * @max 4294967295\n   */\n  reconnectionInterval?: number | null;\n\n  /**\n   * The maximum number of Tgstation.Server.Api.Models.ChatChannels the Tgstation.Server.Api.Models.Internal.ChatBotSettings may contain.\n   * @format int32\n   */\n  channelLimit?: number | null;\n\n  /** The Tgstation.Server.Api.Models.ChatProvider used for the connection. */\n  provider?: ChatProvider | null;\n\n  /** The information used to connect to the Tgstation.Server.Api.Models.Internal.ChatBotSettings.Provider. */\n  connectionString?: string | null;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name?: string | null;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * Indicates a chat channel.\n */\nexport interface ChatChannel {\n  /**\n   * The channel identifier.\n   * For Tgstation.Server.Api.Models.ChatProvider.Irc, it's the IRC channel name and optional password colon separated.\n   * For Tgstation.Server.Api.Models.ChatProvider.Discord, it's the stringified Discord channel snowflake.\n   */\n  channelData: string;\n\n  /** If the Tgstation.Server.Api.Models.ChatChannel is an admin channel. */\n  isAdminChannel: boolean;\n\n  /** If the Tgstation.Server.Api.Models.ChatChannel is a watchdog channel. */\n  isWatchdogChannel: boolean;\n\n  /** If the Tgstation.Server.Api.Models.ChatChannel is an updates channel. */\n  isUpdatesChannel: boolean;\n\n  /** If the Tgstation.Server.Api.Models.ChatChannel received system messages. */\n  isSystemChannel: boolean;\n\n  /** A custom tag users can define to group channels together. */\n  tag?: string | null;\n}\n\n/**\n * Represents a chat service provider.\n * @format int32\n */\nexport enum ChatProvider {\n  Irc = 0,\n  Discord = 1,\n}\n\nexport interface CompileJobResponse {\n  /** The Tgstation.Server.Api.Models.Response.CompileJobResponse.Job relating to this job. */\n  job: JobResponse;\n\n  /** Git revision the compiler ran on. */\n  revisionInformation: RevisionInformation;\n\n  /** The Tgstation.Server.Api.Models.Response.CompileJobResponse.EngineVersion the Tgstation.Server.Api.Models.Response.CompileJobResponse was made with. */\n  engineVersion: EngineVersion;\n\n  /**\n   * The origin System.Uri of the repository the compile job was built from.\n   * @format uri\n   */\n  repositoryOrigin: string;\n\n  /** The .dme file used for compilation. */\n  dmeName: string;\n\n  /** Textual output of DM. */\n  output: string;\n\n  /**\n   * The Game folder the results were compiled into.\n   * @format uuid\n   */\n  directoryName: string;\n\n  /** The minimum Tgstation.Server.Api.Models.DreamDaemonSecurity required to run the Tgstation.Server.Api.Models.Internal.CompileJob's output. */\n  minimumSecurityLevel?: DreamDaemonSecurity | null;\n\n  /** The DMAPI System.Version. */\n  dmApiVersion?: string | null;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * Represents a request to update a configuration file.\n */\nexport interface ConfigurationFileRequest {\n  path: string;\n  lastReadHash?: string | null;\n}\n\n/**\n * Response when reading configuration files.\n */\nexport interface ConfigurationFileResponse {\n  path: string;\n  lastReadHash?: string | null;\n\n  /** If Tgstation.Server.Api.Models.Response.ConfigurationFileResponse.Path represents a directory. */\n  isDirectory: boolean;\n\n  /** If access to the Tgstation.Server.Api.Models.IConfigurationFile file was denied for the operation. */\n  accessDenied?: boolean | null;\n\n  /** The ticket to use to access the Tgstation.Server.Api.Routes.Transfer controller. */\n  fileTicket: string;\n}\n\n/**\n * Rights for Tgstation.Server.Api.Models.IConfigurationFiles.\n * @format int64\n */\nexport enum ConfigurationRights {\n  None = 0,\n  Read = 1,\n  Write = 2,\n  List = 4,\n  Delete = 8,\n}\n\n/**\n * The type of configuration allowed on an Tgstation.Server.Api.Models.Instance.\n * @format int32\n */\nexport enum ConfigurationType {\n  Disallowed = 0,\n  HostWrite = 1,\n  SystemIdentityWrite = 2,\n}\n\n/**\n * A request to update Tgstation.Server.Api.Models.Internal.DreamDaemonSettings.\n */\nexport interface DreamDaemonRequest {\n  /** A System.String to send to the running server's DMAPI for broadcasting. How this is displayed is up to how the DMAPI is integrated in the codebase. Requires interop version >=5.7.0. */\n  broadcastMessage?: string | null;\n\n  /**\n   * An incrementing ID for representing current server execution.\n   * @format int64\n   */\n  sessionId?: number | null;\n\n  /** If the server is undergoing a soft reset. This may be automatically set by changes to other fields. */\n  softRestart?: boolean | null;\n\n  /** If the server is undergoing a soft shutdown. */\n  softShutdown?: boolean | null;\n\n  /** If the watchdog starts when it's Tgstation.Server.Api.Models.Instance starts. */\n  autoStart?: boolean | null;\n\n  /** If the BYOND web client can be used to connect to the game server. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  allowWebClient?: boolean | null;\n\n  /** If -profile is passed in on the DreamDaemon command line. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  startProfiler?: boolean | null;\n\n  /** The Tgstation.Server.Api.Models.DreamDaemonVisibility level of DreamDaemon. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  visibility?: DreamDaemonVisibility | null;\n\n  /** The Tgstation.Server.Api.Models.DreamDaemonSecurity level of DreamDaemon. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  securityLevel?: DreamDaemonSecurity | null;\n\n  /**\n   * The port DreamDaemon uses. This should be publically accessible.\n   * @format int32\n   * @min 1\n   * @max 65535\n   */\n  port?: number | null;\n\n  /**\n   * The DreamDaemon startup timeout in seconds.\n   * @format int32\n   * @min 1\n   * @max 4294967295\n   */\n  startupTimeout?: number | null;\n\n  /**\n   * The number of seconds between each watchdog health check. 0 disables.\n   * @format int32\n   */\n  healthCheckSeconds?: number | null;\n\n  /** If a process core dump should be created prior to restarting the watchdog due to health check failure. */\n  dumpOnHealthCheckRestart?: boolean | null;\n\n  /**\n   * The timeout for sending and receiving BYOND topics in milliseconds.\n   * @format int32\n   * @min 1\n   * @max 4294967295\n   */\n  topicRequestTimeout?: number | null;\n\n  /** Parameters string for DreamDaemon. */\n  additionalParameters?: string | null;\n\n  /** If process output/error text should be logged. */\n  logOutput?: boolean | null;\n\n  /**\n   * If DreamDaemon supports it, the value added as the -map-threads parameter. 0 uses the default BYOND value. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream.\n   * @format int32\n   */\n  mapThreads?: number | null;\n\n  /** If minidumps should be taken instead of full dumps. */\n  minidumps?: boolean | null;\n}\n\n/**\n * Represents an instance of BYOND's DreamDaemon game server. Create action starts the server. Delete action shuts down the server.\n */\nexport interface DreamDaemonResponse {\n  /** The live revision. */\n  activeCompileJob?: CompileJobResponse | null;\n\n  /** The next revision to go live. */\n  stagedCompileJob?: CompileJobResponse | null;\n\n  /** The current Tgstation.Server.Api.Models.WatchdogStatus. */\n  status?: WatchdogStatus | null;\n\n  /** The current Tgstation.Server.Api.Models.DreamDaemonSecurity. May be upgraded. due to requirements of Tgstation.Server.Api.Models.Response.DreamDaemonResponse.ActiveCompileJob. */\n  currentSecurity?: DreamDaemonSecurity | null;\n\n  /** The current Tgstation.Server.Api.Models.DreamDaemonVisibility. */\n  currentVisibility?: DreamDaemonVisibility | null;\n\n  /**\n   * The port the running Tgstation.Server.Api.Models.Response.DreamDaemonResponse instance is set to.\n   * @format int32\n   */\n  currentPort?: number | null;\n\n  /** The webclient status the running Tgstation.Server.Api.Models.Response.DreamDaemonResponse instance is set to. */\n  currentAllowWebclient?: boolean | null;\n\n  /**\n   * An incrementing ID for representing current server execution.\n   * @format int64\n   */\n  sessionId?: number | null;\n\n  /** If the server is undergoing a soft reset. This may be automatically set by changes to other fields. */\n  softRestart?: boolean | null;\n\n  /** If the server is undergoing a soft shutdown. */\n  softShutdown?: boolean | null;\n\n  /** If the watchdog starts when it's Tgstation.Server.Api.Models.Instance starts. */\n  autoStart?: boolean | null;\n\n  /** If the BYOND web client can be used to connect to the game server. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  allowWebClient?: boolean | null;\n\n  /** If -profile is passed in on the DreamDaemon command line. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  startProfiler?: boolean | null;\n\n  /** The Tgstation.Server.Api.Models.DreamDaemonVisibility level of DreamDaemon. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  visibility?: DreamDaemonVisibility | null;\n\n  /** The Tgstation.Server.Api.Models.DreamDaemonSecurity level of DreamDaemon. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  securityLevel?: DreamDaemonSecurity | null;\n\n  /**\n   * The port DreamDaemon uses. This should be publically accessible.\n   * @format int32\n   * @min 1\n   * @max 65535\n   */\n  port?: number | null;\n\n  /**\n   * The DreamDaemon startup timeout in seconds.\n   * @format int32\n   * @min 1\n   * @max 4294967295\n   */\n  startupTimeout?: number | null;\n\n  /**\n   * The number of seconds between each watchdog health check. 0 disables.\n   * @format int32\n   */\n  healthCheckSeconds?: number | null;\n\n  /** If a process core dump should be created prior to restarting the watchdog due to health check failure. */\n  dumpOnHealthCheckRestart?: boolean | null;\n\n  /**\n   * The timeout for sending and receiving BYOND topics in milliseconds.\n   * @format int32\n   * @min 1\n   * @max 4294967295\n   */\n  topicRequestTimeout?: number | null;\n\n  /** Parameters string for DreamDaemon. */\n  additionalParameters?: string | null;\n\n  /** If process output/error text should be logged. */\n  logOutput?: boolean | null;\n\n  /**\n   * If DreamDaemon supports it, the value added as the -map-threads parameter. 0 uses the default BYOND value. No-op for Tgstation.Server.Api.Models.EngineType.OpenDream.\n   * @format int32\n   */\n  mapThreads?: number | null;\n\n  /** If minidumps should be taken instead of full dumps. */\n  minidumps?: boolean | null;\n}\n\n/**\n * Rights for managing DreamDaemon.\n * @format int64\n */\nexport enum DreamDaemonRights {\n  None = 0,\n  ReadRevision = 1,\n  SetPort = 2,\n  SetAutoStart = 4,\n  SetSecurity = 8,\n  ReadMetadata = 16,\n  SetWebClient = 32,\n  SoftRestart = 64,\n  SoftShutdown = 128,\n  Restart = 256,\n  Shutdown = 512,\n  Start = 1024,\n  SetStartupTimeout = 2048,\n  SetHealthCheckInterval = 4096,\n  CreateDump = 8192,\n  SetTopicTimeout = 16384,\n  SetAdditionalParameters = 32768,\n  SetVisibility = 65536,\n  SetProfiler = 131072,\n  SetLogOutput = 262144,\n  SetMapThreads = 524288,\n  BroadcastMessage = 1048576,\n  SetMinidumps = 2097152,\n}\n\n/**\n * DreamDaemon's security level.\n * @format int32\n */\nexport enum DreamDaemonSecurity {\n  Trusted = 0,\n  Safe = 1,\n  Ultrasafe = 2,\n}\n\n/**\n * The visibility setting for DreamDaemon.\n * @format int32\n */\nexport enum DreamDaemonVisibility {\n  Public = 0,\n  Private = 1,\n  Invisible = 2,\n}\n\n/**\n * A request to the DreamMaker controller.\n */\nexport interface DreamMakerRequest {\n  /** The name of the .dme file the server tries to compile with without the extension. */\n  projectName?: string | null;\n\n  /**\n   * The port used during compilation to validate the DMAPI.\n   * @format int32\n   * @min 1\n   * @max 65535\n   */\n  apiValidationPort?: number | null;\n\n  /** The Tgstation.Server.Api.Models.DreamDaemonSecurity level used to validate the DMAPI. */\n  apiValidationSecurityLevel?: DreamDaemonSecurity | null;\n\n  /** If API validation should be required for a deployment to succeed. */\n  requireDMApiValidation?: boolean | null;\n\n  /**\n   * Amount of time before an in-progress deployment is cancelled.\n   * @format date-span\n   */\n  timeout?: string | null;\n\n  /** Additional arguments added to the compiler command line. */\n  compilerAdditionalArguments?: string | null;\n}\n\n/**\n * A request to the DreamMaker controller.\n */\nexport interface DreamMakerResponse {\n  /** The name of the .dme file the server tries to compile with without the extension. */\n  projectName?: string | null;\n\n  /**\n   * The port used during compilation to validate the DMAPI.\n   * @format int32\n   * @min 1\n   * @max 65535\n   */\n  apiValidationPort: number;\n\n  /** The Tgstation.Server.Api.Models.DreamDaemonSecurity level used to validate the DMAPI. */\n  apiValidationSecurityLevel: DreamDaemonSecurity;\n\n  /** If API validation should be required for a deployment to succeed. */\n  requireDMApiValidation: boolean;\n\n  /**\n   * Amount of time before an in-progress deployment is cancelled.\n   * @format date-span\n   */\n  timeout: string;\n\n  /** Additional arguments added to the compiler command line. */\n  compilerAdditionalArguments?: string | null;\n}\n\n/**\n * Rights for deployment.\n * @format int64\n */\nexport enum DreamMakerRights {\n  None = 0,\n  Read = 1,\n  Compile = 2,\n  CancelCompile = 4,\n  SetDme = 8,\n  SetApiValidationPort = 16,\n  CompileJobs = 32,\n  SetSecurityLevel = 64,\n  SetApiValidationRequirement = 128,\n  SetTimeout = 256,\n  SetCompilerArguments = 512,\n}\n\n/**\n * Represents an engine installation job. Tgstation.Server.Api.Models.Response.FileTicketResponse.FileTicket is used to upload custom version zip files.\n */\nexport interface EngineInstallResponse {\n  /** The Tgstation.Server.Api.Models.Response.JobResponse being used to install a new Tgstation.Server.Api.Models.EngineVersion. */\n  installJob?: JobResponse | null;\n  fileTicket?: string | null;\n}\n\n/**\n * Represents an installed Tgstation.Server.Api.Models.EngineVersion.\n */\nexport interface EngineResponse {\n  /** The represented Tgstation.Server.Api.Models.EngineVersion. If null that indicates none were found. */\n  engineVersion: EngineVersion;\n}\n\n/**\n * Rights for engine version management.\n * @format int64\n */\nexport enum EngineRights {\n  None = 0,\n  ReadActive = 1,\n  ListInstalled = 2,\n  InstallOfficialOrChangeActiveByondVersion = 4,\n  CancelInstall = 8,\n  InstallCustomByondVersion = 16,\n  DeleteInstall = 32,\n  InstallOfficialOrChangeActiveOpenDreamVersion = 64,\n  InstallCustomOpenDreamVersion = 128,\n}\n\n/**\n * The type of engine the codebase is using.\n * @format int32\n */\nexport enum EngineType {\n  Byond = 0,\n  OpenDream = 1,\n}\n\n/**\n * Information about an engine installation.\n */\nexport interface EngineVersion {\n  /** The Tgstation.Server.Api.Models.EngineType. */\n  engine: EngineType;\n\n  /** The System.Version of the engine. Currently only valid when Tgstation.Server.Api.Models.EngineVersion.Engine is Tgstation.Server.Api.Models.EngineType.Byond. */\n  version?: string | null;\n\n  /** The git commit SHA of the engine. Currently only valid when Tgstation.Server.Api.Models.EngineVersion.Engine is Tgstation.Server.Api.Models.EngineType.OpenDream. */\n  sourceSHA?: string | null;\n\n  /**\n   * The revision of the custom build.\n   * @format int32\n   */\n  customIteration?: number | null;\n}\n\n/**\n * A request to delete a specific Tgstation.Server.Api.Models.Request.EngineVersionDeleteRequest.EngineVersion.\n */\nexport interface EngineVersionDeleteRequest {\n  /** The Tgstation.Server.Api.Models.EngineVersion to delete. */\n  engineVersion?: EngineVersion | null;\n}\n\n/**\n * A request to switch to a given Tgstation.Server.Api.Models.Request.EngineVersionRequest.EngineVersion.\n */\nexport interface EngineVersionRequest {\n  /** The Tgstation.Server.Api.Models.EngineVersion to switch to. */\n  engineVersion?: EngineVersion | null;\n\n  /** If a custom BYOND version is to be uploaded. */\n  uploadCustomZip?: boolean | null;\n}\n\n/**\n * Common base of entities with IDs.\n */\nexport interface EntityId {\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id?: number | null;\n}\n\n/**\n * Types of Tgstation.Server.Api.Models.Response.ErrorMessageResponses that the API may return.\n * @format int32\n */\nexport enum ErrorCode {\n  InternalServerError = 0,\n  ApiMismatch = 1,\n  ModelValidationFailure = 2,\n  IOError = 3,\n  BadHeaders = 4,\n  TokenWithToken = 5,\n  DatabaseIntegrityConflict = 6,\n  MissingHostWatchdog = 7,\n  CannotChangeServerSuite = 8,\n  RemoteApiError = 9,\n  ServerUpdateInProgress = 10,\n  UserNameChange = 11,\n  UserSidChange = 12,\n  UserMismatchNameSid = 13,\n  UserMismatchPasswordSid = 14,\n  UserPasswordLength = 15,\n  UserColonInName = 16,\n  UserMissingName = 17,\n  InstanceRelocateOnline = 18,\n  InstanceAtExistingPath = 19,\n  InstanceDetachOnline = 20,\n  InstanceAtConflictingPath = 21,\n  InstanceLimitReached = 22,\n  InstanceWhitespaceNameOrPath = 23,\n  InstanceHeaderRequired = 24,\n  RequiresPosixSystemIdentity = 25,\n  ConfigurationFileUpdated = 26,\n  ConfigurationDirectoryNotEmpty = 27,\n  SwarmIntegrityCheckFailed = 28,\n  RepoMismatchUserAndAccessToken = 29,\n  RepoCloning = 30,\n  RepoBusy = 31,\n  RepoExists = 32,\n  RepoMissing = 33,\n  RepoMismatchShaAndReference = 34,\n  RepoMismatchShaAndUpdate = 35,\n  EngineCannotDeleteActiveVersion = 36,\n  RepoDuplicateTestMerge = 37,\n  RepoWhitespaceCommitterName = 38,\n  RepoWhitespaceCommitterEmail = 39,\n  ApiPageTooLarge = 40,\n  ApiInvalidPageOrPageSize = 41,\n  ChatBotWrongChannelType = 42,\n  ChatBotWhitespaceConnectionString = 43,\n  ChatBotWhitespaceName = 44,\n  ChatBotProviderMissing = 45,\n  ConfigurationContendedAccess = 46,\n  ChatBotMax = 47,\n  ChatBotMaxChannels = 48,\n  ByondDirectXInstallFail = 49,\n  EngineDownloadFail = 50,\n  EngineNoVersionsInstalled = 51,\n  DeploymentNeverValidated = 52,\n  DeploymentInvalidValidation = 53,\n  CannotRemoveLastAuthenticationOption = 54,\n  DeploymentNoDme = 55,\n  DeploymentMissingDme = 56,\n  DeploymentExitCode = 57,\n  DeploymentInProgress = 58,\n  InstanceMissingDreamDaemonSettings = 59,\n  InstanceMissingDreamMakerSettings = 60,\n  InstanceMissingRepositorySettings = 61,\n  InstanceUpdateTestMergeConflict = 62,\n  RepoCredentialsRequired = 63,\n  RepoCannotAuthenticate = 64,\n  RepoReferenceRequired = 65,\n  WatchdogRunning = 66,\n  WatchdogCompileJobCorrupted = 67,\n  WatchdogStartupFailed = 68,\n  WatchdogStartupTimeout = 69,\n  RepoUnsupportedTestMergeRemote = 70,\n  RepoSwappedShaOrReference = 71,\n  RepoMergeConflict = 72,\n  RepoReferenceNotTracking = 73,\n  RepoTestMergeConflict = 74,\n  InstanceNotAtWhitelistedPath = 75,\n  GameServerDoubleSoft = 76,\n  DreamDaemonPagerRunning = 77,\n  GameServerPortInUse = 78,\n  PostDeployFailure = 79,\n  WatchdogNotRunning = 80,\n  ResourceNotPresent = 81,\n  ResourceNeverPresent = 82,\n  GitHubApiRateLimit = 83,\n  JobStopped = 84,\n  MissingGCore = 85,\n  GCoreFailure = 86,\n  RepoTestMergeInvalidRemote = 87,\n  EngineNonExistentCustomVersion = 88,\n  GameServerOffline = 89,\n  InstanceOffline = 90,\n  ChatCannotConnectProvider = 91,\n  EngineFirewallFail = 92,\n  NoPortsAvailable = 93,\n  PortNotAvailable = 94,\n  AdminUserCannotOAuth = 95,\n  OAuthProviderDisabled = 96,\n  FileUploadExpired = 97,\n  UserGroupAndPermissionSet = 98,\n  UserGroupNotEmpty = 99,\n  UserLimitReached = 100,\n  UserGroupLimitReached = 101,\n  DeploymentTimeout = 102,\n  BroadcastFailure = 103,\n  OpenDreamCantFindDotnet = 104,\n  OpenDreamTooOld = 105,\n  DotnetDiagnosticsFailure = 106,\n}\n\n/**\n * Represents an error message returned by the server.\n */\nexport interface ErrorMessageResponse {\n  /** The version of the API the server is using. */\n  serverApiVersion: string;\n\n  /** A human readable description of the error. */\n  message: string;\n\n  /** Additional data associated with the error message. */\n  additionalData?: string | null;\n\n  /** The Tgstation.Server.Api.Models.Response.ErrorMessageResponse.ErrorCode of the Tgstation.Server.Api.Models.Response.ErrorMessageResponse. */\n  errorCode: ErrorCode;\n}\n\n/**\n * A request to create an Tgstation.Server.Api.Models.Instance.\n */\nexport interface InstanceCreateRequest {\n  /** The path to where the Tgstation.Server.Api.Models.Instance is located. Can only be changed while the Tgstation.Server.Api.Models.Instance is offline. Must not exist when the instance is created. */\n  path: string;\n\n  /** If Tgstation.Server.Api.Models.IConfigurationFiles can be used on the Tgstation.Server.Api.Models.Instance. */\n  configurationType?: ConfigurationType | null;\n\n  /**\n   * The time interval in minutes the repository is automatically pulled and compiles. 0 disables.\n   * @format int32\n   */\n  autoUpdateInterval?: number | null;\n\n  /** A cron expression indicating when auto-updates should trigger. Must be a valid 6 part cron schedule (SECONDS MINUTES HOURS DAY/MONTH MONTH DAY/WEEK). Empty System.String disables. */\n  autoUpdateCron?: string | null;\n\n  /**\n   * The maximum number of chat bots the Tgstation.Server.Api.Models.Instance may contain.\n   * @format int32\n   */\n  chatBotLimit?: number | null;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name: string;\n}\n\n/**\n * Rights for managing Tgstation.Server.Api.Models.Instances.\n * @format int64\n */\nexport enum InstanceManagerRights {\n  None = 0,\n  Read = 1,\n  Create = 2,\n  Rename = 4,\n  Relocate = 8,\n  SetOnline = 16,\n  Delete = 32,\n  List = 64,\n  SetConfiguration = 128,\n  SetAutoUpdate = 256,\n  SetChatBotLimit = 512,\n  GrantPermissions = 1024,\n}\n\n/**\n * A request to update an instance permission set.\n */\nexport interface InstancePermissionSetRequest {\n  /**\n   * The Tgstation.Server.Api.Models.EntityId.Id of the Tgstation.Server.Api.Models.PermissionSet the Tgstation.Server.Api.Models.Internal.InstancePermissionSet belongs to.\n   * @format int64\n   */\n  permissionSetId: number;\n\n  /** The Tgstation.Server.Api.Rights.InstancePermissionSetRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  instancePermissionSetRights?: InstancePermissionSetRights | null;\n\n  /** The Tgstation.Server.Api.Rights.EngineRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  engineRights?: EngineRights | null;\n\n  /** The Tgstation.Server.Api.Rights.DreamDaemonRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  dreamDaemonRights?: DreamDaemonRights | null;\n\n  /** The Tgstation.Server.Api.Rights.DreamMakerRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  dreamMakerRights?: DreamMakerRights | null;\n\n  /** The Tgstation.Server.Api.Rights.RepositoryRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  repositoryRights?: RepositoryRights | null;\n\n  /** The Tgstation.Server.Api.Rights.ChatBotRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  chatBotRights?: ChatBotRights | null;\n\n  /** The Tgstation.Server.Api.Rights.ConfigurationRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  configurationRights?: ConfigurationRights | null;\n}\n\n/**\n * A response containing an instance permission set.\n */\nexport interface InstancePermissionSetResponse {\n  /**\n   * The Tgstation.Server.Api.Models.EntityId.Id of the Tgstation.Server.Api.Models.PermissionSet the Tgstation.Server.Api.Models.Internal.InstancePermissionSet belongs to.\n   * @format int64\n   */\n  permissionSetId: number;\n\n  /** The Tgstation.Server.Api.Rights.InstancePermissionSetRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  instancePermissionSetRights: InstancePermissionSetRights;\n\n  /** The Tgstation.Server.Api.Rights.EngineRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  engineRights: EngineRights;\n\n  /** The Tgstation.Server.Api.Rights.DreamDaemonRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  dreamDaemonRights: DreamDaemonRights;\n\n  /** The Tgstation.Server.Api.Rights.DreamMakerRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  dreamMakerRights: DreamMakerRights;\n\n  /** The Tgstation.Server.Api.Rights.RepositoryRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  repositoryRights: RepositoryRights;\n\n  /** The Tgstation.Server.Api.Rights.ChatBotRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  chatBotRights: ChatBotRights;\n\n  /** The Tgstation.Server.Api.Rights.ConfigurationRights of the Tgstation.Server.Api.Models.Internal.InstancePermissionSet. */\n  configurationRights: ConfigurationRights;\n}\n\n/**\n * Rights for an Tgstation.Server.Api.Models.Instance.\n * @format int64\n */\nexport enum InstancePermissionSetRights {\n  None = 0,\n  Read = 1,\n  Write = 2,\n  Create = 4,\n}\n\n/**\n * Server response for Tgstation.Server.Api.Models.Instances.\n */\nexport interface InstanceResponse {\n  /** The Tgstation.Server.Api.Models.Response.JobResponse representing a change of Tgstation.Server.Api.Models.Instance.Path. */\n  moveJob?: JobResponse | null;\n\n  /** If the querying user may access this instance. */\n  accessible: boolean;\n\n  /** The path to where the Tgstation.Server.Api.Models.Instance is located. Can only be changed while the Tgstation.Server.Api.Models.Instance is offline. Must not exist when the instance is created. */\n  path: string;\n\n  /** If the Tgstation.Server.Api.Models.Instance is online. */\n  online: boolean;\n\n  /** If Tgstation.Server.Api.Models.IConfigurationFiles can be used on the Tgstation.Server.Api.Models.Instance. */\n  configurationType: ConfigurationType;\n\n  /**\n   * The time interval in minutes the repository is automatically pulled and compiles. 0 disables.\n   * @format int32\n   */\n  autoUpdateInterval: number;\n\n  /** A cron expression indicating when auto-updates should trigger. Must be a valid 6 part cron schedule (SECONDS MINUTES HOURS DAY/MONTH MONTH DAY/WEEK). Empty System.String disables. */\n  autoUpdateCron: string;\n\n  /**\n   * The maximum number of chat bots the Tgstation.Server.Api.Models.Instance may contain.\n   * @format int32\n   */\n  chatBotLimit: number;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name: string;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * A request to update an Tgstation.Server.Api.Models.Instance.\n */\nexport interface InstanceUpdateRequest {\n  /** The path to where the Tgstation.Server.Api.Models.Instance is located. Can only be changed while the Tgstation.Server.Api.Models.Instance is offline. Must not exist when the instance is created. */\n  path?: string | null;\n\n  /** If the Tgstation.Server.Api.Models.Instance is online. */\n  online?: boolean | null;\n\n  /** If Tgstation.Server.Api.Models.IConfigurationFiles can be used on the Tgstation.Server.Api.Models.Instance. */\n  configurationType?: ConfigurationType | null;\n\n  /**\n   * The time interval in minutes the repository is automatically pulled and compiles. 0 disables.\n   * @format int32\n   */\n  autoUpdateInterval?: number | null;\n\n  /** A cron expression indicating when auto-updates should trigger. Must be a valid 6 part cron schedule (SECONDS MINUTES HOURS DAY/MONTH MONTH DAY/WEEK). Empty System.String disables. */\n  autoUpdateCron?: string | null;\n\n  /**\n   * The maximum number of chat bots the Tgstation.Server.Api.Models.Instance may contain.\n   * @format int32\n   */\n  chatBotLimit?: number | null;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name?: string | null;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * The different types of Tgstation.Server.Api.Models.Response.JobResponse.\n * @format int32\n */\nexport enum JobCode {\n  Unknown = 0,\n  Move = 1,\n  RepositoryClone = 2,\n  RepositoryUpdate = 3,\n  RepositoryAutoUpdate = 4,\n  RepositoryDelete = 5,\n  EngineOfficialInstall = 6,\n  EngineCustomInstall = 7,\n  EngineDelete = 8,\n  Deployment = 9,\n  AutomaticDeployment = 10,\n  WatchdogLaunch = 11,\n  WatchdogRestart = 12,\n  WatchdogDump = 13,\n  StartupWatchdogLaunch = 14,\n  StartupWatchdogReattach = 15,\n  ReconnectChatBot = 16,\n}\n\n/**\n * Represents a long running job on the server. Model is read-only, updates attempt to cancel the job.\n */\nexport interface JobResponse {\n  /**\n   * The Tgstation.Server.Api.Models.EntityId.Id of the Tgstation.Server.Api.Models.Instance.\n   * @format int64\n   */\n  instanceId: number;\n\n  /** The Tgstation.Server.Api.Models.Response.UserResponse that started the job. */\n  startedBy: ShallowUserResponse;\n\n  /** The Tgstation.Server.Api.Models.Response.UserResponse that cancelled the job. */\n  cancelledBy?: ShallowUserResponse | null;\n\n  /**\n   * Optional progress between 0 and 100 inclusive.\n   * @format int32\n   */\n  progress?: number | null;\n\n  /** Optional description of the job's current . */\n  stage?: string | null;\n\n  /** The Tgstation.Server.Api.Models.JobCode. */\n  jobCode: JobCode;\n\n  /** English description of the Tgstation.Server.Api.Models.Internal.Job. */\n  description: string;\n\n  /** The Tgstation.Server.Api.Models.ErrorCode associated with the Tgstation.Server.Api.Models.Internal.Job if any. */\n  errorCode?: ErrorCode | null;\n\n  /** Details of any exceptions caught during the Tgstation.Server.Api.Models.Internal.Job. */\n  exceptionDetails?: string | null;\n\n  /**\n   * When the Tgstation.Server.Api.Models.Internal.Job was started.\n   * @format date-time\n   */\n  startedAt: string;\n\n  /**\n   * When the Tgstation.Server.Api.Models.Internal.Job stopped.\n   * @format date-time\n   */\n  stoppedAt?: string | null;\n\n  /** If the Tgstation.Server.Api.Models.Internal.Job was cancelled. */\n  cancelled: boolean;\n\n  /** The Tgstation.Server.Api.Rights.RightsType of Tgstation.Server.Api.Models.Internal.Job.CancelRight if it can be cancelled. */\n  cancelRightsType?: RightsType | null;\n\n  /**\n   * The N:Tgstation.Server.Api.Rights required to cancel the Tgstation.Server.Api.Models.Internal.Job.\n   * @format int64\n   */\n  cancelRight?: number | null;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * Represents a server log file.\n */\nexport interface LogFileResponse {\n  /** The name of the log file. */\n  name: string;\n\n  /**\n   * The System.DateTimeOffset of when the log file was modified.\n   * @format date-time\n   */\n  lastModified: string;\n\n  /** The ticket to use to access the Tgstation.Server.Api.Routes.Transfer controller. */\n  fileTicket: string;\n}\n\n/**\n * Represents a valid OAuth connection.\n */\nexport interface OAuthConnection {\n  /** The Tgstation.Server.Api.Models.OAuthProvider of the Tgstation.Server.Api.Models.OAuthConnection. */\n  provider: OAuthProvider;\n\n  /** The ID of the user in the Tgstation.Server.Api.Models.OAuthConnection.Provider. */\n  externalUserId: string;\n}\n\n/**\n * List of OAuth providers supported by TGS.\n */\nexport enum OAuthProvider {\n  GitHub = \"GitHub\",\n  Discord = \"Discord\",\n  TGForums = \"TGForums\",\n  Keycloak = \"Keycloak\",\n  InvisionCommunity = \"InvisionCommunity\",\n}\n\n/**\n * Public information about a given Tgstation.Server.Api.Models.OAuthProvider.\n */\nexport interface OAuthProviderInfo {\n  /** The client ID. */\n  clientId: string;\n\n  /**\n   * The redirect URL.\n   * @format uri\n   */\n  redirectUri: string;\n\n  /**\n   * The server URL.\n   * @format uri\n   */\n  serverUrl?: string | null;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedChatBotResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: ChatBotResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedCompileJobResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: CompileJobResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedConfigurationFileResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: ConfigurationFileResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedEngineResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: EngineResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedInstancePermissionSetResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: InstancePermissionSetResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedInstanceResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: InstanceResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedJobResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: JobResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedLogFileResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: LogFileResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedUserGroupResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: UserGroupResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a paginated set of models.\n */\nexport interface PaginatedUserResponse {\n  /** The System.Collections.Generic.ICollection`1 of the returned <typeparamref name=\"TModel\" />s. */\n  content: UserResponse[];\n\n  /**\n   * The total number of pages in the query.\n   * @format int32\n   */\n  totalPages: number;\n\n  /**\n   * The current size of pages in the query.\n   * @format int32\n   */\n  pageSize: number;\n\n  /**\n   * The total items across all pages.\n   * @format int32\n   */\n  totalItems: number;\n}\n\n/**\n * Represents a set of server permissions.\n */\nexport interface PermissionSet {\n  /** @format int64 */\n  id?: number | null;\n\n  /** The Tgstation.Server.Api.Rights.AdministrationRights for the user. */\n  administrationRights: AdministrationRights;\n\n  /** The Tgstation.Server.Api.Rights.InstanceManagerRights for the user. */\n  instanceManagerRights: InstanceManagerRights;\n}\n\n/**\n * Indicates the remote git host.\n * @format int32\n */\nexport enum RemoteGitProvider {\n  Unknown = 0,\n  GitHub = 1,\n  GitLab = 2,\n}\n\n/**\n * Represents a request to clone the repository.\n */\nexport interface RepositoryCreateRequest {\n  /**\n   * The origin URL to clone.\n   * @format uri\n   */\n  origin: string;\n\n  /** The branch or tag HEAD points to. */\n  reference?: string | null;\n\n  /** The name of the committer. */\n  committerName?: string | null;\n\n  /**\n   * The e-mail of the committer.\n   * @format email\n   */\n  committerEmail?: string | null;\n\n  /** The username to access the git repository with. */\n  accessUser?: string | null;\n\n  /** The token/password to access the git repository with. */\n  accessToken?: string | null;\n\n  /** If commits created from testmerges are pushed to the remote. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser and Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  pushTestMergeCommits?: boolean | null;\n\n  /** If GitHub deployments should be created. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser, Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken, and Tgstation.Server.Api.Models.Internal.RepositorySettings.PushTestMergeCommits to be set to function. */\n  createGitHubDeployments?: boolean | null;\n\n  /** If test merge commits are signed with the username of the person who merged it. Note this only affects future commits. */\n  showTestMergeCommitters?: boolean | null;\n\n  /** If test merge commits should be kept when auto updating. May cause merge conflicts which will block the update. */\n  autoUpdatesKeepTestMerges?: boolean | null;\n\n  /** If synchronization should occur when auto updating. Requries Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser and Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  autoUpdatesSynchronize?: boolean | null;\n\n  /** If test merging should create a comment. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  postTestMergeComment?: boolean | null;\n\n  /** Do the equivalent of a `git submodule update --init` alongside any resets to origin, checkouts, or test merge additions. Note that this action is recursive ONLY during cloning. */\n  updateSubmodules?: boolean | null;\n}\n\n/**\n * Represents a git repository.\n */\nexport interface RepositoryResponse {\n  /**\n   * The origin URL. If null, the git repository does not currently exist on the server.\n   * @format uri\n   */\n  origin?: string | null;\n\n  /** The current Tgstation.Server.Api.Models.RevisionInformation. */\n  revisionInformation?: RevisionInformation | null;\n  remoteGitProvider?: RemoteGitProvider | null;\n  remoteRepositoryOwner?: string | null;\n  remoteRepositoryName?: string | null;\n\n  /** The Tgstation.Server.Api.Models.Response.JobResponse started by the request, if any. */\n  activeJob?: JobResponse | null;\n\n  /** The branch or tag HEAD points to. */\n  reference?: string | null;\n\n  /** The name of the committer. */\n  committerName: string;\n\n  /**\n   * The e-mail of the committer.\n   * @format email\n   */\n  committerEmail: string;\n\n  /** The username to access the git repository with. */\n  accessUser?: string | null;\n\n  /** If commits created from testmerges are pushed to the remote. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser and Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  pushTestMergeCommits: boolean;\n\n  /** If GitHub deployments should be created. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser, Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken, and Tgstation.Server.Api.Models.Internal.RepositorySettings.PushTestMergeCommits to be set to function. */\n  createGitHubDeployments: boolean;\n\n  /** If test merge commits are signed with the username of the person who merged it. Note this only affects future commits. */\n  showTestMergeCommitters: boolean;\n\n  /** If test merge commits should be kept when auto updating. May cause merge conflicts which will block the update. */\n  autoUpdatesKeepTestMerges: boolean;\n\n  /** If synchronization should occur when auto updating. Requries Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser and Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  autoUpdatesSynchronize: boolean;\n\n  /** If test merging should create a comment. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  postTestMergeComment: boolean;\n\n  /** Do the equivalent of a `git submodule update --init` alongside any resets to origin, checkouts, or test merge additions. Note that this action is recursive ONLY during cloning. */\n  updateSubmodules: boolean;\n}\n\n/**\n * Rights for the git repository.\n * @format int64\n */\nexport enum RepositoryRights {\n  None = 0,\n  CancelPendingChanges = 1,\n  SetOrigin = 2,\n  SetSha = 4,\n  MergePullRequest = 8,\n  UpdateBranch = 16,\n  ChangeCommitter = 32,\n  ChangeTestMergeCommits = 64,\n  ChangeCredentials = 128,\n  SetReference = 256,\n  Read = 512,\n  ChangeAutoUpdateSettings = 1024,\n  Delete = 2048,\n  CancelClone = 4096,\n  ChangeSubmoduleUpdate = 8192,\n}\n\n/**\n * Represents a request to change the repository.\n */\nexport interface RepositoryUpdateRequest {\n  /** The commit HEAD should point to. */\n  checkoutSha?: string | null;\n\n  /** Do the equivalent of a `git pull`. Will attempt to merge unless Tgstation.Server.Api.Models.Internal.RepositoryApiBase.Reference is also specified in which case a hard reset will be performed after checking out. */\n  updateFromOrigin?: boolean | null;\n\n  /** Tgstation.Server.Api.Models.TestMergeParameters for new Tgstation.Server.Api.Models.TestMerges. Note that merges that conflict will not be performed. */\n  newTestMerges?: TestMergeParameters[] | null;\n\n  /** The branch or tag HEAD points to. */\n  reference?: string | null;\n\n  /** The name of the committer. */\n  committerName?: string | null;\n\n  /**\n   * The e-mail of the committer.\n   * @format email\n   */\n  committerEmail?: string | null;\n\n  /** The username to access the git repository with. */\n  accessUser?: string | null;\n\n  /** The token/password to access the git repository with. */\n  accessToken?: string | null;\n\n  /** If commits created from testmerges are pushed to the remote. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser and Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  pushTestMergeCommits?: boolean | null;\n\n  /** If GitHub deployments should be created. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser, Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken, and Tgstation.Server.Api.Models.Internal.RepositorySettings.PushTestMergeCommits to be set to function. */\n  createGitHubDeployments?: boolean | null;\n\n  /** If test merge commits are signed with the username of the person who merged it. Note this only affects future commits. */\n  showTestMergeCommitters?: boolean | null;\n\n  /** If test merge commits should be kept when auto updating. May cause merge conflicts which will block the update. */\n  autoUpdatesKeepTestMerges?: boolean | null;\n\n  /** If synchronization should occur when auto updating. Requries Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessUser and Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  autoUpdatesSynchronize?: boolean | null;\n\n  /** If test merging should create a comment. Requires Tgstation.Server.Api.Models.Internal.RepositorySettings.AccessToken to be set to function. */\n  postTestMergeComment?: boolean | null;\n\n  /** Do the equivalent of a `git submodule update --init` alongside any resets to origin, checkouts, or test merge additions. Note that this action is recursive ONLY during cloning. */\n  updateSubmodules?: boolean | null;\n}\n\nexport interface RevisionInformation {\n  /** The Tgstation.Server.Api.Models.TestMerge that was created with this Tgstation.Server.Api.Models.RevisionInformation. */\n  primaryTestMerge?: TestMerge | null;\n\n  /** The Tgstation.Server.Api.Models.TestMerges active in the Tgstation.Server.Api.Models.RevisionInformation. */\n  activeTestMerges: TestMerge[];\n\n  /** The Tgstation.Server.Api.Models.Internal.CompileJobs made from the Tgstation.Server.Api.Models.RevisionInformation. */\n  compileJobs: EntityId[];\n\n  /** The revision SHA. */\n  commitSha: string;\n\n  /**\n   * The timestamp of the revision.\n   * @format date-time\n   */\n  timestamp: string;\n\n  /** The SHA of the most recent remote commit. */\n  originCommitSha: string;\n}\n\n/**\n * The type of rights a model uses.\n * @format int64\n */\nexport enum RightsType {\n  Administration = 0,\n  InstanceManager = 1,\n  Repository = 2,\n  Engine = 3,\n  DreamMaker = 4,\n  DreamDaemon = 5,\n  ChatBots = 6,\n  Configuration = 7,\n  InstancePermissionSet = 8,\n}\n\n/**\n * Represents basic server information.\n */\nexport interface ServerInformationResponse {\n  /** The version of the host. */\n  version: string;\n\n  /** The N:Tgstation.Server.Api version of the host. */\n  apiVersion: string;\n\n  /** The DMAPI interop version the server uses. */\n  dmApiVersion: string;\n\n  /** If the server is running on a windows operating system. */\n  windowsHost: boolean;\n\n  /** If there is a server update in progress. */\n  updateInProgress: boolean;\n\n  /** A System.Collections.Generic.ICollection`1 of connected Tgstation.Server.Api.Models.Response.SwarmServerResponses. */\n  swarmServers?: SwarmServerResponse[] | null;\n\n  /** Map of Tgstation.Server.Api.Models.OAuthProvider to the Tgstation.Server.Api.Models.OAuthProviderInfo for them. */\n  oAuthProviderInfos: {\n    GitHub: OAuthProviderInfo;\n    Discord: OAuthProviderInfo;\n    TGForums: OAuthProviderInfo;\n    Keycloak: OAuthProviderInfo;\n    InvisionCommunity: OAuthProviderInfo;\n  };\n\n  /**\n   * Minimum length of database user passwords.\n   * @format int32\n   */\n  minimumPasswordLength: number;\n\n  /**\n   * The maximum number of Tgstation.Server.Api.Models.Instances allowed.\n   * @format int32\n   */\n  instanceLimit: number;\n\n  /**\n   * The maximum number of users allowed.\n   * @format int32\n   */\n  userLimit: number;\n\n  /**\n   * The maximum number of user groups allowed.\n   * @format int32\n   */\n  userGroupLimit: number;\n\n  /** Limits the locations instances may be created or attached from. */\n  validInstancePaths?: string[] | null;\n}\n\n/**\n * Represents a request to update TGS.\n */\nexport interface ServerUpdateRequest {\n  /** Changes the version of tgstation-server to the given version from the upstream repository. */\n  newVersion: string;\n\n  /** If the user will provide the server update package .zip file via file transfer as opposed to TGS retrieving it from GitHub. */\n  uploadZip?: boolean | null;\n}\n\n/**\n * A response to a Tgstation.Server.Api.Models.Request.ServerUpdateRequest.\n */\nexport interface ServerUpdateResponse {\n  /** The version of tgstation-server pending update. */\n  newVersion: string;\n\n  /** The ticket to use to access the Tgstation.Server.Api.Routes.Transfer controller. */\n  fileTicket: string;\n}\n\n/**\n * Base class for user names.\n */\nexport interface ShallowUserResponse {\n  name: string;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\nexport interface SwarmServerResponse {\n  /** If the Tgstation.Server.Api.Models.Response.SwarmServerResponse is the controller. */\n  controller: boolean;\n\n  /**\n   * The public address of the server.\n   * @format uri\n   */\n  address: string;\n\n  /**\n   * The address the swarm server can be publically accessed.\n   * @format uri\n   */\n  publicAddress: string;\n\n  /** The server's identifier. */\n  identifier: string;\n}\n\nexport interface TestMerge {\n  /** The Tgstation.Server.Api.Models.NamedEntity of the user who created the Tgstation.Server.Api.Models.TestMerge. */\n  mergedBy: ShallowUserResponse;\n\n  /**\n   * The ID of the Tgstation.Server.Api.Models.Internal.TestMergeApiBase.\n   * @format int64\n   */\n  id: number;\n\n  /**\n   * When the Tgstation.Server.Api.Models.Internal.TestMergeApiBase was created.\n   * @format date-time\n   */\n  mergedAt: string;\n\n  /** The title of the test merge source. */\n  titleAtMerge: string;\n\n  /** The body of the test merge source. */\n  bodyAtMerge: string;\n\n  /** The URL of the test merge source. */\n  url: string;\n\n  /** The author of the test merge source. */\n  author: string;\n\n  /**\n   * The number of the test merge source.\n   * @format int32\n   */\n  number: number;\n\n  /** The sha of the test merge revision to merge. If not specified, the latest commit from the source will be used. */\n  targetCommitSha: string;\n\n  /** Optional comment about the test. */\n  comment?: string | null;\n}\n\n/**\n * Parameters for creating a Tgstation.Server.Api.Models.TestMerge.\n */\nexport interface TestMergeParameters {\n  /**\n   * The number of the test merge source.\n   * @format int32\n   */\n  number: number;\n\n  /** The sha of the test merge revision to merge. If not specified, the latest commit from the source will be used. */\n  targetCommitSha?: string | null;\n\n  /** Optional comment about the test. */\n  comment?: string | null;\n}\n\n/**\n * Represents a JWT returned by the API.\n */\nexport interface TokenResponse {\n  /** The value of the JWT. */\n  bearer: string;\n}\n\n/**\n * For creating a user.\n */\nexport interface UserCreateRequest {\n  /** Cleartext password of the user. */\n  password?: string | null;\n\n  /** List of Tgstation.Server.Api.Models.OAuthConnections associated with the user. */\n  oAuthConnections?: OAuthConnection[] | null;\n\n  /** The Tgstation.Server.Api.Models.PermissionSet directly associated with the user. */\n  permissionSet?: PermissionSet | null;\n\n  /** The Tgstation.Server.Api.Models.Internal.UserGroup asociated with the user, if any. */\n  group?: UserGroup | null;\n\n  /** If the Tgstation.Server.Api.Models.Internal.UserModelBase is enabled since users cannot be deleted. System users cannot be disabled. */\n  enabled?: boolean | null;\n\n  /** The SID/UID of the Tgstation.Server.Api.Models.Internal.UserModelBase on Windows/POSIX respectively. */\n  systemIdentifier?: string | null;\n  name?: string | null;\n}\n\n/**\n * Represents a group of users.\n */\nexport interface UserGroup {\n  /** @format int64 */\n  id: number;\n\n  /** The Tgstation.Server.Api.Models.PermissionSet of the Tgstation.Server.Api.Models.Internal.UserGroup. */\n  permissionSet: PermissionSet;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name: string;\n}\n\n/**\n * Request to create a user group.\n */\nexport interface UserGroupCreateRequest {\n  /** @format int64 */\n  id: number;\n\n  /** The Tgstation.Server.Api.Models.PermissionSet of the Tgstation.Server.Api.Models.Internal.UserGroup. */\n  permissionSet?: PermissionSet | null;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name: string;\n}\n\nexport interface UserGroupResponse {\n  /** The Tgstation.Server.Api.Models.UserNames the Tgstation.Server.Api.Models.Response.UserGroupResponse has. */\n  users: ShallowUserResponse[];\n\n  /** @format int64 */\n  id: number;\n\n  /** The Tgstation.Server.Api.Models.PermissionSet of the Tgstation.Server.Api.Models.Internal.UserGroup. */\n  permissionSet: PermissionSet;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name: string;\n}\n\n/**\n * Request to update a user group.\n */\nexport interface UserGroupUpdateRequest {\n  /** @format int64 */\n  id: number;\n\n  /** The Tgstation.Server.Api.Models.PermissionSet of the Tgstation.Server.Api.Models.Internal.UserGroup. */\n  permissionSet?: PermissionSet | null;\n\n  /** The name of the entity represented by the Tgstation.Server.Api.Models.NamedEntity. */\n  name?: string | null;\n}\n\nexport interface UserResponse {\n  /** The Tgstation.Server.Api.Models.Response.UserResponse who created this Tgstation.Server.Api.Models.Response.UserResponse. */\n  createdBy: ShallowUserResponse;\n\n  /** List of Tgstation.Server.Api.Models.OAuthConnections associated with the user. */\n  oAuthConnections: OAuthConnection[];\n\n  /** The Tgstation.Server.Api.Models.PermissionSet directly associated with the user. */\n  permissionSet?: PermissionSet | null;\n\n  /** The Tgstation.Server.Api.Models.Internal.UserGroup asociated with the user, if any. */\n  group?: UserGroup | null;\n\n  /** If the Tgstation.Server.Api.Models.Internal.UserModelBase is enabled since users cannot be deleted. System users cannot be disabled. */\n  enabled: boolean;\n\n  /**\n   * When the Tgstation.Server.Api.Models.Internal.UserModelBase was created.\n   * @format date-time\n   */\n  createdAt: string;\n\n  /** The SID/UID of the Tgstation.Server.Api.Models.Internal.UserModelBase on Windows/POSIX respectively. */\n  systemIdentifier?: string | null;\n  name: string;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * For editing a given user.\n */\nexport interface UserUpdateRequest {\n  /** Cleartext password of the user. */\n  password?: string | null;\n\n  /** List of Tgstation.Server.Api.Models.OAuthConnections associated with the user. */\n  oAuthConnections?: OAuthConnection[] | null;\n\n  /** The Tgstation.Server.Api.Models.PermissionSet directly associated with the user. */\n  permissionSet?: PermissionSet | null;\n\n  /** The Tgstation.Server.Api.Models.Internal.UserGroup asociated with the user, if any. */\n  group?: UserGroup | null;\n\n  /** If the Tgstation.Server.Api.Models.Internal.UserModelBase is enabled since users cannot be deleted. System users cannot be disabled. */\n  enabled?: boolean | null;\n\n  /** The SID/UID of the Tgstation.Server.Api.Models.Internal.UserModelBase on Windows/POSIX respectively. */\n  systemIdentifier?: string | null;\n  name?: string | null;\n\n  /**\n   * The ID of the entity.\n   * @format int64\n   */\n  id: number;\n}\n\n/**\n * The current status of the watchdog.\n * @format int32\n */\nexport enum WatchdogStatus {\n  Offline = 0,\n  Restoring = 1,\n  Online = 2,\n  DelayedRestart = 3,\n}\n\n/**\n * Represents a request to update TGS.\n */\nexport type AdministrationControllerUpdatePayload = ServerUpdateRequest;\n\nexport interface AdministrationControllerListLogsParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * Represents a request to update a chat bot.\n */\nexport type ChatControllerCreatePayload = ChatBotCreateRequest;\n\n/**\n * Represents a request to update a chat bot.\n */\nexport type ChatControllerUpdatePayload = ChatBotUpdateRequest;\n\nexport interface ChatControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * Represents a request to update a configuration file.\n */\nexport type ConfigurationControllerUpdatePayload = ConfigurationFileRequest;\n\n/**\n * Represents a request to update a configuration file.\n */\nexport type ConfigurationControllerCreateDirectoryPayload = ConfigurationFileRequest;\n\n/**\n * Represents a request to update a configuration file.\n */\nexport type ConfigurationControllerDeleteDirectoryPayload = ConfigurationFileRequest;\n\nexport interface ConfigurationControllerDirectoryParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n\n  /** The path of the directory to get. */\n  directoryPath: string;\n}\n\nexport interface ConfigurationControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * A request to update Tgstation.Server.Api.Models.Internal.DreamDaemonSettings.\n */\nexport type DreamDaemonControllerUpdatePayload = DreamDaemonRequest;\n\n/**\n * A request to the DreamMaker controller.\n */\nexport type DreamMakerControllerUpdatePayload = DreamMakerRequest;\n\nexport interface DreamMakerControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * A request to switch to a given Tgstation.Server.Api.Models.Request.EngineVersionRequest.EngineVersion.\n */\nexport type EngineControllerUpdatePayload = EngineVersionRequest;\n\n/**\n * A request to delete a specific Tgstation.Server.Api.Models.Request.EngineVersionDeleteRequest.EngineVersion.\n */\nexport type EngineControllerDeletePayload = EngineVersionDeleteRequest;\n\nexport interface EngineControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * A request to create an Tgstation.Server.Api.Models.Instance.\n */\nexport type InstanceControllerCreatePayload = InstanceCreateRequest;\n\n/**\n * A request to update an Tgstation.Server.Api.Models.Instance.\n */\nexport type InstanceControllerUpdatePayload = InstanceUpdateRequest;\n\nexport interface InstanceControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * A request to update an instance permission set.\n */\nexport type InstancePermissionSetControllerCreatePayload = InstancePermissionSetRequest;\n\n/**\n * A request to update an instance permission set.\n */\nexport type InstancePermissionSetControllerUpdatePayload = InstancePermissionSetRequest;\n\nexport interface InstancePermissionSetControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\nexport interface JobControllerReadParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\nexport interface JobControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * Represents a request to clone the repository.\n */\nexport type RepositoryControllerCreatePayload = RepositoryCreateRequest;\n\n/**\n * Represents a request to change the repository.\n */\nexport type RepositoryControllerUpdatePayload = RepositoryUpdateRequest;\n\nexport interface TransferControllerDownloadParams {\n  /** The Tgstation.Server.Api.Models.Response.FileTicketResponse.FileTicket for the download. */\n  ticket: string;\n}\n\n/**\n * @format binary\n */\nexport type TransferControllerUploadPayload = File;\n\nexport interface TransferControllerUploadParams {\n  /** The Tgstation.Server.Api.Models.Response.FileTicketResponse.FileTicket for the upload. */\n  ticket: string;\n}\n\n/**\n * For creating a user.\n */\nexport type UserControllerCreatePayload = UserCreateRequest;\n\n/**\n * For editing a given user.\n */\nexport type UserControllerUpdatePayload = UserUpdateRequest;\n\nexport interface UserControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\n/**\n * Request to create a user group.\n */\nexport type UserGroupControllerCreatePayload = UserGroupCreateRequest;\n\n/**\n * Request to update a user group.\n */\nexport type UserGroupControllerUpdatePayload = UserGroupUpdateRequest;\n\nexport interface UserGroupControllerListParams {\n  /**\n   * The current page.\n   * @format int32\n   */\n  page: number;\n\n  /**\n   * The page size.\n   * @format int32\n   */\n  pageSize: number;\n}\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, ResponseType } from \"axios\";\nimport { ServerClientRequestConfig } from \"../ServerClientRequestConfig\";\n\nexport type QueryParamsType = Record<string | number, any>;\n\nexport interface FullRequestParams extends Omit<ServerClientRequestConfig, \"data\" | \"params\" | \"url\" | \"responseType\"> {\n  /** set parameter to `true` for call `securityWorker` for this request */\n  secure?: boolean;\n  /** request path */\n  path: string;\n  /** content type of request body */\n  type?: ContentType;\n  /** query params */\n  query?: QueryParamsType;\n  /** format of response (i.e. response.json() -> format: \"json\") */\n  format?: ResponseType;\n  /** request body */\n  body?: unknown;\n}\n\nexport type RequestParams = Omit<FullRequestParams, \"body\" | \"method\" | \"query\" | \"path\">;\n\nexport interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, \"data\" | \"cancelToken\"> {\n  securityWorker?: (\n    securityData: SecurityDataType | null,\n  ) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void;\n  secure?: boolean;\n  format?: ResponseType;\n}\n\nexport enum ContentType {\n  Json = \"application/json\",\n  FormData = \"multipart/form-data\",\n  UrlEncoded = \"application/x-www-form-urlencoded\",\n}\n\nexport class HttpClient<SecurityDataType = unknown> {\n  public instance: AxiosInstance;\n  private securityData: SecurityDataType | null = null;\n  private securityWorker?: ApiConfig<SecurityDataType>[\"securityWorker\"];\n  private secure?: boolean;\n  private format?: ResponseType;\n\n  constructor({ securityWorker, secure, format, ...axiosConfig }: ApiConfig<SecurityDataType> = {}) {\n    this.instance = axios.create({ ...axiosConfig, baseURL: axiosConfig.baseURL || \"\" });\n    this.secure = secure;\n    this.format = format;\n    this.securityWorker = securityWorker;\n  }\n\n  public setSecurityData = (data: SecurityDataType | null) => {\n    this.securityData = data;\n  };\n\n  private mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig {\n    return {\n      ...this.instance.defaults,\n      ...params1,\n      ...(params2 || {}),\n      headers: {\n        ...(this.instance.defaults.headers || {}),\n        ...(params1.headers || {}),\n        ...((params2 && params2.headers) || {}),\n      },\n    };\n  }\n\n  private createFormData(input: Record<string, unknown>): FormData {\n    return Object.keys(input || {}).reduce((formData, key) => {\n      const property = input[key];\n      formData.append(\n        key,\n        property instanceof Blob\n          ? property\n          : typeof property === \"object\" && property !== null\n          ? JSON.stringify(property)\n          : `${property}`,\n      );\n      return formData;\n    }, new FormData());\n  }\n\n  public request = async <T = any, _E = any>({\n    secure,\n    path,\n    type,\n    query,\n    format,\n    body,\n    ...params\n  }: FullRequestParams): Promise<AxiosResponse<T | _E>> => {\n    const secureParams =\n      ((typeof secure === \"boolean\" ? secure : this.secure) &&\n        this.securityWorker &&\n        (await this.securityWorker(this.securityData))) ||\n      {};\n    const requestParams = this.mergeRequestParams(params, secureParams);\n    const responseFormat = format || this.format || void 0;\n\n    if (type === ContentType.FormData && body && body !== null && typeof body === \"object\") {\n      requestParams.headers.common = { Accept: \"*/*\" };\n      requestParams.headers.post = {};\n      requestParams.headers.put = {};\n\n      body = this.createFormData(body as Record<string, unknown>);\n    }\n\n    return this.instance.request({\n      ...requestParams,\n      headers: {\n        ...(type && type !== ContentType.FormData ? { \"Content-Type\": type } : {}),\n        ...(requestParams.headers || {}),\n      },\n      params: query,\n      responseType: responseFormat,\n      data: body,\n      url: path,\n    });\n  };\n}\n\n/**\n * @title TGS API\n * @version 10.4.0\n * @license AGPL-3.0 (https://github.com/tgstation/tgstation-server/blob/dev/LICENSE)\n * @externalDocs https://tgstation.github.io/tgstation-server/api.html\n * @contact /tg/station 13 (https://github.com/tgstation)\n *\n * A production scale tool for BYOND server management\n */\nexport class Api<SecurityDataType extends unknown> {\n  http: HttpClient<SecurityDataType>;\n\n  constructor(http: HttpClient<SecurityDataType>) {\n    this.http = http;\n  }\n\n  api = {\n    /**\n     * No description\n     *\n     * @tags Administration\n     * @name AdministrationControllerRead\n     * @summary Get Tgstation.Server.Api.Models.Response.AdministrationResponse server information.\n     * @request GET:/api/Administration\n     * @secure\n     * @response `200` `AdministrationResponse` Retrieved Tgstation.Server.Api.Models.Response.AdministrationResponse data successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `424` `ErrorMessageResponse` The GitHub API rate limit was hit. See response header Retry-After.\n     * @response `429` `ErrorMessageResponse` A GitHub API error occurred. See error message for details.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    administrationControllerRead: (params: RequestParams = {}) =>\n      this.http.request<AdministrationResponse, ErrorMessageResponse>({\n        path: `/api/Administration`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Administration\n     * @name AdministrationControllerUpdate\n     * @summary Attempt to perform a server upgrade.\n     * @request POST:/api/Administration\n     * @secure\n     * @response `202` `ServerUpdateResponse` Update has been started successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The requested release version could not be found in the target GitHub repository.\n     * @response `422` `ErrorMessageResponse` Upgrade operations are unavailable due to the launch configuration of TGS.\n     * @response `424` `ErrorMessageResponse` A GitHub rate limit was encountered or the swarm integrity check failed.\n     * @response `429` `ErrorMessageResponse` A GitHub API error occurred.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    administrationControllerUpdate: (data: AdministrationControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<ServerUpdateResponse, ErrorMessageResponse>({\n        path: `/api/Administration`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Administration\n     * @name AdministrationControllerDelete\n     * @summary Attempts to restart the server.\n     * @request DELETE:/api/Administration\n     * @secure\n     * @response `204` `void` Restart begun successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `422` `ErrorMessageResponse` Restart operations are unavailable due to the launch configuration of TGS.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    administrationControllerDelete: (params: RequestParams = {}) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/Administration`,\n        method: \"DELETE\",\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Administration\n     * @name AdministrationControllerListLogs\n     * @summary List Tgstation.Server.Api.Models.Response.LogFileResponses present.\n     * @request GET:/api/Administration/Logs\n     * @secure\n     * @response `200` `PaginatedLogFileResponse` Listed logs successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` An IO error occurred while listing.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    administrationControllerListLogs: (query: AdministrationControllerListLogsParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedLogFileResponse, ErrorMessageResponse>({\n        path: `/api/Administration/Logs`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Administration\n     * @name AdministrationControllerGetLog\n     * @summary Download a Tgstation.Server.Api.Models.Response.LogFileResponse.\n     * @request GET:/api/Administration/Logs/{path}\n     * @secure\n     * @response `200` `LogFileResponse` Downloaded Tgstation.Server.Api.Models.Response.LogFileResponse successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` An IO error occurred while downloading.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    administrationControllerGetLog: (path: string, params: RequestParams = {}) =>\n      this.http.request<LogFileResponse, ErrorMessageResponse>({\n        path: `/api/Administration/Logs/${path}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags ApiRoot\n     * @name ApiRootControllerServerInfo\n     * @summary Main page of the Tgstation.Server.Host.Core.Application.\n     * @request GET:/api\n     * @response `200` `ServerInformationResponse` Tgstation.Server.Api.Models.Response.ServerInformationResponse retrieved successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    apiRootControllerServerInfo: (params: RequestParams = {}) =>\n      this.http.request<ServerInformationResponse, ErrorMessageResponse>({\n        path: `/api`,\n        method: \"GET\",\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags ApiRoot\n     * @name ApiRootControllerCreateToken\n     * @summary Attempt to authenticate a Tgstation.Server.Host.Models.User using Tgstation.Server.Host.Controllers.ApiController.ApiHeaders.\n     * @request POST:/api\n     * @secure\n     * @response `200` `TokenResponse` User logged in and Tgstation.Server.Api.Models.Response.TokenResponse generated successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `void` User authentication failed.\n     * @response `403` `void` User authenticated but is disabled by an administrator.\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `429` `ErrorMessageResponse` OAuth authentication failed due to rate limiting.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    apiRootControllerCreateToken: (params: RequestParams = {}) =>\n      this.http.request<TokenResponse, ErrorMessageResponse | void>({\n        path: `/api`,\n        method: \"POST\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Chat\n     * @name ChatControllerCreate\n     * @summary Create a new chat bot model.\n     * @request PUT:/api/Chat\n     * @secure\n     * @response `201` `ChatBotResponse` Created Tgstation.Server.Host.Models.ChatBot successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    chatControllerCreate: (data: ChatControllerCreatePayload, params: RequestParams = {}) =>\n      this.http.request<ChatBotResponse, ErrorMessageResponse>({\n        path: `/api/Chat`,\n        method: \"PUT\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Chat\n     * @name ChatControllerUpdate\n     * @summary Updates a chat bot model.\n     * @request POST:/api/Chat\n     * @secure\n     * @response `200` `ChatBotResponse` Update applied successfully.\n     * @response `204` `void` Update applied successfully. Tgstation.Server.Host.Models.ChatBot not returned based on user permissions.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The Tgstation.Server.Host.Models.ChatBot with the given ID does not exist in this instance.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    chatControllerUpdate: (data: ChatControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<ChatBotResponse, ErrorMessageResponse>({\n        path: `/api/Chat`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Chat\n     * @name ChatControllerDelete\n     * @summary Delete a Tgstation.Server.Host.Models.ChatBot.\n     * @request DELETE:/api/Chat/{id}\n     * @secure\n     * @response `204` `void` Chat bot deleted or does not exist.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    chatControllerDelete: (id: number, params: RequestParams = {}) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/Chat/${id}`,\n        method: \"DELETE\",\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Chat\n     * @name ChatControllerGetId\n     * @summary Get a specific Tgstation.Server.Host.Models.ChatBot.\n     * @request GET:/api/Chat/{id}\n     * @secure\n     * @response `200` `ChatBotResponse` Retrieved Tgstation.Server.Host.Models.ChatBot successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The Tgstation.Server.Host.Models.ChatBot with the given ID does not exist in this instance.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    chatControllerGetId: (id: number, params: RequestParams = {}) =>\n      this.http.request<ChatBotResponse, ErrorMessageResponse>({\n        path: `/api/Chat/${id}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Chat\n     * @name ChatControllerList\n     * @summary List Tgstation.Server.Host.Models.ChatBots.\n     * @request GET:/api/Chat/List\n     * @secure\n     * @response `200` `PaginatedChatBotResponse` Listed chat bots successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    chatControllerList: (query: ChatControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedChatBotResponse, ErrorMessageResponse>({\n        path: `/api/Chat/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Configuration\n     * @name ConfigurationControllerUpdate\n     * @summary Write to a configuration file.\n     * @request POST:/api/Config\n     * @secure\n     * @response `200` `ConfigurationFileResponse` File updated successfully.\n     * @response `202` `ConfigurationFileResponse` File upload ticket created successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    configurationControllerUpdate: (data: ConfigurationControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<ConfigurationFileResponse, ErrorMessageResponse>({\n        path: `/api/Config`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Configuration\n     * @name ConfigurationControllerCreateDirectory\n     * @summary Create a configuration directory.\n     * @request PUT:/api/Config\n     * @secure\n     * @response `200` `ConfigurationFileResponse` Directory already exists.\n     * @response `201` `ConfigurationFileResponse` Directory created successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` Conflict\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    configurationControllerCreateDirectory: (\n      data: ConfigurationControllerCreateDirectoryPayload,\n      params: RequestParams = {},\n    ) =>\n      this.http.request<ConfigurationFileResponse, ErrorMessageResponse>({\n        path: `/api/Config`,\n        method: \"PUT\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Configuration\n     * @name ConfigurationControllerDeleteDirectory\n     * @summary Deletes an empty directory.\n     * @request DELETE:/api/Config\n     * @secure\n     * @response `204` `void` Empty directory deleted successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` Conflict\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    configurationControllerDeleteDirectory: (\n      data: ConfigurationControllerDeleteDirectoryPayload,\n      params: RequestParams = {},\n    ) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/Config`,\n        method: \"DELETE\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Configuration\n     * @name ConfigurationControllerFile\n     * @summary Get the contents of a file at a filePath.\n     * @request GET:/api/Config/File/{filePath}\n     * @secure\n     * @response `200` `ConfigurationFileResponse` File read successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` Conflict\n     * @response `410` `ErrorMessageResponse` File does not currently exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    configurationControllerFile: (filePath: string, params: RequestParams = {}) =>\n      this.http.request<ConfigurationFileResponse, ErrorMessageResponse>({\n        path: `/api/Config/File/${filePath}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Configuration\n     * @name ConfigurationControllerDirectory\n     * @summary Get the contents of a directory at a directoryPath.\n     * @request GET:/api/Config/List/{directoryPath}\n     * @secure\n     * @response `200` `PaginatedConfigurationFileResponse` Directory listed successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` Conflict\n     * @response `410` `ErrorMessageResponse` Directory does not currently exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    configurationControllerDirectory: (\n      { directoryPath, ...query }: ConfigurationControllerDirectoryParams,\n      params: RequestParams = {},\n    ) =>\n      this.http.request<PaginatedConfigurationFileResponse, ErrorMessageResponse>({\n        path: `/api/Config/List/${directoryPath}`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Configuration\n     * @name ConfigurationControllerList\n     * @summary Get the contents of the root configuration directory.\n     * @request GET:/api/Config/List\n     * @secure\n     * @response `200` `PaginatedConfigurationFileResponse` OK\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    configurationControllerList: (query: ConfigurationControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedConfigurationFileResponse, ErrorMessageResponse>({\n        path: `/api/Config/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamDaemon\n     * @name DreamDaemonControllerCreate\n     * @summary Launches the watchdog.\n     * @request PUT:/api/DreamDaemon\n     * @secure\n     * @response `202` `JobResponse` Watchdog launch started successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamDaemonControllerCreate: (params: RequestParams = {}) =>\n      this.http.request<JobResponse, ErrorMessageResponse>({\n        path: `/api/DreamDaemon`,\n        method: \"PUT\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamDaemon\n     * @name DreamDaemonControllerRead\n     * @summary Get the watchdog status.\n     * @request GET:/api/DreamDaemon\n     * @secure\n     * @response `200` `DreamDaemonResponse` Read Tgstation.Server.Api.Models.Response.DreamDaemonResponse information successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamDaemonControllerRead: (params: RequestParams = {}) =>\n      this.http.request<DreamDaemonResponse, ErrorMessageResponse>({\n        path: `/api/DreamDaemon`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamDaemon\n     * @name DreamDaemonControllerDelete\n     * @summary Stops the Watchdog if it's running.\n     * @request DELETE:/api/DreamDaemon\n     * @secure\n     * @response `204` `void` Watchdog terminated.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamDaemonControllerDelete: (params: RequestParams = {}) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/DreamDaemon`,\n        method: \"DELETE\",\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamDaemon\n     * @name DreamDaemonControllerUpdate\n     * @summary Update watchdog settings to be applied at next server reboot.\n     * @request POST:/api/DreamDaemon\n     * @secure\n     * @response `200` `DreamDaemonResponse` Settings applied successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamDaemonControllerUpdate: (data: DreamDaemonControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<DreamDaemonResponse, ErrorMessageResponse>({\n        path: `/api/DreamDaemon`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamDaemon\n     * @name DreamDaemonControllerRestart\n     * @summary Creates a Tgstation.Server.Api.Models.Response.JobResponse to restart the Watchdog. It will not start if it wasn't already running.\n     * @request PATCH:/api/DreamDaemon\n     * @secure\n     * @response `202` `JobResponse` Restart Tgstation.Server.Api.Models.Response.JobResponse started successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamDaemonControllerRestart: (params: RequestParams = {}) =>\n      this.http.request<JobResponse, ErrorMessageResponse>({\n        path: `/api/DreamDaemon`,\n        method: \"PATCH\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamDaemon\n     * @name DreamDaemonControllerCreateDump\n     * @summary Creates a Tgstation.Server.Api.Models.Response.JobResponse to generate a DreamDaemon process dump.\n     * @request PATCH:/api/DreamDaemon/Diagnostics\n     * @secure\n     * @response `202` `JobResponse` Dump Tgstation.Server.Api.Models.Response.JobResponse started successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamDaemonControllerCreateDump: (params: RequestParams = {}) =>\n      this.http.request<JobResponse, ErrorMessageResponse>({\n        path: `/api/DreamDaemon/Diagnostics`,\n        method: \"PATCH\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamMaker\n     * @name DreamMakerControllerRead\n     * @summary Read current deployment settings.\n     * @request GET:/api/DreamMaker\n     * @secure\n     * @response `200` `DreamMakerResponse` Read deployment settings successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamMakerControllerRead: (params: RequestParams = {}) =>\n      this.http.request<DreamMakerResponse, ErrorMessageResponse>({\n        path: `/api/DreamMaker`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamMaker\n     * @name DreamMakerControllerCreate\n     * @summary Begin deploying repository code.\n     * @request PUT:/api/DreamMaker\n     * @secure\n     * @response `202` `JobResponse` Created deployment Tgstation.Server.Api.Models.Response.JobResponse successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamMakerControllerCreate: (params: RequestParams = {}) =>\n      this.http.request<JobResponse, ErrorMessageResponse>({\n        path: `/api/DreamMaker`,\n        method: \"PUT\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamMaker\n     * @name DreamMakerControllerUpdate\n     * @summary Update deployment settings.\n     * @request POST:/api/DreamMaker\n     * @secure\n     * @response `200` `DreamMakerResponse` Changes applied successfully. The updated Tgstation.Server.Host.Models.DreamMakerSettings will be returned.\n     * @response `204` `void` Changes applied successfully. The updated Tgstation.Server.Host.Models.DreamMakerSettings will be not be returned due to permissions.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamMakerControllerUpdate: (data: DreamMakerControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<DreamMakerResponse, ErrorMessageResponse>({\n        path: `/api/DreamMaker`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamMaker\n     * @name DreamMakerControllerGetId\n     * @summary Get a Tgstation.Server.Host.Models.CompileJob specified by a given id.\n     * @request GET:/api/DreamMaker/{id}\n     * @secure\n     * @response `200` `CompileJobResponse` Tgstation.Server.Host.Models.CompileJob retrieved successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `404` `ErrorMessageResponse` Specified Tgstation.Server.Host.Models.CompileJob ID does not exist in this instance.\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamMakerControllerGetId: (id: number, params: RequestParams = {}) =>\n      this.http.request<CompileJobResponse, ErrorMessageResponse>({\n        path: `/api/DreamMaker/${id}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags DreamMaker\n     * @name DreamMakerControllerList\n     * @summary List all Tgstation.Server.Host.Models.CompileJobTgstation.Server.Api.Models.EntityIds for the instance.\n     * @request GET:/api/DreamMaker/List\n     * @secure\n     * @response `200` `PaginatedCompileJobResponse` Retrieved Tgstation.Server.Api.Models.EntityIds successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    dreamMakerControllerList: (query: DreamMakerControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedCompileJobResponse, ErrorMessageResponse>({\n        path: `/api/DreamMaker/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Engine\n     * @name EngineControllerRead\n     * @summary Gets the active Tgstation.Server.Api.Models.EngineVersion.\n     * @request GET:/api/Engine\n     * @secure\n     * @response `200` `EngineResponse` Retrieved version information successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` No engine versions installed.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    engineControllerRead: (params: RequestParams = {}) =>\n      this.http.request<EngineResponse, ErrorMessageResponse>({\n        path: `/api/Engine`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Engine\n     * @name EngineControllerUpdate\n     * @summary Changes the active engine version to the one specified in a given model.\n     * @request POST:/api/Engine\n     * @secure\n     * @response `200` `EngineInstallResponse` Switched active engine version successfully.\n     * @response `202` `EngineInstallResponse` Created Tgstation.Server.Host.Models.Job to install and switch active engine version successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    engineControllerUpdate: (data: EngineControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<EngineInstallResponse, ErrorMessageResponse>({\n        path: `/api/Engine`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Engine\n     * @name EngineControllerDelete\n     * @summary Attempts to delete the BYOND version specified in a given model from the instance.\n     * @request DELETE:/api/Engine\n     * @secure\n     * @response `202` `JobResponse` Created Tgstation.Server.Host.Models.Job to delete target version successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` Attempted to delete the active BYOND System.Version.\n     * @response `410` `ErrorMessageResponse` The Tgstation.Server.Api.Models.EngineVersion specified was not installed.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    engineControllerDelete: (data: EngineControllerDeletePayload, params: RequestParams = {}) =>\n      this.http.request<JobResponse, ErrorMessageResponse>({\n        path: `/api/Engine`,\n        method: \"DELETE\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Engine\n     * @name EngineControllerList\n     * @summary Lists installed Tgstation.Server.Api.Models.EngineVersions.\n     * @request GET:/api/Engine/List\n     * @secure\n     * @response `200` `PaginatedEngineResponse` Retrieved version information successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    engineControllerList: (query: EngineControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedEngineResponse, ErrorMessageResponse>({\n        path: `/api/Engine/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Instance\n     * @name InstanceControllerCreate\n     * @summary Create or attach an Tgstation.Server.Api.Models.Instance.\n     * @request PUT:/api/Instance\n     * @secure\n     * @response `200` `InstanceResponse` Instance attached successfully.\n     * @response `201` `InstanceResponse` Instance created successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instanceControllerCreate: (data: InstanceControllerCreatePayload, params: RequestParams = {}) =>\n      this.http.request<InstanceResponse, ErrorMessageResponse>({\n        path: `/api/Instance`,\n        method: \"PUT\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Instance\n     * @name InstanceControllerUpdate\n     * @summary Modify an Tgstation.Server.Api.Models.Instance's settings.\n     * @request POST:/api/Instance\n     * @secure\n     * @response `200` `InstanceResponse` Instance updated successfully.\n     * @response `202` `InstanceResponse` Instance updated successfully and relocation job created.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instanceControllerUpdate: (data: InstanceControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<InstanceResponse, ErrorMessageResponse>({\n        path: `/api/Instance`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Instance\n     * @name InstanceControllerDelete\n     * @summary Detach an Tgstation.Server.Api.Models.Instance with the given id.\n     * @request DELETE:/api/Instance/{id}\n     * @secure\n     * @response `204` `void` Instance detatched successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instanceControllerDelete: (id: number, params: RequestParams = {}) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/Instance/${id}`,\n        method: \"DELETE\",\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Instance\n     * @name InstanceControllerGetId\n     * @summary Get a specific Tgstation.Server.Api.Models.Instance.\n     * @request GET:/api/Instance/{id}\n     * @secure\n     * @response `200` `InstanceResponse` Retrieved Tgstation.Server.Api.Models.Instance successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instanceControllerGetId: (id: number, params: RequestParams = {}) =>\n      this.http.request<InstanceResponse, ErrorMessageResponse>({\n        path: `/api/Instance/${id}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Instance\n     * @name InstanceControllerGrantPermissions\n     * @summary Gives the current user full permissions on a given instance id.\n     * @request PATCH:/api/Instance/{id}\n     * @secure\n     * @response `204` `void` Granted permissions successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` Gone\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instanceControllerGrantPermissions: (id: number, params: RequestParams = {}) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/Instance/${id}`,\n        method: \"PATCH\",\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Instance\n     * @name InstanceControllerList\n     * @summary List Tgstation.Server.Api.Models.Instances.\n     * @request GET:/api/Instance/List\n     * @secure\n     * @response `200` `PaginatedInstanceResponse` Retrieved Tgstation.Server.Api.Models.Instances successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instanceControllerList: (query: InstanceControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedInstanceResponse, ErrorMessageResponse>({\n        path: `/api/Instance/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags InstancePermissionSet\n     * @name InstancePermissionSetControllerCreate\n     * @summary Create an Tgstation.Server.Host.Models.InstancePermissionSet.\n     * @request PUT:/api/InstancePermissionSet\n     * @secure\n     * @response `201` `InstancePermissionSetResponse` Tgstation.Server.Host.Models.InstancePermissionSet created successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The Tgstation.Server.Api.Models.PermissionSet does not exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instancePermissionSetControllerCreate: (\n      data: InstancePermissionSetControllerCreatePayload,\n      params: RequestParams = {},\n    ) =>\n      this.http.request<InstancePermissionSetResponse, ErrorMessageResponse>({\n        path: `/api/InstancePermissionSet`,\n        method: \"PUT\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags InstancePermissionSet\n     * @name InstancePermissionSetControllerUpdate\n     * @summary Update the permissions for an Tgstation.Server.Host.Models.InstancePermissionSet.\n     * @request POST:/api/InstancePermissionSet\n     * @secure\n     * @response `200` `InstancePermissionSetResponse` Tgstation.Server.Host.Models.InstancePermissionSet updated successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The requested Tgstation.Server.Host.Models.InstancePermissionSet does not currently exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instancePermissionSetControllerUpdate: (\n      data: InstancePermissionSetControllerUpdatePayload,\n      params: RequestParams = {},\n    ) =>\n      this.http.request<InstancePermissionSetResponse, ErrorMessageResponse>({\n        path: `/api/InstancePermissionSet`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags InstancePermissionSet\n     * @name InstancePermissionSetControllerRead\n     * @summary Read the active Tgstation.Server.Host.Models.InstancePermissionSet.\n     * @request GET:/api/InstancePermissionSet\n     * @secure\n     * @response `200` `InstancePermissionSetResponse` Tgstation.Server.Host.Models.InstancePermissionSet retrieved successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instancePermissionSetControllerRead: (params: RequestParams = {}) =>\n      this.http.request<InstancePermissionSetResponse, ErrorMessageResponse>({\n        path: `/api/InstancePermissionSet`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags InstancePermissionSet\n     * @name InstancePermissionSetControllerList\n     * @summary Lists Tgstation.Server.Host.Models.InstancePermissionSets for the instance.\n     * @request GET:/api/InstancePermissionSet/List\n     * @secure\n     * @response `200` `PaginatedInstancePermissionSetResponse` Retrieved Tgstation.Server.Host.Models.InstancePermissionSets successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instancePermissionSetControllerList: (\n      query: InstancePermissionSetControllerListParams,\n      params: RequestParams = {},\n    ) =>\n      this.http.request<PaginatedInstancePermissionSetResponse, ErrorMessageResponse>({\n        path: `/api/InstancePermissionSet/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags InstancePermissionSet\n     * @name InstancePermissionSetControllerGetId\n     * @summary Gets a specific Tgstation.Server.Api.Models.Internal.InstancePermissionSet.\n     * @request GET:/api/InstancePermissionSet/{id}\n     * @secure\n     * @response `200` `InstancePermissionSetResponse` Retrieve Tgstation.Server.Api.Models.Internal.InstancePermissionSet successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The requested Tgstation.Server.Api.Models.Internal.InstancePermissionSet does not currently exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instancePermissionSetControllerGetId: (id: number, params: RequestParams = {}) =>\n      this.http.request<InstancePermissionSetResponse, ErrorMessageResponse>({\n        path: `/api/InstancePermissionSet/${id}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags InstancePermissionSet\n     * @name InstancePermissionSetControllerDelete\n     * @summary Delete an Tgstation.Server.Host.Models.InstancePermissionSet.\n     * @request DELETE:/api/InstancePermissionSet/{id}\n     * @secure\n     * @response `204` `void` Target Tgstation.Server.Host.Models.InstancePermissionSet deleted.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` Target Tgstation.Server.Host.Models.InstancePermissionSet or no longer exists.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    instancePermissionSetControllerDelete: (id: number, params: RequestParams = {}) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/InstancePermissionSet/${id}`,\n        method: \"DELETE\",\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Job\n     * @name JobControllerRead\n     * @summary Get active Tgstation.Server.Api.Models.Response.JobResponses for the instance.\n     * @request GET:/api/Job\n     * @secure\n     * @response `200` `PaginatedJobResponse` Retrieved active Tgstation.Server.Host.Models.Jobs successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    jobControllerRead: (query: JobControllerReadParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedJobResponse, ErrorMessageResponse>({\n        path: `/api/Job`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Job\n     * @name JobControllerList\n     * @summary List all Tgstation.Server.Api.Models.Response.JobResponse for the instance in reverse creation order.\n     * @request GET:/api/Job/List\n     * @secure\n     * @response `200` `PaginatedJobResponse` Retrieved Tgstation.Server.Host.Models.JobTgstation.Server.Api.Models.EntityIds successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    jobControllerList: (query: JobControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedJobResponse, ErrorMessageResponse>({\n        path: `/api/Job/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Job\n     * @name JobControllerDelete\n     * @summary Cancel a running Tgstation.Server.Api.Models.Response.JobResponse.\n     * @request DELETE:/api/Job/{id}\n     * @secure\n     * @response `202` `JobResponse` Tgstation.Server.Host.Models.Job cancellation requested successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `404` `ErrorMessageResponse` Tgstation.Server.Host.Models.Job does not exist in this instance.\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `void` Tgstation.Server.Host.Models.Job could not be found in the job manager. Has it already completed?.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    jobControllerDelete: (id: number, params: RequestParams = {}) =>\n      this.http.request<JobResponse, ErrorMessageResponse | void>({\n        path: `/api/Job/${id}`,\n        method: \"DELETE\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Job\n     * @name JobControllerGetId\n     * @summary Get a specific Tgstation.Server.Api.Models.Response.JobResponse.\n     * @request GET:/api/Job/{id}\n     * @secure\n     * @response `200` `JobResponse` Retrieved Tgstation.Server.Host.Models.Job successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `404` `ErrorMessageResponse` Tgstation.Server.Host.Models.Job does not exist in this instance.\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    jobControllerGetId: (id: number, params: RequestParams = {}) =>\n      this.http.request<JobResponse, ErrorMessageResponse>({\n        path: `/api/Job/${id}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Repository\n     * @name RepositoryControllerCreate\n     * @summary Begin cloning the repository if it doesn't exist.\n     * @request PUT:/api/Repository\n     * @secure\n     * @response `201` `RepositoryResponse` The repository was created successfully and the Tgstation.Server.Api.Models.Response.JobResponse to clone it has begun.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    repositoryControllerCreate: (data: RepositoryControllerCreatePayload, params: RequestParams = {}) =>\n      this.http.request<RepositoryResponse, ErrorMessageResponse>({\n        path: `/api/Repository`,\n        method: \"PUT\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Repository\n     * @name RepositoryControllerDelete\n     * @summary Delete the repository.\n     * @request DELETE:/api/Repository\n     * @secure\n     * @response `202` `RepositoryResponse` Job to delete the repository created successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    repositoryControllerDelete: (params: RequestParams = {}) =>\n      this.http.request<RepositoryResponse, ErrorMessageResponse>({\n        path: `/api/Repository`,\n        method: \"DELETE\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Repository\n     * @name RepositoryControllerRead\n     * @summary Get the repository's status.\n     * @request GET:/api/Repository\n     * @secure\n     * @response `200` `RepositoryResponse` Retrieved the repository settings successfully.\n     * @response `201` `RepositoryResponse` Retrieved the repository settings successfully, though they did not previously exist.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `RepositoryResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    repositoryControllerRead: (params: RequestParams = {}) =>\n      this.http.request<RepositoryResponse, ErrorMessageResponse | RepositoryResponse>({\n        path: `/api/Repository`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Repository\n     * @name RepositoryControllerUpdate\n     * @summary Perform updates to the repository.\n     * @request POST:/api/Repository\n     * @secure\n     * @response `200` `RepositoryResponse` Updated the repository settings successfully.\n     * @response `202` `RepositoryResponse` Updated the repository settings successfully and a Tgstation.Server.Api.Models.Response.JobResponse was created to make the requested git changes.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The database entity for the requested instance could not be retrieved. The instance was likely detached.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    repositoryControllerUpdate: (data: RepositoryControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<RepositoryResponse, ErrorMessageResponse>({\n        path: `/api/Repository`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Transfer\n     * @name TransferControllerDownload\n     * @summary Downloads a file with a given ticket.\n     * @request GET:/api/Transfer\n     * @secure\n     * @response `200` `File` Started streaming download successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The ticket was no longer or was never valid.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    transferControllerDownload: (query: TransferControllerDownloadParams, params: RequestParams = {}) =>\n      this.http.request<File, ErrorMessageResponse>({\n        path: `/api/Transfer`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags Transfer\n     * @name TransferControllerUpload\n     * @summary Uploads a file with a given ticket.\n     * @request PUT:/api/Transfer\n     * @secure\n     * @response `204` `void` Uploaded file successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `void` An error occurred during the upload.\n     * @response `410` `ErrorMessageResponse` The ticket was no longer or was never valid.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    transferControllerUpload: (\n      query: TransferControllerUploadParams,\n      data: TransferControllerUploadPayload,\n      params: RequestParams = {},\n    ) =>\n      this.http.request<void, ErrorMessageResponse | void>({\n        path: `/api/Transfer`,\n        method: \"PUT\",\n        query: query,\n        body: data,\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags User\n     * @name UserControllerCreate\n     * @summary Create a new Tgstation.Server.Host.Models.User.\n     * @request PUT:/api/User\n     * @secure\n     * @response `201` `UserResponse` Tgstation.Server.Host.Models.User created successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `void` The requested system identifier could not be found.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userControllerCreate: (data: UserControllerCreatePayload, params: RequestParams = {}) =>\n      this.http.request<UserResponse, ErrorMessageResponse | void>({\n        path: `/api/User`,\n        method: \"PUT\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags User\n     * @name UserControllerUpdate\n     * @summary Update a Tgstation.Server.Host.Models.User.\n     * @request POST:/api/User\n     * @secure\n     * @response `200` `UserResponse` Tgstation.Server.Host.Models.User updated successfully. Not returned due to lack of permissions.\n     * @response `204` `void` No Content\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `404` `ErrorMessageResponse` Requested Tgstation.Server.Api.Models.EntityId.Id does not exist.\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` Requested Tgstation.Server.Api.Models.Internal.UserApiBase.Group does not exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userControllerUpdate: (data: UserControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<UserResponse, ErrorMessageResponse>({\n        path: `/api/User`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags User\n     * @name UserControllerRead\n     * @summary Get information about the current Tgstation.Server.Host.Models.User.\n     * @request GET:/api/User\n     * @secure\n     * @response `200` `UserResponse` The Tgstation.Server.Host.Models.User was retrieved successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userControllerRead: (params: RequestParams = {}) =>\n      this.http.request<UserResponse, ErrorMessageResponse>({\n        path: `/api/User`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags User\n     * @name UserControllerList\n     * @summary List all Tgstation.Server.Host.Models.Users in the server.\n     * @request GET:/api/User/List\n     * @secure\n     * @response `200` `PaginatedUserResponse` Retrieved Tgstation.Server.Host.Models.Users successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userControllerList: (query: UserControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedUserResponse, ErrorMessageResponse>({\n        path: `/api/User/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags User\n     * @name UserControllerGetId\n     * @summary Get a specific Tgstation.Server.Host.Models.User.\n     * @request GET:/api/User/{id}\n     * @secure\n     * @response `200` `UserResponse` The Tgstation.Server.Host.Models.User was retrieved successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `404` `ErrorMessageResponse` The Tgstation.Server.Host.Models.User does not exist.\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userControllerGetId: (id: number, params: RequestParams = {}) =>\n      this.http.request<UserResponse, ErrorMessageResponse>({\n        path: `/api/User/${id}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags UserGroup\n     * @name UserGroupControllerCreate\n     * @summary Create a new Tgstation.Server.Host.Models.UserGroup.\n     * @request PUT:/api/UserGroup\n     * @secure\n     * @response `201` `UserGroupResponse` Tgstation.Server.Host.Models.UserGroup created successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userGroupControllerCreate: (data: UserGroupControllerCreatePayload, params: RequestParams = {}) =>\n      this.http.request<UserGroupResponse, ErrorMessageResponse>({\n        path: `/api/UserGroup`,\n        method: \"PUT\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags UserGroup\n     * @name UserGroupControllerUpdate\n     * @summary Update a Tgstation.Server.Host.Models.UserGroup.\n     * @request POST:/api/UserGroup\n     * @secure\n     * @response `200` `UserGroupResponse` Tgstation.Server.Host.Models.UserGroup updated successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `void` The requested Tgstation.Server.Host.Models.UserGroup does not currently exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userGroupControllerUpdate: (data: UserGroupControllerUpdatePayload, params: RequestParams = {}) =>\n      this.http.request<UserGroupResponse, ErrorMessageResponse | void>({\n        path: `/api/UserGroup`,\n        method: \"POST\",\n        body: data,\n        secure: true,\n        type: ContentType.Json,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags UserGroup\n     * @name UserGroupControllerGetId\n     * @summary Gets a specific Tgstation.Server.Host.Models.UserGroup.\n     * @request GET:/api/UserGroup/{id}\n     * @secure\n     * @response `200` `UserGroupResponse` Retrieve Tgstation.Server.Host.Models.UserGroup successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `410` `ErrorMessageResponse` The requested Tgstation.Server.Host.Models.UserGroup does not currently exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userGroupControllerGetId: (id: number, params: RequestParams = {}) =>\n      this.http.request<UserGroupResponse, ErrorMessageResponse>({\n        path: `/api/UserGroup/${id}`,\n        method: \"GET\",\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags UserGroup\n     * @name UserGroupControllerDelete\n     * @summary Delete a Tgstation.Server.Host.Models.UserGroup.\n     * @request DELETE:/api/UserGroup/{id}\n     * @secure\n     * @response `204` `void` Tgstation.Server.Host.Models.UserGroup was deleted.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse` The Tgstation.Server.Host.Models.UserGroup is not empty.\n     * @response `410` `ErrorMessageResponse` The Tgstation.Server.Host.Models.UserGroup didn't exist.\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userGroupControllerDelete: (id: number, params: RequestParams = {}) =>\n      this.http.request<void, ErrorMessageResponse>({\n        path: `/api/UserGroup/${id}`,\n        method: \"DELETE\",\n        secure: true,\n        ...params,\n      }),\n\n    /**\n     * No description\n     *\n     * @tags UserGroup\n     * @name UserGroupControllerList\n     * @summary Lists all Tgstation.Server.Host.Models.UserGroups.\n     * @request GET:/api/UserGroup/List\n     * @secure\n     * @response `200` `PaginatedUserGroupResponse` Retrieved Tgstation.Server.Host.Models.UserGroups successfully.\n     * @response `400` `ErrorMessageResponse`\n     * @response `401` `any`\n     * @response `403` `any`\n     * @response `406` `ErrorMessageResponse`\n     * @response `409` `ErrorMessageResponse`\n     * @response `500` `ErrorMessageResponse`\n     * @response `501` `ErrorMessageResponse`\n     * @response `503` `any`\n     */\n    userGroupControllerList: (query: UserGroupControllerListParams, params: RequestParams = {}) =>\n      this.http.request<PaginatedUserGroupResponse, ErrorMessageResponse>({\n        path: `/api/UserGroup/List`,\n        method: \"GET\",\n        query: query,\n        secure: true,\n        format: \"json\",\n        ...params,\n      }),\n  };\n}\n","import { OAuthProvider } from \"../generatedcode/generated\";\n\nexport enum CredentialsType {\n    Password,\n    OAuth\n}\n\nexport interface IPasswordCredentials {\n    type: CredentialsType.Password;\n    userName: string;\n    password: string;\n}\n\nexport interface IOAuthCredentials {\n    type: CredentialsType.OAuth;\n    provider: OAuthProvider;\n    token: string;\n}\n\nexport type ICredentials = IPasswordCredentials | IOAuthCredentials;\n","import { AxiosResponse } from \"axios\";\n\nimport { replaceAll } from \"../../../utils/misc\";\nimport { ErrorCode as TGSErrorCode, ErrorMessageResponse } from \"../../generatedcode/generated\";\nimport configOptions from \"../../util/config\";\nimport CredentialsProvider from \"../../util/CredentialsProvider\";\n\nexport type GenericErrors =\n    | ErrorCode.HTTP_BAD_REQUEST\n    | ErrorCode.HTTP_DATA_INEGRITY\n    | ErrorCode.HTTP_API_MISMATCH\n    | ErrorCode.HTTP_SERVER_ERROR\n    | ErrorCode.HTTP_UNIMPLEMENTED\n    //    | ErrorCode.HTTP_SERVER_NOT_READY\n    | ErrorCode.AXIOS\n    | ErrorCode.UNHANDLED_RESPONSE\n    | ErrorCode.UNHANDLED_GLOBAL_RESPONSE\n    | ErrorCode.HTTP_ACCESS_DENIED\n    | ErrorCode.HTTP_NOT_ACCEPTABLE\n    | ErrorCode.OK\n    | ErrorCode.NO_APIPATH\n    | ErrorCode.APP_FAIL;\n\nexport enum ErrorCode {\n    OK = 'Isnt displayed but is used as an \"error\" when everything is ok', //void\n    HTTP_BAD_REQUEST = \"error.http.bad_request\", //errmessage\n    HTTP_DATA_INEGRITY = \"error.http.data_integrity\", //errmessage\n    HTTP_API_MISMATCH = \"error.http.api_mismatch\", //void\n    HTTP_SERVER_ERROR = \"error.http.server_error\", //errmessage\n    HTTP_UNIMPLEMENTED = \"error.http.unimplemented\", //errmessage\n    //auto retry    HTTP_SERVER_NOT_READY = 'error.http.server_not_ready', //void\n    HTTP_ACCESS_DENIED = \"error.http.access_denied\", //void\n    HTTP_NOT_ACCEPTABLE = \"error.http.not_acceptable\", //void\n    UNHANDLED_RESPONSE = \"error.unhandled_response\", //axiosresponse\n    UNHANDLED_GLOBAL_RESPONSE = \"error.unhandled_global_response\", //axiosresponse\n    AXIOS = \"error.axios\", //jserror\n\n    //Generic errors\n    GITHUB_FAIL = \"error.github\", //jserror\n    APP_FAIL = \"error.app\", //jserror\n    NO_APIPATH = \"error.no_apipath\", //void\n\n    //Login errors\n    LOGIN_FAIL = \"error.login.bad_user_pass\", //void\n    LOGIN_NOCREDS = \"error.login.no_creds\", //void\n    LOGIN_DISABLED = \"error.login.user_disabled\", //void\n    LOGIN_BAD_OAUTH = \"error.login.bad_oauth\", //jserror\n    LOGIN_RATELIMIT = \"error.login.rate_limit\", //errmessage\n\n    //User errors\n    USER_NO_SYS_IDENT = \"error.user.no_sys_ident\", //errmessage\n    USER_NOT_FOUND = \"error.user.not_found\", //errmessage\n\n    //Administration errors\n    ADMIN_GITHUB_RATE = \"error.admin.rate\", //errmessage\n    ADMIN_GITHUB_ERROR = \"error.admin.error\", //errmessage\n    ADMIN_WATCHDOG_UNAVAIL = \"error.admin.watchdog.avail\", //errmessage\n    ADMIN_VERSION_NOT_FOUND = \"error.admin.update.notfound\", //errmessage\n    ADMIN_LOGS_IO_ERROR = \"error.admin.logs.io\", //errmessage\n\n    //Job errors\n    JOB_JOB_NOT_FOUND = \"error.job.not_found\", //errmessage\n    JOB_JOB_COMPLETE = \"error.job.complete\", //void\n\n    //Transfer errors\n    TRANSFER_NOT_AVAILABLE = \"error.transfer.not_available\", //errmessage\n    UPLOAD_FAILED = \"error.transfer.upload_failed\", //void\n\n    GROUP_NOT_FOUND = \"error.group.not_found\", //errmessage\n    GROUP_NOT_EMPTY = \"error.group.not_empty\", //errmessage\n\n    //Watchdog errors\n    NO_DB_ENTITY = \"error.no_db_entity\", //errmessage\n\n    //Engine errors\n    ENGINE_VERSION_NOT_FOUND = \"error.no_engine_version\",\n\n    //DreamMaker errors\n    COMPILE_JOB_NOT_FOUND = \"error.compile_job_not_found\", //errmessage\n\n    //Config File errors\n    CONFIG_FILE_NOT_FOUND = \"error.config_file_not_found\",\n    CONFIG_FILE_IO_ERROR = \"error.config_file_io\",\n    CONFIG_FILE_DIRECTORY_NOT_FOUND = \"error.config_file_directory_not_found\",\n\n    BAD_YML = \"error.bad_yml\",\n    BAD_TGS_YML_VERSION = \"error.bad_tgs_yml_version\",\n\n    BAD_CHANNELS_JSON = \"error.bad_channels_json\",\n\n    BAD_HUB_CONNECTION = \"error.bad_hub_connection\"\n}\n\ntype errorMessage = {\n    errorMessage: ErrorMessageResponse;\n};\ntype axiosResponse = {\n    axiosResponse: AxiosResponse;\n};\ntype jsError = {\n    jsError: Error;\n};\ntype voidError = {\n    void: true;\n};\n\nexport enum DescType {\n    LOCALE,\n    TEXT\n}\n\ninterface Desc {\n    type: DescType;\n    desc: string;\n}\n\nexport type allAddons = errorMessage | axiosResponse | jsError | voidError;\n\nexport default class InternalError<T extends ErrorCode = ErrorCode> {\n    public readonly code: T;\n    public readonly desc?: Desc;\n    public readonly extendedInfo: string;\n    public readonly originalErrorMessage?: ErrorMessageResponse;\n\n    public constructor(code: T, addon: allAddons, origin?: AxiosResponse, noError?: boolean) {\n        this.code = code;\n        if (\"errorMessage\" in addon) {\n            const err = addon.errorMessage;\n            this.originalErrorMessage = err;\n            this.desc = {\n                type: DescType.TEXT,\n                desc: `${TGSErrorCode[err.errorCode]}: ${err.message}${\n                    err.additionalData ? \": \" + err.additionalData : \"\"\n                }`\n            };\n            if (!err.message) {\n                this.desc = {\n                    type: DescType.TEXT,\n                    desc: TGSErrorCode[err.errorCode]\n                };\n            }\n        }\n        if (\"jsError\" in addon) {\n            const err = addon.jsError;\n            this.desc = {\n                type: DescType.TEXT,\n                desc: `${err.name}: ${err.message}`\n            };\n        }\n        const stack = new Error().stack;\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (origin?.config.headers[\"Authorization\"]) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            origin.config.headers[\"Authorization\"] = \"*********\";\n        }\n\n        let debuginfo = JSON.stringify({ addon, origin, config: configOptions, stack });\n        debuginfo = debuginfo.replace(\n            /Basic (?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?/g,\n            \"Basic **************\"\n        );\n        debuginfo = debuginfo.replace(\n            /{\"username\":\".+?\",\"password\":\".+?\"}/g,\n            '{\"username\":\"*******\",\"password\":\"*******\"}'\n        );\n        if (CredentialsProvider.hasToken()) {\n            debuginfo = replaceAll(debuginfo, CredentialsProvider.token!.bearer, \"**************\");\n        }\n        if (configOptions.githubtoken.value) {\n            debuginfo = replaceAll(\n                debuginfo,\n                configOptions.githubtoken.value as string,\n                \"**************\"\n            );\n        }\n        this.extendedInfo = debuginfo;\n\n        if (!noError) {\n            console.error(\n                `Error occured within the application: ${this.code} (${\n                    this.desc?.desc ?? \"No description\"\n                })`,\n                this\n            );\n        }\n\n        //@ts-expect-error yeah well, i aint extending the window interface\n        if (window.breakonerror) {\n            // eslint-disable-next-line no-debugger\n            debugger;\n        }\n    }\n}\n","import InternalError, { ErrorCode } from \"./InternalError\";\n\nexport enum StatusCode {\n    OK,\n    ERROR\n}\n\nexport interface InternalStatusErr<Codes extends ErrorCode> {\n    code: StatusCode.ERROR;\n    error: InternalError<Codes>;\n}\n\nexport interface InternalStatusOK<T> {\n    code: StatusCode.OK;\n    payload: T;\n}\n\ntype InternalStatus<T, Codes extends ErrorCode> = InternalStatusOK<T> | InternalStatusErr<Codes>;\n\nconst InternalStatus = (function InternalStatus<T, Codes extends ErrorCode>(\n    this: InternalStatus<T, Codes>,\n    args: InternalStatus<T, Codes>\n): Readonly<InternalStatus<T, Codes>> {\n    return Object.freeze(Object.assign({}, args));\n} as unknown) as {\n    new <T, Codes extends ErrorCode>(args: InternalStatus<T, Codes>): Readonly<\n        InternalStatus<T, Codes>\n    >;\n};\n\nexport default InternalStatus;\n","import configOptions, { BaseConfigOption, ConfigOption, ConfigValue } from \"./config\";\n\nexport default new (class ConfigController {\n    public loadconfig() {\n        for (const val of Object.values(configOptions)) {\n            this.getconfig(val);\n        }\n        console.log(\"Configuration loaded\", configOptions);\n    }\n\n    public saveconfig(newconfig: Partial<typeof configOptions>) {\n        for (const [key, val] of Object.entries(newconfig)) {\n            this.setconfig(key as keyof typeof configOptions, val);\n        }\n        console.log(\"Configuration saved\", configOptions);\n    }\n\n    private getConfigKey(option: BaseConfigOption): string {\n        if (!option.site_local) return option.id;\n\n        return `${window.location.pathname}:${option.id}`;\n    }\n\n    private setconfig(key: keyof typeof configOptions, option: ConfigOption) {\n        if (option?.value === undefined) return this.deleteconfig(key);\n\n        //safeties\n        switch (option.type) {\n            case \"num\": {\n                //this parses strings and numbers alike to numbers and refuses non numbers\n                //@ts-expect-error //parseInt can take numbers\n                const value = parseInt(option.value);\n                if (Number.isNaN(option.value)) return;\n                if (option.min !== undefined && value < option.min) return;\n                if (option.max !== undefined && value > option.max) return;\n                option.value = value;\n                break;\n            }\n        }\n\n        if (option.callback) {\n            // @ts-expect-error Can't be assed to figure this one out\n            option.callback(configOptions[key].value, option.value);\n        }\n        configOptions[key].value = option.value;\n        //configOptions[key].persist = option.persist;\n\n        //if (!option.persist) return this.deleteconfig(key); //idiot proofing, alexkar proofing\n\n        try {\n            localStorage.setItem(this.getConfigKey(option), JSON.stringify(option.value));\n            //option.persist = true;\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n\n    private getconfig(option: ConfigOption): void {\n        try {\n            const data = localStorage.getItem(this.getConfigKey(option));\n            if (data !== undefined && data !== null) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const json = JSON.parse(data);\n                if (json !== null && json !== undefined) {\n                    option.value = json as ConfigValue;\n                }\n                //option.persist = true;\n            }\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n\n    private deleteconfig(key: keyof typeof configOptions): void {\n        try {\n            const option = configOptions[key];\n            localStorage.removeItem(this.getConfigKey(option));\n            //option.persist = false;\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n})();\n","import { MODE } from \"../../definitions/constants\";\nimport type { TokenResponse } from \"../generatedcode/generated\";\nimport { CredentialsType, ICredentials, IPasswordCredentials } from \"../models/ICredentials\";\n\n//Data structure meant to help against circular dependencies within the ApiClient\n//Its rather dumb and only holds username, password and the token.\n//Also contains a function to determine if theres a token here\nexport default new (class CredentialsProvider {\n    //token\n    public token?: TokenResponse;\n    public defaulted?: boolean;\n\n    //credentials\n    public credentials?: ICredentials;\n    public default: IPasswordCredentials = {\n        type: CredentialsType.Password,\n        userName: \"admin\",\n        password: \"ISolemlySwearToDeleteTheDataDirectory\"\n    };\n\n    public hasToken() {\n        return (\n            this.token &&\n            this.token\n                .bearer /* &&\n            (!this.token.expiresAt || new Date(this.token.expiresAt) > new Date(Date.now()))*/\n        );\n    }\n\n    public constructor() {\n        if (MODE === \"DEV\") {\n            window.credentialProvider = this;\n        }\n    }\n})();\n","import * as signalR from \"@microsoft/signalr\";\nimport { gte as SemVerGte, satisfies as SemverSatisfies } from \"semver\";\nimport { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { resolvePermissionSet } from \"../../utils/misc\";\nimport {\n    AdministrationRights,\n    ChatBotRights,\n    ConfigurationRights,\n    DreamDaemonRights,\n    DreamMakerRights,\n    EngineRights,\n    ErrorCode as TGSErrorCode,\n    InstanceManagerRights,\n    InstancePermissionSetRights,\n    InstanceResponse,\n    JobResponse,\n    RepositoryRights,\n    RightsType\n} from \"../generatedcode/generated\";\nimport InstanceClient from \"../InstanceClient\";\nimport InstancePermissionSetClient from \"../InstancePermissionSetClient\";\nimport JobsClient, { TGSJobResponse } from \"../JobsClient\";\nimport InternalError, { ErrorCode } from \"../models/InternalComms/InternalError\";\nimport { StatusCode } from \"../models/InternalComms/InternalStatus\";\nimport ServerClient from \"../ServerClient\";\nimport UserClient from \"../UserClient\";\nimport configOptions from \"./config\";\nimport LoginHooks from \"./LoginHooks\";\n\ninterface IEvents {\n    jobsLoaded: () => unknown;\n}\n\nexport default new (class JobsController extends TypedEmitter<IEvents> {\n    private fastmodecount = 0;\n    public set fastmode(cycles: number) {\n        const doStuff = async () => {\n            if (await this.jobsHubSupported()) {\n                return;\n            }\n\n            console.log(`JobsController going in fastmode for ${cycles} cycles`);\n            this.fastmodecount = cycles;\n            await this.restartLoop();\n        };\n        void doStuff();\n    }\n\n    private currentLoop: Date = new Date(0);\n    public accessibleInstances = new Map<number, InstanceResponse>();\n\n    private enableJobProgressWorkaround?: boolean;\n\n    public errors: InternalError[] = [];\n    public nextRetry: Date | null;\n    public jobs = new Map<number, TGSJobResponse>();\n    public jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n    private jobCallback = new Map<number, Set<(job: TGSJobResponse) => unknown>>();\n    private lastSeenJob = -1;\n\n    private connection: signalR.HubConnection | null;\n\n    public async reset(clearJobs: boolean): Promise<void> {\n        console.log(\"JobsController resetting\");\n        if (clearJobs) {\n            this.jobs = new Map<number, TGSJobResponse>();\n            this.jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n        }\n\n        try {\n            await this.reloadAccessibleInstances();\n        } catch (e) {\n            this.errors.push(\n                new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e as string) })\n            );\n            return;\n        }\n\n        await this.restartLoop();\n    }\n\n    public constructor() {\n        super();\n\n        this.connection = null;\n        this.nextRetry = null;\n        this.loop = this.loop.bind(this);\n        this.reset = this.reset.bind(this);\n        this.cleanConnection = this.cleanConnection.bind(this);\n        this.restartLoop = this.restartLoop.bind(this);\n    }\n\n    private async stopAndRemoveConnection(): Promise<void> {\n        console.log(\"JobsController: stopAndRemoveConnection\");\n\n        if (this.connection) {\n            console.log(\n                `Stopping and removing active hub connection. State is: ${this.connection.state}`\n            );\n            const connectionToStop = this.connection;\n            this.connection = null;\n            await connectionToStop.stop();\n        }\n    }\n\n    private async cleanConnection(): Promise<void> {\n        if (!(await this.jobsHubSupported())) {\n            return;\n        }\n\n        console.log(\"JobsController: cleanConnection\");\n\n        await this.stopAndRemoveConnection();\n\n        this.errors = [];\n        this.nextRetry = null;\n        this.jobs = new Map<number, TGSJobResponse>();\n        this.jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n        this.emit(\"jobsLoaded\");\n    }\n\n    public init() {\n        window.clients[\"JobsController\"] = this;\n\n        //technically not a \"cache\" but we might as well reload it\n        ServerClient.on(\"purgeCache\", () => void this.reset(true));\n        ServerClient.on(\"logout\", () => void this.cleanConnection());\n\n        InstanceClient.on(\"instanceChange\", () => void this.reset(false));\n        // eslint-disable-next-line @typescript-eslint/require-await\n        LoginHooks.addHook(async () => {\n            console.log(\"JobsController resetting due to login\");\n            await this.reset(true);\n        });\n\n        ServerClient.on(\"loadServerInfo\", response => {\n            if (response.code === StatusCode.OK) {\n                //A bug in versions below 4.11.0 makes it so that /Job/List doesn't report back progress. If we are running on a higher version, theres no point in enabling the workaround\n                this.enableJobProgressWorkaround = SemverSatisfies(\n                    response.payload.version,\n                    \"<4.11.0\"\n                );\n            }\n        });\n    }\n\n    private async reloadAccessibleInstances(loop = false): Promise<void> {\n        const allInstances: InstanceResponse[] = [];\n\n        const instances1 = await InstanceClient.listInstances({ pageSize: 100 });\n        if (instances1.code === StatusCode.ERROR) {\n            this.errors.push(instances1.error);\n            return;\n        } else {\n            allInstances.push(...instances1.payload.content);\n        }\n        for (let i = 2; i <= instances1.payload.totalPages; i++) {\n            const instances2 = await InstanceClient.listInstances({ page: i, pageSize: 100 });\n            if (instances2.code === StatusCode.ERROR) {\n                this.errors.push(instances2.error);\n                return;\n            } else {\n                allInstances.push(...instances2.payload.content);\n            }\n        }\n\n        const updatedSet = new Map<number, InstanceResponse>();\n\n        const work = allInstances\n            .filter(instance => instance.online && instance.accessible)\n            .map(instance => {\n                return InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    instance.id\n                ).then(permissionSet => {\n                    if (permissionSet.code === StatusCode.ERROR) {\n                        //If its access denied, it means we have view all instances but we dont have access to the instance itself\n                        if (permissionSet.error.code !== ErrorCode.HTTP_ACCESS_DENIED) {\n                            this.errors.push(permissionSet.error);\n                        }\n                        return;\n                    }\n                    updatedSet.set(instance.id, instance);\n                });\n            });\n\n        await Promise.all(work);\n\n        this.accessibleInstances = updatedSet;\n\n        if (loop) {\n            window.setTimeout(\n                () => void this.reloadAccessibleInstances(true),\n                configOptions.instanceprobetimer.value as number\n            );\n        }\n    }\n\n    private async jobsHubSupported(): Promise<boolean> {\n        if (configOptions.restjobs2.value as boolean) {\n            return false;\n        }\n\n        if (this.connection) {\n            return true;\n        }\n\n        const serverInfo = await ServerClient.getServerInfo();\n        if (serverInfo.code === StatusCode.OK) {\n            return SemVerGte(serverInfo.payload.apiVersion, \"9.13.0\");\n        }\n\n        console.warn(\"Failed to retrieve server info to determin jobs hub support!\");\n\n        return false;\n    }\n\n    public async restartLoop(): Promise<void> {\n        console.log(\"JobsController: restartLoop\");\n        if (!(await this.jobsHubSupported())) {\n            //we use an actual date object here because it could help prevent really weird timing\n            // issues as two different date objects cannot be equal\n            // despite the date being\n            const initDate = new Date(Date.now());\n            this.currentLoop = initDate;\n            window.setTimeout(() => {\n                this.loop(initDate).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, 0);\n\n            return;\n        }\n\n        await this.stopAndRemoveConnection();\n\n        this.nextRetry = null;\n\n        let apiPath = configOptions.apipath.value as string;\n        if (!apiPath.endsWith(\"/\")) {\n            apiPath = apiPath + \"/\";\n        }\n\n        const localConnection = (this.connection = new signalR.HubConnectionBuilder()\n            .withUrl(`${apiPath}api/hubs/jobs`, {\n                accessTokenFactory: async () => {\n                    const token = await ServerClient.wait4Token();\n                    return token.bearer;\n                },\n                transport: signalR.HttpTransportType.ServerSentEvents,\n                headers: ServerClient.defaultHeaders\n            })\n            .withAutomaticReconnect({\n                nextRetryDelayInMilliseconds: (retryContext: signalR.RetryContext) => {\n                    if (retryContext.previousRetryCount == 0) {\n                        return 0;\n                    }\n\n                    const nextRetryMs = Math.min(2 ** retryContext.previousRetryCount, 30) * 1000;\n                    const retryDate = new Date();\n                    retryDate.setMilliseconds(retryDate.getMilliseconds() + nextRetryMs);\n                    this.nextRetry = retryDate;\n                    this.emit(\"jobsLoaded\");\n                    return nextRetryMs;\n                }\n            })\n            .configureLogging(signalR.LogLevel.Trace)\n            .build());\n\n        localConnection.on(\"ReceiveJobUpdate\", async (job: JobResponse) => {\n            console.log(`Received update for job ${job.id}`);\n            this.registerJob(job, job.instanceId);\n            this.emit(\"jobsLoaded\");\n            const canCancel = await this.canCancel(job, this.errors);\n            if (this.jobs.has(job.id)) {\n                this.jobs.get(job.id)!.canCancel = canCancel;\n                this.emit(\"jobsLoaded\");\n            }\n        });\n\n        let justReconnected = true;\n        let reconnectionTimeout: NodeJS.Timeout | null = null;\n        localConnection.onreconnected(() => {\n            this.nextRetry = null;\n            justReconnected = true;\n            this.emit(\"jobsLoaded\");\n            console.log(\"Jobs hub connection re-established, running refresh...\");\n\n            // at this point we need to manually load all the jobs we have registered in case they've completed in the hub and are no longer receiving updates\n            const forcedRefresh = async () => {\n                clearTimeout(reconnectionTimeout!);\n                reconnectionTimeout = null;\n                if (localConnection.state !== signalR.HubConnectionState.Connected) {\n                    return;\n                }\n\n                justReconnected = false;\n\n                this.errors = [];\n                this.emit(\"jobsLoaded\");\n                await this.reloadAccessibleInstances(false);\n                await this.loop((this.currentLoop = new Date()));\n            };\n\n            if (reconnectionTimeout) {\n                clearTimeout(reconnectionTimeout);\n            }\n\n            reconnectionTimeout = setTimeout(() => void forcedRefresh(), 3000);\n        });\n\n        localConnection.onreconnecting(() => {\n            if (justReconnected) {\n                if (reconnectionTimeout) {\n                    clearTimeout(reconnectionTimeout);\n                    reconnectionTimeout = null;\n                }\n\n                const relog = async () => {\n                    // we reconnected and then got disconnected? That's an auth issue\n                    const result = await ServerClient.login();\n                    if (result.code != StatusCode.OK) {\n                        ServerClient.logout();\n                    } else {\n                        justReconnected = false;\n                    }\n                };\n\n                void relog();\n                return;\n            }\n\n            this.errors = [];\n            this.errors.push(new InternalError(ErrorCode.BAD_HUB_CONNECTION, { void: true }));\n            this.emit(\"jobsLoaded\");\n        });\n\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        localConnection.start().catch(error => {\n            if (this.connection != localConnection) {\n                return;\n            }\n\n            this.errors = [];\n            if (error instanceof Error) {\n                this.errors.push(\n                    new InternalError(ErrorCode.BAD_HUB_CONNECTION, { jsError: error })\n                );\n            } else {\n                this.errors.push(new InternalError(ErrorCode.BAD_HUB_CONNECTION, { void: true }));\n            }\n            this.emit(\"jobsLoaded\");\n            this.connection = null;\n        });\n    }\n\n    private _registerJob(job: TGSJobResponse, instanceid?: number): void;\n    // noinspection JSUnusedLocalSymbols\n    private _registerJob(job: JobResponse, instanceid: number): void;\n    private _registerJob(_job: JobResponse | TGSJobResponse, instanceid?: number) {\n        const job = _job as TGSJobResponse;\n        if (this.jobs.has(job.id) && this.jobs.get(job.id)!.stoppedAt) {\n            console.warn(\n                `Receieved job update for ${job.id} after it completed! Incoming job was${\n                    job.stoppedAt ? \"\" : \" not\"\n                } completed.`\n            );\n            return;\n        }\n\n        if (instanceid) job.instanceId = instanceid;\n        const instanceSet = this.jobsByInstance.get(job.instanceId) ?? new Map();\n        this.jobsByInstance.set(job.instanceId, instanceSet);\n        instanceSet.set(job.id, job);\n        this.jobs.set(job.id, job);\n    }\n\n    public registerJob(job: TGSJobResponse, instanceid?: number): void;\n    public registerJob(job: JobResponse, instanceid: number): void;\n    public registerJob(_job: JobResponse | TGSJobResponse, instanceid?: number) {\n        this._registerJob(_job, instanceid);\n\n        const doStuff = async () => {\n            if (!(await this.jobsHubSupported())) {\n                console.log(\n                    \"Server does not support jobs hub, restarting loop due to job registration.\"\n                );\n                await this.restartLoop();\n            }\n        };\n\n        void doStuff();\n    }\n\n    private async loop(loopid: Date) {\n        //so loops get initialiazed with the current time, it keeps track of which loop to run with\n        // that initialization date in currentLoop if the currentLoop isnt equal to the one provided\n        // to the loop, it means that the loop was\n        // replaced so we dont try to call for another one\n        if (loopid !== this.currentLoop) {\n            return;\n        }\n\n        //time to clear out errors\n        this.errors = [];\n\n        let totalActiveJobs = 0;\n        const work: Promise<void>[] = [];\n\n        //We can't update the value immediatly or instances will conflict with each other and prevent some jobs from fetching\n        let tempLastSeenJob = this.lastSeenJob;\n        for (const instanceid of this.accessibleInstances.keys()) {\n            const processJobs = async (jobs: TGSJobResponse[]) => {\n                for (const job of jobs) {\n                    this._registerJob(job);\n                    tempLastSeenJob = Math.max(tempLastSeenJob, job.id);\n                }\n\n                const remoteActive = jobs.map(job => job.id);\n                const localActive = Array.from(this.jobs.values())\n                    .filter(job => !job.stoppedAt)\n                    .filter(job => job.instanceId === instanceid)\n                    .map(job => job.id);\n                const manualIds = localActive.filter(jobId => !remoteActive.includes(jobId));\n\n                const instanceSet = this.jobsByInstance.get(instanceid) ?? new Map();\n                this.jobsByInstance.set(instanceid, instanceSet);\n                const work: Promise<void>[] = [];\n                manualIds.forEach(jobId => {\n                    work.push(\n                        JobsClient.getJob(instanceid, jobId).then(job => {\n                            if (job.code === StatusCode.ERROR) {\n                                this.errors.push(job.error);\n                                return;\n                            }\n                            instanceSet.set(job.payload.id, job.payload);\n                            this.jobs.set(job.payload.id, job.payload);\n                        })\n                    );\n                });\n                await Promise.all(work);\n\n                if (loopid !== this.currentLoop) return;\n\n                totalActiveJobs += jobs.length;\n            };\n\n            const processError = (error: InternalError) => {\n                if (\n                    error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                    error.originalErrorMessage?.errorCode === TGSErrorCode.InstanceOffline\n                ) {\n                    console.log(\n                        `[JobsController] Clearing instance ${instanceid} as it is now offline`\n                    );\n                    this.accessibleInstances.delete(instanceid);\n                    //Probably a good idea to reload the list at this point\n                    this.reloadAccessibleInstances().catch(e => {\n                        this.errors.push(\n                            new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) })\n                        );\n                    });\n                } else {\n                    this.errors.push(error);\n                }\n            };\n\n            const fetchJobs =\n                this.lastSeenJob === -1 ? JobsClient.listActiveJobs : JobsClient.listJobs;\n            //now since this is async, it still possible that a single fire gets done after the new loop started, theres no really much that can be done about it\n            work.push(\n                fetchJobs(instanceid, { page: 1, pageSize: 10 })\n                    .then(async value => {\n                        //this check is here because the request itself is async and could return after\n                        // the loop is terminated, we dont want to contaminate the jobs of an instance\n                        // with the jobs of another even if it is for a single fire and would eventually\n                        // get fixed on its own after a few seconds\n                        if (loopid !== this.currentLoop) return;\n\n                        if (value.code === StatusCode.OK) {\n                            let lastPayload = value.payload.content;\n                            fetchLoop: for (let i = 2; i <= value.payload.totalPages; i++) {\n                                for (const job of lastPayload) {\n                                    //We reached the last page of usable content, break the loop\n                                    if (job.id <= this.lastSeenJob) {\n                                        break fetchLoop;\n                                    }\n                                }\n                                const jobs2 = await fetchJobs(instanceid, {\n                                    page: i,\n                                    pageSize: 10\n                                });\n                                if (jobs2.code === StatusCode.ERROR) {\n                                    processError(jobs2.error);\n                                    return;\n                                } else {\n                                    value.payload.content.push(...jobs2.payload.content);\n                                    lastPayload = value.payload.content;\n                                }\n                            }\n                            if (loopid !== this.currentLoop) return;\n                            await processJobs(\n                                value.payload.content.filter(\n                                    job => job.id > this.lastSeenJob || this.jobs.has(job.id)\n                                )\n                            );\n                        } else {\n                            processError(value.error);\n                        }\n                    })\n                    .catch(reason => {\n                        console.error(reason);\n                    })\n            );\n        }\n\n        await Promise.all(work);\n\n        this.lastSeenJob = tempLastSeenJob;\n\n        work.length = 0;\n        for (const job of this.jobs.values()) {\n            if (\n                this.enableJobProgressWorkaround &&\n                job.progress === undefined &&\n                !job.stoppedAt &&\n                this.accessibleInstances.has(job.instanceId)\n            ) {\n                work.push(\n                    JobsClient.getJob(job.instanceId, job.id).then(progressedjob => {\n                        if (loopid !== this.currentLoop) return;\n                        if (progressedjob.code === StatusCode.OK) {\n                            job.progress = progressedjob.payload.progress;\n                        } else {\n                            if (\n                                progressedjob.error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                                progressedjob.error.originalErrorMessage?.errorCode ===\n                                    TGSErrorCode.InstanceOffline\n                            ) {\n                                console.log(\n                                    `[JobsController] Clearing instance ${job.instanceId} as it is now offline`\n                                );\n                                this.accessibleInstances.delete(job.instanceId);\n                                //Probably a good idea to reload the list at this point\n                                this.reloadAccessibleInstances().catch(e => {\n                                    this.errors.push(\n                                        new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) })\n                                    );\n                                });\n                            } else {\n                                this.errors.push(progressedjob.error);\n                            }\n                        }\n                    })\n                );\n            }\n\n            work.push(\n                this.canCancel(job, this.errors).then(canCancel => {\n                    if (loopid !== this.currentLoop) return;\n                    job.canCancel = canCancel;\n                })\n            );\n        }\n\n        //populate fields on jobs\n        await Promise.all(work);\n        if (loopid !== this.currentLoop) return;\n\n        this.emit(\"jobsLoaded\");\n\n        for (const job of this.jobs.values()) {\n            if (!job.stoppedAt) continue;\n            const callbacks = this.jobCallback.get(job.id);\n            if (!callbacks) continue;\n            for (const callback of callbacks) {\n                callback(job);\n            }\n            this.jobCallback.delete(job.id);\n        }\n\n        if (this.fastmodecount && loopid === this.currentLoop) {\n            window.setTimeout(() => {\n                this.loop(loopid).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, 800);\n            this.fastmodecount--;\n            console.log(`JobsController will remain in fastmode for ${this.fastmodecount} cycles`);\n        } else {\n            window.setTimeout(() => {\n                this.loop(loopid).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, (totalActiveJobs ? (configOptions.jobpollactive.value as number) : (configOptions.jobpollinactive.value as number)) * 1000);\n        }\n    }\n\n    private async canCancel(\n        job: Readonly<TGSJobResponse>,\n        errors: InternalError<ErrorCode>[]\n    ): Promise<boolean> {\n        //we dont need to reevalutate stuff that we already know\n        if (job.canCancel !== undefined) return job.canCancel;\n\n        if (job.cancelRightsType === undefined) {\n            return true;\n        }\n\n        switch (job.cancelRightsType as RightsType) {\n            case RightsType.Administration: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as AdministrationRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).administrationRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.InstanceManager: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstanceManagerRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).instanceManagerRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.Engine: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as EngineRights;\n                    return !!(InstancePermissionSet.payload.engineRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.ChatBots: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ChatBotRights;\n                    return !!(InstancePermissionSet.payload.chatBotRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Configuration: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ConfigurationRights;\n                    return !!(InstancePermissionSet.payload.configurationRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamDaemon: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamDaemonRights;\n                    return !!(InstancePermissionSet.payload.dreamDaemonRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamMaker: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamMakerRights;\n                    return !!(InstancePermissionSet.payload.dreamMakerRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.InstancePermissionSet: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstancePermissionSetRights;\n                    return !!(InstancePermissionSet.payload.instancePermissionSetRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Repository: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as RepositoryRights;\n                    return !!(InstancePermissionSet.payload.repositoryRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n        }\n    }\n\n    public async cancelJob(\n        jobid: number,\n        onError: (error: InternalError<ErrorCode>) => void\n    ): Promise<boolean> {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        const deleteInfo = await JobsClient.deleteJob(job.instanceId, jobid);\n        if (deleteInfo.code === StatusCode.OK) {\n            return true;\n        } else {\n            onError(deleteInfo.error);\n            return false;\n        }\n    }\n\n    public clearJob(jobid: number, noEmit = false): boolean {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        this.jobsByInstance.get(job.instanceId)?.delete(jobid);\n        this.jobs.delete(jobid);\n        if (!noEmit) {\n            this.emit(\"jobsLoaded\");\n        }\n        return true;\n    }\n\n    public registerCallback(jobid: number, callback: (job: TGSJobResponse) => unknown): void {\n        const set = this.jobCallback.get(jobid) ?? new Set();\n        set.add(callback);\n        this.jobCallback.set(jobid, set);\n    }\n})();\n","import { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport type { TokenResponse } from \"../generatedcode/generated\";\n\ninterface IEvents {\n    //tasks once the user is fully logged in\n    loginSuccess: (token: TokenResponse) => void;\n}\n\nclass LoginHooks extends TypedEmitter<IEvents> {\n    private promiseHooks: Set<(token: TokenResponse) => Promise<unknown>> = new Set();\n\n    public runHooks(token: TokenResponse) {\n        console.log(\"Running login hooks\");\n        let i = 0;\n        const work: Array<Promise<void>> = [];\n        for (const hook of this.promiseHooks) {\n            const id = i;\n            console.log(`Running hook ${hook.name}(${id})`);\n            work.push(\n                new Promise<void>((resolve, reject) => {\n                    hook(token)\n                        .then(() => {\n                            console.log(`Done hook ${hook.name}(${id})`);\n                            resolve();\n                        })\n                        .catch(err => {\n                            console.error(`Error running hook ${hook.name}(${id}): `, err);\n                            reject(err);\n                        });\n                })\n            );\n            i++;\n        }\n        Promise.all(work)\n            .then(() => {\n                console.log(\"Running post login event\");\n                this.emit(\"loginSuccess\", token);\n            })\n            .catch(() => console.error(\"An error occured while running login hooks\"));\n    }\n\n    public addHook(hook: (token: TokenResponse) => Promise<unknown>): void {\n        this.promiseHooks.add(hook);\n    }\n\n    public removeHook(hook: (token: TokenResponse) => Promise<unknown>): void {\n        this.promiseHooks.delete(hook);\n    }\n}\n\nexport default new LoginHooks();\n","import { DEFAULT_APIPATH, MODE } from \"../../definitions/constants\";\n\nexport type ConfigValue = number | string | boolean;\n\nexport type ConfigOption = BaseConfigOption &\n    (NumConfigOption | StrConfigOption | PwdConfigOption | BoolConfigOption | EnumConfigOption);\n\nexport interface BaseConfigOption {\n    id: string;\n    site_local?: boolean;\n}\n\nexport interface NumConfigOption extends BaseConfigOption {\n    type: \"num\";\n    value: number;\n    min?: number;\n    max?: number;\n    callback?: (oldValue: number, newValue: number) => void;\n}\nexport interface StrConfigOption extends BaseConfigOption {\n    type: \"str\";\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\nexport interface PwdConfigOption extends BaseConfigOption {\n    type: \"pwd\";\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\nexport interface BoolConfigOption extends BaseConfigOption {\n    type: \"bool\";\n    value: boolean;\n    callback?: (oldValue: boolean, newValue: boolean) => void;\n}\nexport interface EnumConfigOption extends BaseConfigOption {\n    type: \"enum\";\n    possibleValues: Record<string, string>;\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\n\nexport type ConfigMap = {\n    [key: string]: ConfigOption;\n};\n\nexport enum jobsWidgetOptions {\n    ALWAYS = \"always\",\n    AUTO = \"auto\",\n    NEVER = \"never\"\n}\n\nexport enum InstanceEditSidebar {\n    AUTO = \"auto\",\n    COLLAPSE = \"collapse\",\n    EXPAND = \"expand\"\n}\n\n//https://stackoverflow.com/questions/54598322/how-to-make-typescript-infer-the-keys-of-an-object-but-define-type-of-its-value\n//Infer the keys but restrict the values to a type\nconst asElementTypesConfig = <Type>(\n    elements: {\n        [Property in keyof Type]: ConfigOption;\n    }\n) => elements;\n\nconst configOptions = asElementTypesConfig({\n    githubtoken: {\n        id: \"config.githubtoken\",\n        type: \"pwd\",\n        value: \"\"\n    },\n    apipath: {\n        id: \"config.apipath\",\n        type: \"str\",\n        site_local: true,\n        value:\n            MODE === \"DEV\"\n                ? DEFAULT_APIPATH\n                : window.publicPath\n                ? new URL(\"..\", new URL(window.publicPath, window.location.href)).href\n                : DEFAULT_APIPATH\n    },\n    jobpollinactive: {\n        id: \"config.jobpollinactive\",\n        type: \"num\",\n        value: 15\n    },\n    jobpollactive: {\n        id: \"config.jobpollactive\",\n        type: \"num\",\n        value: 5\n    },\n    jobswidgetdisplay: {\n        id: \"config.jobswidgetdisplay\",\n        type: \"enum\",\n        possibleValues: jobsWidgetOptions,\n        value: jobsWidgetOptions.AUTO\n    },\n    instanceprobetimer: {\n        id: \"config.instanceprobetimer\",\n        type: \"num\",\n        value: 60\n    },\n    itemsperpage: {\n        id: \"config.itemsperpage\",\n        type: \"num\",\n        value: 25,\n        min: 1,\n        max: 100\n    },\n    instanceeditsidebar: {\n        id: \"config.instanceeditsidebar\",\n        type: \"enum\",\n        possibleValues: InstanceEditSidebar,\n        value: InstanceEditSidebar.AUTO\n    },\n    showjson: {\n        id: \"config.showjson\",\n        type: \"bool\",\n        value: MODE === \"DEV\"\n    },\n    manualpr: {\n        id: \"config.manualpr\",\n        type: \"bool\",\n        value: true\n    },\n    restjobs2: {\n        id: \"config.restjobs2\",\n        type: \"bool\",\n        value: false\n    }\n});\n\nexport default configOptions;\n"],"names":["ApiClient","cachedAdminInfo","this","_cachedAdminInfo","constructor","super","loadingAdminInfo","ServerClient","undefined","Promise","resolve","resolver","user","removeListener","on","response","stat","res","InternalStatus","code","StatusCode","error","emit","status","thing","payload","data","errorMessage","InternalError","ErrorCode","axiosResponse","newVersion","file","uploadZip","upload","TransferClient","fileTicket","page","pageSize","configOptions","logName","progressHandler","logFileResponse","contents","temp","Object","assign","content","text","instance","id","instanceid","_cachedInstancePermissionSet","Map","loadingInstancePermissionSetInfo","clear","headers","Instance","toString","noCache","has","get","set","permissionSetId","instancePermissionSet","newContent","map","job","jobid","void","apiHttpClient","apiClient","apiRequestInterceptor","onFulfilled","async","errorobj","reject","value","overrideTokenDetection","url","tok","wait4Token","bearer","onRejected","apiResponseInterceptor","val","axiosServer","snowflake","globalHandledCodes","includes","err","jsError","request","config","autoLogin","login","then","logout","method","console","log","setTimeout","initialized","loadingServerInfo","_serverInfo","loggingIn","getServerInfo","bind","LoginHooks","CredentialsProvider","window","location","reload","serverInfo","defaultHeaders","Accept","Api","API_VERSION","VERSION","time","HttpClient","baseURL","withCredentials","validateStatus","interceptors","use","timeEnd","result","localStorage","getItem","expiresAtUnixTimestampStr","defaultToken","parseInt","Date","now","storedToken","setToken","wait4Init","token","newCreds","defaulted","oauthAutoLogin","type","CredentialsType","info","api","apiRootControllerCreateToken","auth","username","password","OAuthProvider","Authorization","removeItem","_token","bypassCache","apiRootControllerServerInfo","cache","validate","previousToken","previousDefaulted","failed","setItem","jwt","jwtDecode","exp","ticket","format","onDownloadProgress","e","cachedUser","_cachedUser","loadingUserInfo","createAllUsersWithAA","getCurrentUser","newUser","current","sort","a","b","newuser","enabled","instanceManagerRights","administrationRights","perm","values","InstanceManagerRights","AdministrationRights","TypedEmitter","clients","name","ChatBotRights","ChatProvider","ConfigurationRights","ConfigurationType","DreamDaemonRights","DreamDaemonSecurity","DreamDaemonVisibility","DreamMakerRights","EngineRights","EngineType","InstancePermissionSetRights","JobCode","RemoteGitProvider","RepositoryRights","RightsType","WatchdogStatus","ContentType","securityWorker","secure","axiosConfig","securityData","setSecurityData","path","query","body","params","secureParams","requestParams","mergeRequestParams","responseFormat","FormData","common","post","put","createFormData","responseType","axios","params1","params2","defaults","input","keys","reduce","formData","key","property","append","Blob","JSON","stringify","http","administrationControllerRead","administrationControllerUpdate","Json","administrationControllerDelete","administrationControllerListLogs","administrationControllerGetLog","chatControllerCreate","chatControllerUpdate","chatControllerDelete","chatControllerGetId","chatControllerList","configurationControllerUpdate","configurationControllerCreateDirectory","configurationControllerDeleteDirectory","configurationControllerFile","filePath","configurationControllerDirectory","directoryPath","configurationControllerList","dreamDaemonControllerCreate","dreamDaemonControllerRead","dreamDaemonControllerDelete","dreamDaemonControllerUpdate","dreamDaemonControllerRestart","dreamDaemonControllerCreateDump","dreamMakerControllerRead","dreamMakerControllerCreate","dreamMakerControllerUpdate","dreamMakerControllerGetId","dreamMakerControllerList","engineControllerRead","engineControllerUpdate","engineControllerDelete","engineControllerList","instanceControllerCreate","instanceControllerUpdate","instanceControllerDelete","instanceControllerGetId","instanceControllerGrantPermissions","instanceControllerList","instancePermissionSetControllerCreate","instancePermissionSetControllerUpdate","instancePermissionSetControllerRead","instancePermissionSetControllerList","instancePermissionSetControllerGetId","instancePermissionSetControllerDelete","jobControllerRead","jobControllerList","jobControllerDelete","jobControllerGetId","repositoryControllerCreate","repositoryControllerDelete","repositoryControllerRead","repositoryControllerUpdate","transferControllerDownload","transferControllerUpload","userControllerCreate","userControllerUpdate","userControllerRead","userControllerList","userControllerGetId","userGroupControllerCreate","userGroupControllerUpdate","userGroupControllerGetId","userGroupControllerDelete","userGroupControllerList","DescType","addon","origin","noError","desc","extendedInfo","originalErrorMessage","TEXT","TGSErrorCode","errorCode","message","additionalData","stack","Error","debuginfo","replace","replaceAll","breakonerror","args","freeze","loadconfig","getconfig","saveconfig","newconfig","entries","setconfig","getConfigKey","option","site_local","pathname","deleteconfig","Number","isNaN","min","max","callback","json","parse","hasToken","credentials","default","userName","fastmode","cycles","jobsHubSupported","fastmodecount","restartLoop","doStuff","clearJobs","jobs","jobsByInstance","reloadAccessibleInstances","errors","push","currentLoop","accessibleInstances","enableJobProgressWorkaround","nextRetry","jobCallback","lastSeenJob","connection","loop","reset","cleanConnection","state","connectionToStop","stop","stopAndRemoveConnection","init","InstanceClient","SemverSatisfies","version","allInstances","instances1","i","totalPages","instances2","updatedSet","work","filter","online","accessible","InstancePermissionSetClient","permissionSet","all","SemVerGte","apiVersion","warn","initDate","catch","apiPath","endsWith","localConnection","signalR","withUrl","accessTokenFactory","transport","withAutomaticReconnect","nextRetryDelayInMilliseconds","retryContext","previousRetryCount","nextRetryMs","Math","retryDate","setMilliseconds","getMilliseconds","configureLogging","build","registerJob","instanceId","canCancel","justReconnected","reconnectionTimeout","onreconnected","forcedRefresh","clearTimeout","onreconnecting","relog","start","_registerJob","_job","stoppedAt","instanceSet","loopid","totalActiveJobs","tempLastSeenJob","processJobs","remoteActive","manualIds","Array","from","jobId","forEach","JobsClient","length","processError","delete","fetchJobs","lastPayload","fetchLoop","jobs2","reason","progress","progressedjob","callbacks","cancelRightsType","userInfo","UserClient","required","cancelRight","resolvePermissionSet","InstancePermissionSet","engineRights","chatBotRights","configurationRights","dreamDaemonRights","dreamMakerRights","instancePermissionSetRights","repositoryRights","onError","deleteInfo","clearJob","noEmit","registerCallback","Set","add","promiseHooks","runHooks","hook","addHook","removeHook","jobsWidgetOptions","InstanceEditSidebar","githubtoken","apipath","publicPath","URL","href","DEFAULT_APIPATH","jobpollinactive","jobpollactive","jobswidgetdisplay","possibleValues","AUTO","instanceprobetimer","itemsperpage","instanceeditsidebar","showjson","MODE","manualpr","restjobs2"],"sourceRoot":""}