"use strict";(self.webpackChunktgstation_server_control_panel=self.webpackChunktgstation_server_control_panel||[]).push([[379],{1824:function(e,t,s){var n=s(4354),r=s(4173),o=s(5301),a=s(3728),i=s(8437);t.A=new class extends n.O{async listInstances({page:e=1,pageSize:t=i.Ay.itemsperpage.value}={}){let s;await a.A.wait4Init();try{s=await a.A.apiClient.api.instanceControllerList({pageSize:t,page:e})}catch(e){return new o.A({code:o.s.ERROR,error:e})}return 200===s.status?new o.A({code:o.s.OK,payload:s.data}):new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)})}async grantPermissions(e){let t;await a.A.wait4Init();try{t=await a.A.apiClient.api.instanceControllerGrantPermissions(e.id),this.emit("instanceChange",e.id)}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(t.status){case 204:return new o.A({code:o.s.OK,payload:{id:e.id}});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:t.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:t},t)})}}async editInstance(e){let t;await a.A.wait4Init();try{t=await a.A.apiClient.api.instanceControllerUpdate(e),this.emit("instanceChange",e.id)}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(t.status){case 200:case 202:return new o.A({code:o.s.OK,payload:t.data});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:t.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:t},t)})}}async detachInstance(e){let t;await a.A.wait4Init();try{t=await a.A.apiClient.api.instanceControllerDelete(e),this.emit("instanceChange",e)}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(t.status){case 204:return new o.A({code:o.s.OK,payload:null});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:t.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:t},t)})}}async createInstance(e){let t;await a.A.wait4Init();try{t=await a.A.apiClient.api.instanceControllerCreate(e)}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(t.status){case 200:case 201:{const e=t.data;return this.emit("instanceChange",e.id),new o.A({code:o.s.OK,payload:e})}case 409:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.HTTP_DATA_INEGRITY,{errorMessage:t.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:t},t)})}}async getInstance(e){let t;await a.A.wait4Init();try{t=await a.A.apiClient.api.instanceControllerGetId(e)}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(t.status){case 200:return new o.A({code:o.s.OK,payload:t.data});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:t.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:t},t)})}}}},2589:function(e,t,s){var n=s(4354),r=s(4173),o=s(5301),a=s(3728),i=s(8437);t.A=new class extends n.O{constructor(){super(),this._cachedInstancePermissionSet=new Map,this.loadingInstancePermissionSetInfo=new Map,a.A.on("purgeCache",(()=>{this._cachedInstancePermissionSet.clear()}))}async listInstancePermissionSets(e,{page:t=1,pageSize:s=i.Ay.itemsperpage.value}){let n;await a.A.wait4Init();try{n=await a.A.apiClient.api.instancePermissionSetControllerList({page:t,pageSize:s},{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}if(200===n.status){return new o.A({code:o.s.OK,payload:n.data})}return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:n},n)})}async getCurrentInstancePermissionSet(e,t){if(await a.A.wait4Init(),!t&&this._cachedInstancePermissionSet.has(e))return this._cachedInstancePermissionSet.get(e);if(this.loadingInstancePermissionSetInfo.get(e))return await new Promise((e=>{const t=s=>{e(s),this.removeListener("loadInstancePermissionSet",t)};this.on("loadInstancePermissionSet",t)}));let s;this.loadingInstancePermissionSetInfo.set(e,!0);try{s=await a.A.apiClient.api.instancePermissionSetControllerRead({headers:{Instance:e.toString()}})}catch(t){const s=new o.A({code:o.s.ERROR,error:t});return this.emit("loadInstancePermissionSet",s),this.loadingInstancePermissionSetInfo.set(e,!1),s}if(200===s.status){const t=new o.A({code:o.s.OK,payload:s.data});return this._cachedInstancePermissionSet.set(e,t),this.emit("loadInstancePermissionSet",t),this.loadingInstancePermissionSetInfo.set(e,!1),t}{const t=new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)});return this.emit("loadInstancePermissionSet",t),this.loadingInstancePermissionSetInfo.set(e,!1),t}}async getByPermissionSetId(e,t){let s;await a.A.wait4Init();try{s=await a.A.apiClient.api.instancePermissionSetControllerGetId(t,{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(s.status){case 200:return new o.A({code:o.s.OK,payload:s.data});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:s.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)})}}async createInstancePermissionSet(e,t){let s;await a.A.wait4Init();try{s=await a.A.apiClient.api.instancePermissionSetControllerCreate(t,{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(s.status){case 201:return new o.A({code:o.s.OK,payload:s.data});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:s.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)})}}async updateInstancePermissionSet(e,t){let s;await a.A.wait4Init();try{s=await a.A.apiClient.api.instancePermissionSetControllerUpdate(t,{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(s.status){case 200:return new o.A({code:o.s.OK,payload:s.data});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:s.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)})}}async deleteInstancePermissionSet(e,t){let s;await a.A.wait4Init();try{s=await a.A.apiClient.api.instancePermissionSetControllerDelete(t,{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(s.status){case 204:return new o.A({code:o.s.OK,payload:{permissionSetId:t}});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.NO_DB_ENTITY,{errorMessage:s.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)})}}}},4295:function(e,t,s){var n=s(4354),r=s(4173),o=s(5301),a=s(3728),i=s(8437);t.A=new class extends n.O{async listActiveJobs(e,{page:t=1,pageSize:s=i.Ay.itemsperpage.value}){let n;await a.A.wait4Init();try{n=await a.A.apiClient.api.jobControllerRead({page:t,pageSize:s},{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}if(200===n.status){const t=n.data.content.map((t=>({...t,instanceid:e})));return new o.A({code:o.s.OK,payload:{...n.data,content:t}})}return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:n},n)})}async getJob(e,t){let s;await a.A.wait4Init();try{s=await a.A.apiClient.api.jobControllerGetId(t,{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(s.status){case 200:{const t={...s.data,instanceid:e};return new o.A({code:o.s.OK,payload:t})}case 404:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.JOB_JOB_NOT_FOUND,{errorMessage:s.data})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)})}}async deleteJob(e,t){let s;await a.A.wait4Init();try{s=await a.A.apiClient.api.jobControllerDelete(t,{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}switch(s.status){case 202:{const t={...s.data,instanceid:e};return new o.A({code:o.s.OK,payload:t})}case 404:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.JOB_JOB_NOT_FOUND,{errorMessage:s.data})});case 410:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.JOB_JOB_COMPLETE,{void:!0})});default:return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:s},s)})}}async listJobs(e,{page:t=1,pageSize:s=i.Ay.itemsperpage.value}){let n;await a.A.wait4Init();try{n=await a.A.apiClient.api.jobControllerList({pageSize:s,page:t},{headers:{Instance:e.toString()}})}catch(e){return new o.A({code:o.s.ERROR,error:e})}if(200===n.status){const t=n.data.content.map((t=>({...t,instanceid:e})));return new o.A({code:o.s.OK,payload:{...n.data,content:t}})}return new o.A({code:o.s.ERROR,error:new r.Ay(r.O4.UNHANDLED_RESPONSE,{axiosResponse:n},n)})}}},379:function(e,t,s){s.r(t);var n=s(6997),r=s(2521),o=s(250),a=s(4492),i=s(9589),c=s(4101),l=s(4118),d=s(2576),h=s(1824),u=s(2589),p=s(4295),w=s(4173),A=s(5301),R=s(3728),g=s(1552),y=s(8437),O=s(536);t.default=new class extends c.TypedEmitter{set fastmode(e){(async()=>{await this.jobsHubSupported()||(console.log(`JobsController going in fastmode for ${e} cycles`),this.fastmodecount=e,await this.restartLoop())})()}async reset(e){console.log("JobsController resetting"),e&&(this.jobs=new Map,this.jobsByInstance=new Map);try{await this.reloadAccessibleInstances()}catch(e){return void this.errors.push(new w.Ay(w.O4.APP_FAIL,{jsError:Error(e)}))}await this.restartLoop()}constructor(){super(),this.fastmodecount=0,this.currentLoop=new Date(0),this.accessibleInstances=new Map,this.enableJobProgressWorkaround=void 0,this.errors=[],this.nextRetry=void 0,this.jobs=new Map,this.jobsByInstance=new Map,this.jobCallback=new Map,this.lastSeenJob=-1,this.connection=void 0,this.connection=null,this.nextRetry=null,this.loop=this.loop.bind(this),this.reset=this.reset.bind(this),this.cleanConnection=this.cleanConnection.bind(this),this.restartLoop=this.restartLoop.bind(this)}async stopAndRemoveConnection(){if(console.log("JobsController: stopAndRemoveConnection"),this.connection){console.log(`Stopping and removing active hub connection. State is: ${this.connection.state}`);const e=this.connection;this.connection=null,await e.stop()}}async cleanConnection(){await this.jobsHubSupported()&&(console.log("JobsController: cleanConnection"),await this.stopAndRemoveConnection(),this.errors=[],this.nextRetry=null,this.jobs=new Map,this.jobsByInstance=new Map,this.emit("jobsLoaded"))}init(){window.clients.JobsController=this,R.A.on("purgeCache",(()=>{this.reset(!0)})),R.A.on("logout",(()=>{this.cleanConnection()})),h.A.on("instanceChange",(()=>{this.reset(!1)})),O.A.addHook((async()=>{console.log("JobsController resetting due to login"),await this.reset(!0)})),R.A.on("loadServerInfo",(e=>{e.code===A.s.OK&&(this.enableJobProgressWorkaround=(0,i.satisfies)(e.payload.version,"<4.11.0"))}))}async reloadAccessibleInstances(e=!1){const t=[],s=await h.A.listInstances({pageSize:100});if(s.code===A.s.ERROR)return void this.errors.push(s.error);t.push(...s.payload.content);for(let e=2;e<=s.payload.totalPages;e++){const s=await h.A.listInstances({page:e,pageSize:100});if(s.code===A.s.ERROR)return void this.errors.push(s.error);t.push(...s.payload.content)}const n=new Map,r=t.filter((e=>e.online&&e.accessible)).map((e=>u.A.getCurrentInstancePermissionSet(e.id).then((t=>{t.code!==A.s.ERROR?n.set(e.id,e):t.error.code!==w.O4.HTTP_ACCESS_DENIED&&this.errors.push(t.error)}))));await Promise.all(r),this.accessibleInstances=n,e&&window.setTimeout((()=>{this.reloadAccessibleInstances(!0)}),y.Ay.instanceprobetimer.value)}async jobsHubSupported(){if(y.Ay.restjobs2.value)return!1;if(this.connection)return!0;const e=await R.A.getServerInfo();return e.code===A.s.OK?(0,i.gte)(e.payload.apiVersion,"9.13.0"):(console.warn("Failed to retrieve server info to determin jobs hub support!"),!1)}async restartLoop(){if(console.log("JobsController: restartLoop"),!await this.jobsHubSupported()){const e=new Date(Date.now());return this.currentLoop=e,void window.setTimeout((()=>{this.loop(e).catch((e=>this.errors.push(new w.Ay(w.O4.APP_FAIL,{jsError:Error(e)}))))}),0)}await this.stopAndRemoveConnection(),this.nextRetry=null;let e=y.Ay.apipath.value;e.endsWith("/")||(e+="/");const t=this.connection=(new n.$).withUrl(`${e}api/hubs/jobs`,{accessTokenFactory:async()=>(await R.A.wait4Token()).bearer,transport:r.w.ServerSentEvents,headers:R.A.defaultHeaders}).withAutomaticReconnect({nextRetryDelayInMilliseconds:e=>{if(0==e.previousRetryCount)return 0;const t=1e3*Math.min(2**e.previousRetryCount,30),s=new Date;return s.setMilliseconds(s.getMilliseconds()+t),this.nextRetry=s,this.emit("jobsLoaded"),t}}).configureLogging(o.$.Trace).build();t.on("ReceiveJobUpdate",(async e=>{console.log(`Received update for job ${e.id}`),this.registerJob(e,e.instanceId),this.emit("jobsLoaded");const t=await this.canCancel(e,this.errors);this.jobs.has(e.id)&&(this.jobs.get(e.id).canCancel=t,this.emit("jobsLoaded"))}));let s=!0,i=null;t.onreconnected((()=>{this.nextRetry=null,s=!0,this.emit("jobsLoaded"),console.log("Jobs hub connection re-established, running refresh...");const e=async()=>{clearTimeout(i),i=null,t.state===a.j.Connected&&(s=!1,this.errors=[],this.emit("jobsLoaded"),await this.reloadAccessibleInstances(!1),await this.loop(this.currentLoop=new Date))};i&&clearTimeout(i),i=setTimeout((()=>{e()}),3e3)})),t.onreconnecting((()=>{if(s){i&&(clearTimeout(i),i=null);(async()=>{(await R.A.login()).code!=A.s.OK?R.A.logout():s=!1})()}else this.errors=[],this.errors.push(new w.Ay(w.O4.BAD_HUB_CONNECTION,{void:!0})),this.emit("jobsLoaded")})),t.start().catch((e=>{this.connection==t&&(this.errors=[],e instanceof Error?this.errors.push(new w.Ay(w.O4.BAD_HUB_CONNECTION,{jsError:e})):this.errors.push(new w.Ay(w.O4.BAD_HUB_CONNECTION,{void:!0})),this.emit("jobsLoaded"),this.connection=null)}))}_registerJob(e,t){const s=e;if(this.jobs.has(s.id)&&this.jobs.get(s.id).stoppedAt)return void console.warn(`Receieved job update for ${s.id} after it completed! Incoming job was${s.stoppedAt?"":" not"} completed.`);t&&(s.instanceId=t);const n=this.jobsByInstance.get(s.instanceId)??new Map;this.jobsByInstance.set(s.instanceId,n),n.set(s.id,s),this.jobs.set(s.id,s)}registerJob(e,t){this._registerJob(e,t);(async()=>{await this.jobsHubSupported()||(console.log("Server does not support jobs hub, restarting loop due to job registration."),await this.restartLoop())})()}async loop(e){if(e!==this.currentLoop)return;this.errors=[];let t=0;const s=[];let n=this.lastSeenJob;for(const r of this.accessibleInstances.keys()){const o=async s=>{for(const e of s)this._registerJob(e),n=Math.max(n,e.id);const o=s.map((e=>e.id)),a=Array.from(this.jobs.values()).filter((e=>!e.stoppedAt)).filter((e=>e.instanceId===r)).map((e=>e.id)).filter((e=>!o.includes(e))),i=this.jobsByInstance.get(r)??new Map;this.jobsByInstance.set(r,i);const c=[];a.forEach((e=>{c.push(p.A.getJob(r,e).then((e=>{e.code!==A.s.ERROR?(i.set(e.payload.id,e.payload),this.jobs.set(e.payload.id,e.payload)):this.errors.push(e.error)})))})),await Promise.all(c),e===this.currentLoop&&(t+=s.length)},a=e=>{e.code===w.O4.HTTP_DATA_INEGRITY&&e.originalErrorMessage?.errorCode===d.vH.InstanceOffline?(console.log(`[JobsController] Clearing instance ${r} as it is now offline`),this.accessibleInstances.delete(r),this.reloadAccessibleInstances().catch((e=>{this.errors.push(new w.Ay(w.O4.APP_FAIL,{jsError:Error(e)}))}))):this.errors.push(e)},i=-1===this.lastSeenJob?p.A.listActiveJobs:p.A.listJobs;s.push(i(r,{page:1,pageSize:10}).then((async t=>{if(e===this.currentLoop)if(t.code===A.s.OK){let s=t.payload.content;e:for(let e=2;e<=t.payload.totalPages;e++){for(const e of s)if(e.id<=this.lastSeenJob)break e;const n=await i(r,{page:e,pageSize:10});if(n.code===A.s.ERROR)return void a(n.error);t.payload.content.push(...n.payload.content),s=t.payload.content}if(e!==this.currentLoop)return;await o(t.payload.content.filter((e=>e.id>this.lastSeenJob||this.jobs.has(e.id))))}else a(t.error)})).catch((e=>{console.error(e)})))}await Promise.all(s),this.lastSeenJob=n,s.length=0;for(const t of this.jobs.values())this.enableJobProgressWorkaround&&void 0===t.progress&&!t.stoppedAt&&this.accessibleInstances.has(t.instanceId)&&s.push(p.A.getJob(t.instanceId,t.id).then((s=>{e===this.currentLoop&&(s.code===A.s.OK?t.progress=s.payload.progress:s.error.code===w.O4.HTTP_DATA_INEGRITY&&s.error.originalErrorMessage?.errorCode===d.vH.InstanceOffline?(console.log(`[JobsController] Clearing instance ${t.instanceId} as it is now offline`),this.accessibleInstances.delete(t.instanceId),this.reloadAccessibleInstances().catch((e=>{this.errors.push(new w.Ay(w.O4.APP_FAIL,{jsError:Error(e)}))}))):this.errors.push(s.error))}))),s.push(this.canCancel(t,this.errors).then((s=>{e===this.currentLoop&&(t.canCancel=s)})));if(await Promise.all(s),e===this.currentLoop){this.emit("jobsLoaded");for(const e of this.jobs.values()){if(!e.stoppedAt)continue;const t=this.jobCallback.get(e.id);if(t){for(const s of t)s(e);this.jobCallback.delete(e.id)}}this.fastmodecount&&e===this.currentLoop?(window.setTimeout((()=>{this.loop(e).catch((e=>this.errors.push(new w.Ay(w.O4.APP_FAIL,{jsError:Error(e)}))))}),800),this.fastmodecount--,console.log(`JobsController will remain in fastmode for ${this.fastmodecount} cycles`)):window.setTimeout((()=>{this.loop(e).catch((e=>this.errors.push(new w.Ay(w.O4.APP_FAIL,{jsError:Error(e)}))))}),1e3*(t?y.Ay.jobpollactive.value:y.Ay.jobpollinactive.value))}}async canCancel(e,t){if(void 0!==e.canCancel)return e.canCancel;if(void 0===e.cancelRightsType)return!0;switch(e.cancelRightsType){case d.CF.Administration:{const s=await g.A.getCurrentUser();if(s.code===A.s.OK){const t=e.cancelRight;return!!((0,l.u)(s.payload).administrationRights&t)}return t.push(s.error),!1}case d.CF.InstanceManager:{const s=await g.A.getCurrentUser();if(s.code===A.s.OK){const t=e.cancelRight;return!!((0,l.u)(s.payload).instanceManagerRights&t)}return t.push(s.error),!1}case d.CF.Engine:{const s=await u.A.getCurrentInstancePermissionSet(e.instanceId);if(s.code===A.s.OK){const t=e.cancelRight;return!!(s.payload.engineRights&t)}return t.push(s.error),!1}case d.CF.ChatBots:{const s=await u.A.getCurrentInstancePermissionSet(e.instanceId);if(s.code===A.s.OK){const t=e.cancelRight;return!!(s.payload.chatBotRights&t)}return t.push(s.error),!1}case d.CF.Configuration:{const s=await u.A.getCurrentInstancePermissionSet(e.instanceId);if(s.code===A.s.OK){const t=e.cancelRight;return!!(s.payload.configurationRights&t)}return t.push(s.error),!1}case d.CF.DreamDaemon:{const s=await u.A.getCurrentInstancePermissionSet(e.instanceId);if(s.code===A.s.OK){const t=e.cancelRight;return!!(s.payload.dreamDaemonRights&t)}return t.push(s.error),!1}case d.CF.DreamMaker:{const s=await u.A.getCurrentInstancePermissionSet(e.instanceId);if(s.code===A.s.OK){const t=e.cancelRight;return!!(s.payload.dreamMakerRights&t)}return t.push(s.error),!1}case d.CF.InstancePermissionSet:{const s=await u.A.getCurrentInstancePermissionSet(e.instanceId);if(s.code===A.s.OK){const t=e.cancelRight;return!!(s.payload.instancePermissionSetRights&t)}return t.push(s.error),!1}case d.CF.Repository:{const s=await u.A.getCurrentInstancePermissionSet(e.instanceId);if(s.code===A.s.OK){const t=e.cancelRight;return!!(s.payload.repositoryRights&t)}return t.push(s.error),!1}}}async cancelJob(e,t){const s=this.jobs.get(e);if(!s)return!1;const n=await p.A.deleteJob(s.instanceId,e);return n.code===A.s.OK||(t(n.error),!1)}clearJob(e,t=!1){const s=this.jobs.get(e);return!!s&&(this.jobsByInstance.get(s.instanceId)?.delete(e),this.jobs.delete(e),t||this.emit("jobsLoaded"),!0)}registerCallback(e,t){const s=this.jobCallback.get(e)??new Set;s.add(t),this.jobCallback.set(e,s)}}}}]);
//# sourceMappingURL=379.c3e224183df605ae225f.bundle.js.map