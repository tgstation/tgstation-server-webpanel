{"version":3,"sources":["webpack:///./src/ApiClient/TransferClient.ts","webpack:///./src/ApiClient/AdminClient.ts"],"names":["ticket","response","ServerClient","wait4Init","apiClient","TransferController_Download","headers","Accept","stat","InternalStatus","code","StatusCode","ERROR","error","status","OK","payload","data","InternalError","ErrorCode","TRANSFER_NOT_AVAILABLE","errorMessage","UNHANDLED_RESPONSE","axiosResponse","_cachedAdminInfo","loadingAdminInfo","on","undefined","this","Promise","resolve","resolver","user","removeListener","AdministrationController_Read","res","emit","thing","ADMIN_GITHUB_RATE","ADMIN_GITHUB_ERROR","AdministrationController_Delete","ADMIN_WATCHDOG_UNAVAIL","newVersion","AdministrationController_Update","latestVersion","trackedRepositoryUrl","ADMIN_VERSION_NOT_FOUND","AdministrationController_ListLogs","pageSize","page","content","ADMIN_LOGS_IO_ERROR","logName","AdministrationController_GetLog","path","contents","TransferClient","Download","fileTicket","temp","Object","assign","TypedEmitter"],"mappings":"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","file":"1.85f25e4d0f3a70c86478.js","sourcesContent":["import { Components } from \"./generatedcode/_generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\n\nexport type DownloadErrors = GenericErrors | ErrorCode.TRANSFER_NOT_AVAILABLE;\n\nexport default new (class TransferClient {\n    public async Download(ticket: string): Promise<InternalStatus<string, DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.TransferController_Download(\n                {\n                    ticket: ticket\n                },\n                null,\n                {\n                    headers: {\n                        Accept: \"application/json, application/octet-stream\"\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: (response.data as unknown) as string\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.TRANSFER_NOT_AVAILABLE, {\n                        errorMessage: response.data as Components.Schemas.ErrorMessage\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { TypedEmitter } from \"tiny-typed-emitter/lib\";\n\nimport { Components } from \"./generatedcode/_generated\";\nimport { DownloadedLog } from \"./models/DownloadedLog\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport TransferClient, { DownloadErrors } from \"./TransferClient\";\n\ninterface IEvents {\n    loadAdminInfo: (\n        user: InternalStatus<Components.Schemas.Administration, AdminInfoErrors>\n    ) => void;\n}\n\nexport type AdminInfoErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR;\n\nexport type RestartErrors = GenericErrors | ErrorCode.ADMIN_WATCHDOG_UNAVAIL;\n\nexport type UpdateErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_WATCHDOG_UNAVAIL\n    | ErrorCode.ADMIN_VERSION_NOT_FOUND\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR;\n\nexport type LogsErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport type LogErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport default new (class AdminClient extends TypedEmitter<IEvents> {\n    private _cachedAdminInfo?: InternalStatus<Components.Schemas.Administration, ErrorCode.OK>;\n    public get cachedAdminInfo() {\n        return this._cachedAdminInfo;\n    }\n    private loadingAdminInfo = false;\n\n    public constructor() {\n        super();\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedAdminInfo = undefined;\n        });\n    }\n\n    public async getAdminInfo(): Promise<\n        InternalStatus<Components.Schemas.Administration, AdminInfoErrors>\n    > {\n        await ServerClient.wait4Init();\n        if (this._cachedAdminInfo) {\n            return this._cachedAdminInfo;\n        }\n\n        if (this.loadingAdminInfo) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<Components.Schemas.Administration, AdminInfoErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadAdminInfo\", resolver);\n                };\n                this.on(\"loadAdminInfo\", resolver);\n            });\n        }\n\n        this.loadingAdminInfo = true;\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Read();\n        } catch (stat) {\n            const res = new InternalStatus<Components.Schemas.Administration, AdminInfoErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<AdminInfoErrors>\n            });\n            this.emit(\"loadAdminInfo\", res);\n            this.loadingAdminInfo = false;\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const thing = new InternalStatus<Components.Schemas.Administration, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.Administration\n                });\n\n                this._cachedAdminInfo = thing;\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 424: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                const thing = new InternalStatus<\n                    Components.Schemas.Administration,\n                    ErrorCode.ADMIN_GITHUB_RATE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 429: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                const thing = new InternalStatus<\n                    Components.Schemas.Administration,\n                    ErrorCode.ADMIN_GITHUB_ERROR\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            default: {\n                const res = new InternalStatus<\n                    Components.Schemas.Administration,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", res);\n                this.loadingAdminInfo = false;\n                return res;\n            }\n        }\n    }\n\n    public async restartServer(): Promise<InternalStatus<null, RestartErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Delete();\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<RestartErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({ code: StatusCode.OK, payload: null });\n            }\n            case 422: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<null, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async updateServer(newVersion: string): Promise<InternalStatus<null, UpdateErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Update(null, {\n                newVersion,\n                latestVersion: null,\n                trackedRepositoryUrl: null\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<UpdateErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                return new InternalStatus({ code: StatusCode.OK, payload: null });\n            }\n            case 410: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_VERSION_NOT_FOUND,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 422: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 424: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                return new InternalStatus<null, ErrorCode.ADMIN_GITHUB_RATE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 429: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                return new InternalStatus<null, ErrorCode.ADMIN_GITHUB_ERROR>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<null, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLogs(): Promise<InternalStatus<Components.Schemas.LogFile[], LogsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_ListLogs({\n                pageSize: 100,\n                page: 1\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<LogsErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: (response.data as Components.Schemas.PaginatedLogFile)!.content\n                });\n            }\n            case 409: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLog(\n        logName: string\n    ): Promise<InternalStatus<DownloadedLog, LogErrors | DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_GetLog({\n                path: logName\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                const contents = await TransferClient.Download(\n                    (response.data as Components.Schemas.LogFile).fileTicket!\n                );\n                if (contents.code === StatusCode.OK) {\n                    //Object.assign() is a funky function but all it does is copy everything from the second object to the first object\n                    const temp: DownloadedLog = Object.assign(\n                        { content: contents.payload },\n                        response.data as Components.Schemas.LogFile\n                    );\n                    return new InternalStatus({\n                        code: StatusCode.OK,\n                        payload: temp\n                    });\n                } else {\n                    return new InternalStatus({\n                        code: StatusCode.ERROR,\n                        error: contents.error\n                    });\n                }\n            }\n            case 409: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessage;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n"],"sourceRoot":""}