{"version":3,"file":"9521.af5da2309d25f8f0908b.bundle.js","mappings":"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","sources":["webpack://tgstation-server-control-panel/./src/ApiClient/InstanceClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/InstancePermissionSetClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/JobsClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/JobsController.ts"],"sourcesContent":["import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    InstanceCreateRequest,\n    InstanceResponse,\n    InstanceUpdateRequest,\n    PaginatedInstanceResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type ListInstancesErrors = GenericErrors;\nexport type CreateInstanceErrors = GenericErrors;\nexport type EditInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type GetInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type GrantPermissionsErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type DetachInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\n\ninterface IEvents {\n    instanceChange: (instanceId: number) => void;\n}\n\nexport default new (class InstanceClient extends ApiClient<IEvents> {\n    public async listInstances({\n        page = 1,\n        pageSize = configOptions.itemsperpage.value as number\n    } = {}): Promise<InternalStatus<PaginatedInstanceResponse, ListInstancesErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerList({\n                pageSize: pageSize,\n                page: page\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedInstanceResponse\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async grantPermissions(\n        instance: InstanceUpdateRequest\n    ): Promise<InternalStatus<InstanceResponse, GrantPermissionsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerGrantPermissions(\n                instance.id\n            );\n            this.emit(\"instanceChange\", instance.id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: { id: instance.id } as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async editInstance(\n        instance: InstanceUpdateRequest\n    ): Promise<InternalStatus<InstanceResponse, EditInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerUpdate(instance);\n            this.emit(\"instanceChange\", instance.id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 202: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async detachInstance(id: number): Promise<InternalStatus<null, DetachInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerDelete(id);\n            this.emit(\"instanceChange\", id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: null\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async createInstance(\n        instance: InstanceCreateRequest\n    ): Promise<InternalStatus<InstanceResponse, CreateInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerCreate(instance);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 201: {\n                const instance = response.data as InstanceResponse;\n\n                this.emit(\"instanceChange\", instance.id);\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: instance\n                });\n            }\n            case 409:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.HTTP_DATA_INEGRITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getInstance(\n        instanceid: number\n    ): Promise<InternalStatus<InstanceResponse, GetInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerGetId(instanceid);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    InstancePermissionSetRequest,\n    InstancePermissionSetResponse,\n    PaginatedInstancePermissionSetResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\ninterface IEvents {\n    loadInstancePermissionSet: (\n        user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n    ) => void;\n}\n\nexport type getCurrentInstancePermissionSetErrors = GenericErrors;\nexport type getByPermissionSetIdErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type createInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type updateInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type deleteInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type listInstancePermissionSetErrors = GenericErrors;\n\nexport default new (class InstancePermissionSetClient extends ApiClient<IEvents> {\n    private _cachedInstancePermissionSet: Map<\n        number,\n        InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>\n    > = new Map<number, InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>>();\n\n    private loadingInstancePermissionSetInfo: Map<number, boolean> = new Map<number, boolean>();\n\n    public constructor() {\n        super();\n\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedInstancePermissionSet.clear();\n        });\n    }\n\n    public async listInstancePermissionSets(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<\n        InternalStatus<PaginatedInstancePermissionSetResponse, listInstancePermissionSetErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerList(\n                {\n                    page: page,\n                    pageSize: pageSize\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<\n                    PaginatedInstancePermissionSetResponse,\n                    ErrorCode.OK\n                >({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedInstancePermissionSetResponse\n                });\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<\n                    PaginatedInstancePermissionSetResponse,\n                    GenericErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async getCurrentInstancePermissionSet(\n        instanceid: number,\n        noCache?: boolean\n    ): Promise<\n        InternalStatus<InstancePermissionSetResponse, getCurrentInstancePermissionSetErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        if (!noCache && this._cachedInstancePermissionSet.has(instanceid)) {\n            return this._cachedInstancePermissionSet.get(instanceid)!;\n        }\n\n        if (this.loadingInstancePermissionSetInfo.get(instanceid)) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadInstancePermissionSet\", resolver);\n                };\n                this.on(\"loadInstancePermissionSet\", resolver);\n            });\n        }\n\n        this.loadingInstancePermissionSetInfo.set(instanceid, true);\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerRead({\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadInstancePermissionSet\", res);\n            this.loadingInstancePermissionSetInfo.set(instanceid, false);\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n\n                this._cachedInstancePermissionSet.set(instanceid, res);\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n        }\n    }\n\n    public async getByPermissionSetId(\n        instanceid: number,\n        permissionSetId: number\n    ): Promise<InternalStatus<InstancePermissionSetResponse, getByPermissionSetIdErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerGetId(\n                permissionSetId,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                getByPermissionSetIdErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<getByPermissionSetIdErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    getByPermissionSetIdErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async createInstancePermissionSet(\n        instanceid: number,\n        instancePermissionSet: InstancePermissionSetRequest\n    ): Promise<InternalStatus<InstancePermissionSetResponse, createInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerCreate(\n                instancePermissionSet,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                createInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<createInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 201: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    createInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async updateInstancePermissionSet(\n        instanceid: number,\n        instancePermissionSet: InstancePermissionSetRequest\n    ): Promise<InternalStatus<InstancePermissionSetResponse, updateInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerUpdate(\n                instancePermissionSet,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                updateInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<updateInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    updateInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async deleteInstancePermissionSet(\n        instanceid: number,\n        permissionSetId: number\n    ): Promise<InternalStatus<InstancePermissionSetResponse, deleteInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerDelete(\n                permissionSetId,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                deleteInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<deleteInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: { permissionSetId } as InstancePermissionSetResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    deleteInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    JobResponse,\n    PaginatedJobResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type listJobsErrors = GenericErrors;\nexport type getJobErrors = GenericErrors | ErrorCode.JOB_JOB_NOT_FOUND;\nexport type deleteJobErrors =\n    | GenericErrors\n    | ErrorCode.JOB_JOB_NOT_FOUND\n    | ErrorCode.JOB_JOB_COMPLETE;\n\nexport type PaginatedTGSJobResponse = Omit<PaginatedJobResponse, \"content\"> & {\n    content: TGSJobResponse[];\n};\nexport type TGSJobResponse = JobResponse & {\n    canCancel?: boolean;\n};\n\nexport default new (class JobsClient extends ApiClient {\n    public async listActiveJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, listJobsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerRead(\n                {\n                    page: page,\n                    pageSize: pageSize\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, getJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerGetId(jobid, {\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async deleteJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, deleteJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerDelete(jobid, {\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_COMPLETE, {\n                        void: true\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async listJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, GenericErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerList(\n                {\n                    pageSize,\n                    page\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import * as signalR from \"@microsoft/signalr\";\nimport { gte as SemVerGte, satisfies as SemverSatisfies } from \"semver\";\nimport { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { resolvePermissionSet } from \"../../utils/misc\";\nimport {\n    AdministrationRights,\n    ChatBotRights,\n    ConfigurationRights,\n    DreamDaemonRights,\n    DreamMakerRights,\n    EngineRights,\n    ErrorCode as TGSErrorCode,\n    InstanceManagerRights,\n    InstancePermissionSetRights,\n    InstanceResponse,\n    JobResponse,\n    RepositoryRights,\n    RightsType\n} from \"../generatedcode/generated\";\nimport InstanceClient from \"../InstanceClient\";\nimport InstancePermissionSetClient from \"../InstancePermissionSetClient\";\nimport JobsClient, { TGSJobResponse } from \"../JobsClient\";\nimport InternalError, { ErrorCode } from \"../models/InternalComms/InternalError\";\nimport { StatusCode } from \"../models/InternalComms/InternalStatus\";\nimport ServerClient from \"../ServerClient\";\nimport UserClient from \"../UserClient\";\nimport configOptions from \"./config\";\nimport LoginHooks from \"./LoginHooks\";\n\ninterface IEvents {\n    jobsLoaded: () => unknown;\n}\n\nexport default new (class JobsController extends TypedEmitter<IEvents> {\n    private fastmodecount = 0;\n    public set fastmode(cycles: number) {\n        const doStuff = async () => {\n            if (await this.jobsHubSupported()) {\n                return;\n            }\n\n            console.log(`JobsController going in fastmode for ${cycles} cycles`);\n            this.fastmodecount = cycles;\n            await this.restartLoop();\n        };\n        void doStuff();\n    }\n\n    private currentLoop: Date = new Date(0);\n    public accessibleInstances = new Map<number, InstanceResponse>();\n\n    private enableJobProgressWorkaround?: boolean;\n\n    public errors: InternalError[] = [];\n    public nextRetry: Date | null;\n    public jobs = new Map<number, TGSJobResponse>();\n    public jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n    private jobCallback = new Map<number, Set<(job: TGSJobResponse) => unknown>>();\n    private lastSeenJob = -1;\n\n    private connection: signalR.HubConnection | null;\n\n    public async reset(clearJobs: boolean): Promise<void> {\n        console.log(\"JobsController resetting\");\n        if (clearJobs) {\n            this.jobs = new Map<number, TGSJobResponse>();\n            this.jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n        }\n\n        try {\n            await this.reloadAccessibleInstances();\n        } catch (e) {\n            this.errors.push(\n                new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e as string) })\n            );\n            return;\n        }\n\n        await this.restartLoop();\n    }\n\n    public constructor() {\n        super();\n\n        this.connection = null;\n        this.nextRetry = null;\n        this.loop = this.loop.bind(this);\n        this.reset = this.reset.bind(this);\n        this.cleanConnection = this.cleanConnection.bind(this);\n        this.restartLoop = this.restartLoop.bind(this);\n    }\n\n    private async stopAndRemoveConnection(): Promise<void> {\n        console.log(\"JobsController: stopAndRemoveConnection\");\n\n        if (this.connection) {\n            console.log(\n                `Stopping and removing active hub connection. State is: ${this.connection.state}`\n            );\n            const connectionToStop = this.connection;\n            this.connection = null;\n            await connectionToStop.stop();\n        }\n    }\n\n    private async cleanConnection(): Promise<void> {\n        if (!(await this.jobsHubSupported())) {\n            return;\n        }\n\n        console.log(\"JobsController: cleanConnection\");\n\n        await this.stopAndRemoveConnection();\n\n        this.errors = [];\n        this.nextRetry = null;\n        this.jobs = new Map<number, TGSJobResponse>();\n        this.jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n        this.emit(\"jobsLoaded\");\n    }\n\n    public init() {\n        window.clients[\"JobsController\"] = this;\n\n        //technically not a \"cache\" but we might as well reload it\n        ServerClient.on(\"purgeCache\", () => void this.reset(true));\n        ServerClient.on(\"logout\", () => void this.cleanConnection());\n\n        InstanceClient.on(\"instanceChange\", () => void this.reset(false));\n        // eslint-disable-next-line @typescript-eslint/require-await\n        LoginHooks.addHook(async () => {\n            console.log(\"JobsController resetting due to login\");\n            await this.reset(true);\n        });\n\n        ServerClient.on(\"loadServerInfo\", response => {\n            if (response.code === StatusCode.OK) {\n                //A bug in versions below 4.11.0 makes it so that /Job/List doesn't report back progress. If we are running on a higher version, theres no point in enabling the workaround\n                this.enableJobProgressWorkaround = SemverSatisfies(\n                    response.payload.version,\n                    \"<4.11.0\"\n                );\n            }\n        });\n    }\n\n    private async reloadAccessibleInstances(loop = false): Promise<void> {\n        const allInstances: InstanceResponse[] = [];\n\n        const instances1 = await InstanceClient.listInstances({ pageSize: 100 });\n        if (instances1.code === StatusCode.ERROR) {\n            this.errors.push(instances1.error);\n            return;\n        } else {\n            allInstances.push(...instances1.payload.content);\n        }\n        for (let i = 2; i <= instances1.payload.totalPages; i++) {\n            const instances2 = await InstanceClient.listInstances({ page: i, pageSize: 100 });\n            if (instances2.code === StatusCode.ERROR) {\n                this.errors.push(instances2.error);\n                return;\n            } else {\n                allInstances.push(...instances2.payload.content);\n            }\n        }\n\n        const updatedSet = new Map<number, InstanceResponse>();\n\n        const work = allInstances\n            .filter(instance => instance.online && instance.accessible)\n            .map(instance => {\n                return InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    instance.id\n                ).then(permissionSet => {\n                    if (permissionSet.code === StatusCode.ERROR) {\n                        //If its access denied, it means we have view all instances but we dont have access to the instance itself\n                        if (permissionSet.error.code !== ErrorCode.HTTP_ACCESS_DENIED) {\n                            this.errors.push(permissionSet.error);\n                        }\n                        return;\n                    }\n                    updatedSet.set(instance.id, instance);\n                });\n            });\n\n        await Promise.all(work);\n\n        this.accessibleInstances = updatedSet;\n\n        if (loop) {\n            window.setTimeout(\n                () => void this.reloadAccessibleInstances(true),\n                configOptions.instanceprobetimer.value as number\n            );\n        }\n    }\n\n    private async jobsHubSupported(): Promise<boolean> {\n        if (configOptions.restjobs2.value as boolean) {\n            return false;\n        }\n\n        if (this.connection) {\n            return true;\n        }\n\n        const serverInfo = await ServerClient.getServerInfo();\n        if (serverInfo.code === StatusCode.OK) {\n            return SemVerGte(serverInfo.payload.apiVersion, \"9.13.0\");\n        }\n\n        console.warn(\"Failed to retrieve server info to determin jobs hub support!\");\n\n        return false;\n    }\n\n    public async restartLoop(): Promise<void> {\n        console.log(\"JobsController: restartLoop\");\n        if (!(await this.jobsHubSupported())) {\n            //we use an actual date object here because it could help prevent really weird timing\n            // issues as two different date objects cannot be equal\n            // despite the date being\n            const initDate = new Date(Date.now());\n            this.currentLoop = initDate;\n            window.setTimeout(() => {\n                this.loop(initDate).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, 0);\n\n            return;\n        }\n\n        await this.stopAndRemoveConnection();\n\n        this.nextRetry = null;\n\n        let apiPath = configOptions.apipath.value as string;\n        if (!apiPath.endsWith(\"/\")) {\n            apiPath = apiPath + \"/\";\n        }\n\n        const localConnection = (this.connection = new signalR.HubConnectionBuilder()\n            .withUrl(`${apiPath}api/hubs/jobs`, {\n                accessTokenFactory: async () => {\n                    const token = await ServerClient.wait4Token();\n                    return token.bearer;\n                },\n                transport: signalR.HttpTransportType.ServerSentEvents,\n                headers: ServerClient.defaultHeaders\n            })\n            .withAutomaticReconnect({\n                nextRetryDelayInMilliseconds: (retryContext: signalR.RetryContext) => {\n                    if (retryContext.previousRetryCount == 0) {\n                        return 0;\n                    }\n\n                    const nextRetryMs = Math.min(2 ** retryContext.previousRetryCount, 30) * 1000;\n                    const retryDate = new Date();\n                    retryDate.setMilliseconds(retryDate.getMilliseconds() + nextRetryMs);\n                    this.nextRetry = retryDate;\n                    this.emit(\"jobsLoaded\");\n                    return nextRetryMs;\n                }\n            })\n            .configureLogging(signalR.LogLevel.Trace)\n            .build());\n\n        localConnection.on(\"ReceiveJobUpdate\", async (job: JobResponse) => {\n            console.log(`Received update for job ${job.id}`);\n            this.registerJob(job, job.instanceId);\n            this.emit(\"jobsLoaded\");\n            const canCancel = await this.canCancel(job, this.errors);\n            if (this.jobs.has(job.id)) {\n                this.jobs.get(job.id)!.canCancel = canCancel;\n                this.emit(\"jobsLoaded\");\n            }\n        });\n\n        let justReconnected = true;\n        let reconnectionTimeout: NodeJS.Timeout | null = null;\n        localConnection.onreconnected(() => {\n            this.nextRetry = null;\n            justReconnected = true;\n            this.emit(\"jobsLoaded\");\n            console.log(\"Jobs hub connection re-established, running refresh...\");\n\n            // at this point we need to manually load all the jobs we have registered in case they've completed in the hub and are no longer receiving updates\n            const forcedRefresh = async () => {\n                clearTimeout(reconnectionTimeout!);\n                reconnectionTimeout = null;\n                if (localConnection.state !== signalR.HubConnectionState.Connected) {\n                    return;\n                }\n\n                justReconnected = false;\n\n                this.errors = [];\n                this.emit(\"jobsLoaded\");\n                await this.reloadAccessibleInstances(false);\n                await this.loop((this.currentLoop = new Date()));\n            };\n\n            if (reconnectionTimeout) {\n                clearTimeout(reconnectionTimeout);\n            }\n\n            reconnectionTimeout = setTimeout(() => void forcedRefresh(), 3000);\n        });\n\n        localConnection.onreconnecting(() => {\n            if (justReconnected) {\n                if (reconnectionTimeout) {\n                    clearTimeout(reconnectionTimeout);\n                    reconnectionTimeout = null;\n                }\n\n                const relog = async () => {\n                    // we reconnected and then got disconnected? That's an auth issue\n                    const result = await ServerClient.login();\n                    if (result.code != StatusCode.OK) {\n                        ServerClient.logout();\n                    } else {\n                        justReconnected = false;\n                    }\n                };\n\n                void relog();\n                return;\n            }\n\n            this.errors = [];\n            this.errors.push(new InternalError(ErrorCode.BAD_HUB_CONNECTION, { void: true }));\n            this.emit(\"jobsLoaded\");\n        });\n\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        localConnection.start().catch(error => {\n            if (this.connection != localConnection) {\n                return;\n            }\n\n            this.errors = [];\n            if (error instanceof Error) {\n                this.errors.push(\n                    new InternalError(ErrorCode.BAD_HUB_CONNECTION, { jsError: error })\n                );\n            } else {\n                this.errors.push(new InternalError(ErrorCode.BAD_HUB_CONNECTION, { void: true }));\n            }\n            this.emit(\"jobsLoaded\");\n            this.connection = null;\n        });\n    }\n\n    private _registerJob(job: TGSJobResponse, instanceid?: number): void;\n    // noinspection JSUnusedLocalSymbols\n    private _registerJob(job: JobResponse, instanceid: number): void;\n    private _registerJob(_job: JobResponse | TGSJobResponse, instanceid?: number) {\n        const job = _job as TGSJobResponse;\n        if (this.jobs.has(job.id) && this.jobs.get(job.id)!.stoppedAt) {\n            console.warn(\n                `Receieved job update for ${job.id} after it completed! Incoming job was${\n                    job.stoppedAt ? \"\" : \" not\"\n                } completed.`\n            );\n            return;\n        }\n\n        if (instanceid) job.instanceId = instanceid;\n        const instanceSet = this.jobsByInstance.get(job.instanceId) ?? new Map();\n        this.jobsByInstance.set(job.instanceId, instanceSet);\n        instanceSet.set(job.id, job);\n        this.jobs.set(job.id, job);\n    }\n\n    public registerJob(job: TGSJobResponse, instanceid?: number): void;\n    public registerJob(job: JobResponse, instanceid: number): void;\n    public registerJob(_job: JobResponse | TGSJobResponse, instanceid?: number) {\n        this._registerJob(_job, instanceid);\n\n        const doStuff = async () => {\n            if (!(await this.jobsHubSupported())) {\n                console.log(\n                    \"Server does not support jobs hub, restarting loop due to job registration.\"\n                );\n                await this.restartLoop();\n            }\n        };\n\n        void doStuff();\n    }\n\n    private async loop(loopid: Date) {\n        //so loops get initialiazed with the current time, it keeps track of which loop to run with\n        // that initialization date in currentLoop if the currentLoop isnt equal to the one provided\n        // to the loop, it means that the loop was\n        // replaced so we dont try to call for another one\n        if (loopid !== this.currentLoop) {\n            return;\n        }\n\n        //time to clear out errors\n        this.errors = [];\n\n        let totalActiveJobs = 0;\n        const work: Promise<void>[] = [];\n\n        //We can't update the value immediatly or instances will conflict with each other and prevent some jobs from fetching\n        let tempLastSeenJob = this.lastSeenJob;\n        for (const instanceid of this.accessibleInstances.keys()) {\n            const processJobs = async (jobs: TGSJobResponse[]) => {\n                for (const job of jobs) {\n                    this._registerJob(job);\n                    tempLastSeenJob = Math.max(tempLastSeenJob, job.id);\n                }\n\n                const remoteActive = jobs.map(job => job.id);\n                const localActive = Array.from(this.jobs.values())\n                    .filter(job => !job.stoppedAt)\n                    .filter(job => job.instanceId === instanceid)\n                    .map(job => job.id);\n                const manualIds = localActive.filter(jobId => !remoteActive.includes(jobId));\n\n                const instanceSet = this.jobsByInstance.get(instanceid) ?? new Map();\n                this.jobsByInstance.set(instanceid, instanceSet);\n                const work: Promise<void>[] = [];\n                manualIds.forEach(jobId => {\n                    work.push(\n                        JobsClient.getJob(instanceid, jobId).then(job => {\n                            if (job.code === StatusCode.ERROR) {\n                                this.errors.push(job.error);\n                                return;\n                            }\n                            instanceSet.set(job.payload.id, job.payload);\n                            this.jobs.set(job.payload.id, job.payload);\n                        })\n                    );\n                });\n                await Promise.all(work);\n\n                if (loopid !== this.currentLoop) return;\n\n                totalActiveJobs += jobs.length;\n            };\n\n            const processError = (error: InternalError) => {\n                if (\n                    error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                    error.originalErrorMessage?.errorCode === TGSErrorCode.InstanceOffline\n                ) {\n                    console.log(\n                        `[JobsController] Clearing instance ${instanceid} as it is now offline`\n                    );\n                    this.accessibleInstances.delete(instanceid);\n                    //Probably a good idea to reload the list at this point\n                    this.reloadAccessibleInstances().catch(e => {\n                        this.errors.push(\n                            new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) })\n                        );\n                    });\n                } else {\n                    this.errors.push(error);\n                }\n            };\n\n            const fetchJobs =\n                this.lastSeenJob === -1 ? JobsClient.listActiveJobs : JobsClient.listJobs;\n            //now since this is async, it still possible that a single fire gets done after the new loop started, theres no really much that can be done about it\n            work.push(\n                fetchJobs(instanceid, { page: 1, pageSize: 10 })\n                    .then(async value => {\n                        //this check is here because the request itself is async and could return after\n                        // the loop is terminated, we dont want to contaminate the jobs of an instance\n                        // with the jobs of another even if it is for a single fire and would eventually\n                        // get fixed on its own after a few seconds\n                        if (loopid !== this.currentLoop) return;\n\n                        if (value.code === StatusCode.OK) {\n                            let lastPayload = value.payload.content;\n                            fetchLoop: for (let i = 2; i <= value.payload.totalPages; i++) {\n                                for (const job of lastPayload) {\n                                    //We reached the last page of usable content, break the loop\n                                    if (job.id <= this.lastSeenJob) {\n                                        break fetchLoop;\n                                    }\n                                }\n                                const jobs2 = await fetchJobs(instanceid, {\n                                    page: i,\n                                    pageSize: 10\n                                });\n                                if (jobs2.code === StatusCode.ERROR) {\n                                    processError(jobs2.error);\n                                    return;\n                                } else {\n                                    value.payload.content.push(...jobs2.payload.content);\n                                    lastPayload = value.payload.content;\n                                }\n                            }\n                            if (loopid !== this.currentLoop) return;\n                            await processJobs(\n                                value.payload.content.filter(\n                                    job => job.id > this.lastSeenJob || this.jobs.has(job.id)\n                                )\n                            );\n                        } else {\n                            processError(value.error);\n                        }\n                    })\n                    .catch(reason => {\n                        console.error(reason);\n                    })\n            );\n        }\n\n        await Promise.all(work);\n\n        this.lastSeenJob = tempLastSeenJob;\n\n        work.length = 0;\n        for (const job of this.jobs.values()) {\n            if (\n                this.enableJobProgressWorkaround &&\n                job.progress === undefined &&\n                !job.stoppedAt &&\n                this.accessibleInstances.has(job.instanceId)\n            ) {\n                work.push(\n                    JobsClient.getJob(job.instanceId, job.id).then(progressedjob => {\n                        if (loopid !== this.currentLoop) return;\n                        if (progressedjob.code === StatusCode.OK) {\n                            job.progress = progressedjob.payload.progress;\n                        } else {\n                            if (\n                                progressedjob.error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                                progressedjob.error.originalErrorMessage?.errorCode ===\n                                    TGSErrorCode.InstanceOffline\n                            ) {\n                                console.log(\n                                    `[JobsController] Clearing instance ${job.instanceId} as it is now offline`\n                                );\n                                this.accessibleInstances.delete(job.instanceId);\n                                //Probably a good idea to reload the list at this point\n                                this.reloadAccessibleInstances().catch(e => {\n                                    this.errors.push(\n                                        new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) })\n                                    );\n                                });\n                            } else {\n                                this.errors.push(progressedjob.error);\n                            }\n                        }\n                    })\n                );\n            }\n\n            work.push(\n                this.canCancel(job, this.errors).then(canCancel => {\n                    if (loopid !== this.currentLoop) return;\n                    job.canCancel = canCancel;\n                })\n            );\n        }\n\n        //populate fields on jobs\n        await Promise.all(work);\n        if (loopid !== this.currentLoop) return;\n\n        this.emit(\"jobsLoaded\");\n\n        for (const job of this.jobs.values()) {\n            if (!job.stoppedAt) continue;\n            const callbacks = this.jobCallback.get(job.id);\n            if (!callbacks) continue;\n            for (const callback of callbacks) {\n                callback(job);\n            }\n            this.jobCallback.delete(job.id);\n        }\n\n        if (this.fastmodecount && loopid === this.currentLoop) {\n            window.setTimeout(() => {\n                this.loop(loopid).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, 800);\n            this.fastmodecount--;\n            console.log(`JobsController will remain in fastmode for ${this.fastmodecount} cycles`);\n        } else {\n            window.setTimeout(() => {\n                this.loop(loopid).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, (totalActiveJobs ? (configOptions.jobpollactive.value as number) : (configOptions.jobpollinactive.value as number)) * 1000);\n        }\n    }\n\n    private async canCancel(\n        job: Readonly<TGSJobResponse>,\n        errors: InternalError<ErrorCode>[]\n    ): Promise<boolean> {\n        //we dont need to reevalutate stuff that we already know\n        if (job.canCancel !== undefined) return job.canCancel;\n\n        if (job.cancelRightsType === undefined) {\n            return true;\n        }\n\n        switch (job.cancelRightsType as RightsType) {\n            case RightsType.Administration: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as AdministrationRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).administrationRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.InstanceManager: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstanceManagerRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).instanceManagerRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.Engine: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as EngineRights;\n                    return !!(InstancePermissionSet.payload.engineRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.ChatBots: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ChatBotRights;\n                    return !!(InstancePermissionSet.payload.chatBotRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Configuration: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ConfigurationRights;\n                    return !!(InstancePermissionSet.payload.configurationRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamDaemon: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamDaemonRights;\n                    return !!(InstancePermissionSet.payload.dreamDaemonRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamMaker: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamMakerRights;\n                    return !!(InstancePermissionSet.payload.dreamMakerRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.InstancePermissionSet: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstancePermissionSetRights;\n                    return !!(InstancePermissionSet.payload.instancePermissionSetRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Repository: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    job.instanceId\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as RepositoryRights;\n                    return !!(InstancePermissionSet.payload.repositoryRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n        }\n    }\n\n    public async cancelJob(\n        jobid: number,\n        onError: (error: InternalError<ErrorCode>) => void\n    ): Promise<boolean> {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        const deleteInfo = await JobsClient.deleteJob(job.instanceId, jobid);\n        if (deleteInfo.code === StatusCode.OK) {\n            return true;\n        } else {\n            onError(deleteInfo.error);\n            return false;\n        }\n    }\n\n    public clearJob(jobid: number, noEmit = false): boolean {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        this.jobsByInstance.get(job.instanceId)?.delete(jobid);\n        this.jobs.delete(jobid);\n        if (!noEmit) {\n            this.emit(\"jobsLoaded\");\n        }\n        return true;\n    }\n\n    public registerCallback(jobid: number, callback: (job: TGSJobResponse) => unknown): void {\n        const set = this.jobCallback.get(jobid) ?? new Set();\n        set.add(callback);\n        this.jobCallback.set(jobid, set);\n    }\n})();\n"],"names":["ApiClient","page","pageSize","configOptions","response","ServerClient","stat","InternalStatus","code","StatusCode","error","status","payload","data","InternalError","ErrorCode","axiosResponse","instance","id","this","emit","errorMessage","instanceid","constructor","super","_cachedInstancePermissionSet","Map","loadingInstancePermissionSetInfo","clear","headers","Instance","toString","noCache","has","get","Promise","resolve","resolver","user","removeListener","on","set","res","permissionSetId","instancePermissionSet","newContent","content","map","job","jobid","void","TypedEmitter","fastmode","cycles","async","jobsHubSupported","console","log","fastmodecount","restartLoop","doStuff","clearJobs","jobs","jobsByInstance","reloadAccessibleInstances","e","errors","push","jsError","Error","currentLoop","Date","accessibleInstances","enableJobProgressWorkaround","nextRetry","jobCallback","lastSeenJob","connection","loop","bind","reset","cleanConnection","state","connectionToStop","stop","stopAndRemoveConnection","init","window","clients","InstanceClient","LoginHooks","SemverSatisfies","version","allInstances","instances1","i","totalPages","instances2","updatedSet","work","filter","online","accessible","InstancePermissionSetClient","then","permissionSet","all","setTimeout","serverInfo","SemVerGte","apiVersion","warn","initDate","now","catch","apiPath","endsWith","localConnection","signalR","withUrl","accessTokenFactory","bearer","transport","withAutomaticReconnect","nextRetryDelayInMilliseconds","retryContext","previousRetryCount","nextRetryMs","Math","min","retryDate","setMilliseconds","getMilliseconds","configureLogging","build","registerJob","instanceId","canCancel","justReconnected","reconnectionTimeout","onreconnected","forcedRefresh","clearTimeout","onreconnecting","relog","start","_registerJob","_job","stoppedAt","instanceSet","loopid","totalActiveJobs","tempLastSeenJob","keys","processJobs","max","remoteActive","manualIds","Array","from","values","jobId","includes","forEach","JobsClient","length","processError","originalErrorMessage","errorCode","TGSErrorCode","delete","fetchJobs","value","lastPayload","fetchLoop","jobs2","reason","undefined","progress","progressedjob","callbacks","callback","cancelRightsType","RightsType","userInfo","UserClient","required","cancelRight","resolvePermissionSet","administrationRights","instanceManagerRights","InstancePermissionSet","engineRights","chatBotRights","configurationRights","dreamDaemonRights","dreamMakerRights","instancePermissionSetRights","repositoryRights","onError","deleteInfo","clearJob","noEmit","registerCallback","Set","add"],"sourceRoot":""}