{"version":3,"file":"379.c3e224183df605ae225f.bundle.js","mappings":"2MAwBA,QAAoB,cAA6BA,EAAAA,EAC7C,mBAAaC,EAAc,KACvBC,EAAO,EAAC,SACRC,EAAWC,EAAAA,GAAcC,aAAaC,OACtC,CAAC,GAGD,IAAIC,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAIC,uBAAuB,CAChET,SAAUA,EACVD,KAAMA,GAEd,CAAE,MAAOW,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CAEA,OACS,MADDN,EAASY,OAEF,IAAIL,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,OAIf,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,IAKpB,CAEA,sBAAaoB,CACTC,GAIA,IAAIrB,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAIkB,mCACzCD,EAASE,IAEbC,KAAKC,KAAK,iBAAkBJ,EAASE,GACzC,CAAE,MAAOjB,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CACA,OAAQN,EAASY,QACb,KAAK,IACD,OAAO,IAAIL,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAAS,CAAES,GAAIF,EAASE,MAGhC,KAAK,IACD,OAAO,IAAIhB,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QACI,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKpB,CAEA,kBAAa4B,CACTP,GAIA,IAAIrB,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAIyB,yBAAyBR,GACtEG,KAAKC,KAAK,iBAAkBJ,EAASE,GACzC,CAAE,MAAOjB,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CACA,OAAQN,EAASY,QACb,KAAK,IACL,KAAK,IACD,OAAO,IAAIL,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,OAG1B,KAAK,IACD,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QACI,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKpB,CAEA,oBAAa8B,CAAeP,GAGxB,IAAIvB,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAI2B,yBAAyBR,GACtEC,KAAKC,KAAK,iBAAkBF,EAChC,CAAE,MAAOjB,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CACA,OAAQN,EAASY,QACb,KAAK,IACD,OAAO,IAAIL,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAAS,OAGjB,KAAK,IACD,OAAO,IAAIP,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QACI,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKpB,CAEA,oBAAagC,CACTX,GAIA,IAAIrB,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAI6B,yBAAyBZ,EAC1E,CAAE,MAAOf,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CACA,OAAQN,EAASY,QACb,KAAK,IACL,KAAK,IAAK,CACN,MAAMS,EAAWrB,EAASe,KAI1B,OAFAS,KAAKC,KAAK,iBAAkBJ,EAASE,IAE9B,IAAIhB,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAASO,GAEjB,CACA,KAAK,IACD,OAAO,IAAId,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUiB,mBAAoB,CACnDP,aAAc3B,EAASe,SAGnC,QACI,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKpB,CAEA,iBAAamC,CACTC,GAIA,IAAIpC,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAIiC,wBAAwBD,EACzE,CAAE,MAAO9B,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CACA,OAAQN,EAASY,QACb,KAAK,IACD,OAAO,IAAIL,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,OAG1B,KAAK,IACD,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QACI,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKpB,E,6EC3PJ,QAAoB,cAA0CP,EAAAA,EAQnD6C,WAAAA,GACHC,QAAQ,KARJC,6BAGJ,IAAIC,IAA0E,KAE1EC,iCAAyD,IAAID,IAKjExC,EAAAA,EAAa0C,GAAG,cAAc,KAC1BnB,KAAKgB,6BAA6BI,OAAO,GAEjD,CAEA,gCAAaC,CACTT,GACA,KAAEzC,EAAO,EAAC,SAAEC,EAAWC,EAAAA,GAAcC,aAAaC,QAMlD,IAAIC,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAI0C,oCACzC,CACInD,KAAMA,EACNC,SAAUA,GAEd,CACImD,QAAS,CACLC,SAAUZ,EAAWa,aAIrC,CAAE,MAAO3C,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CAEA,GACS,MADDN,EAASY,OACH,CAQN,OAPY,IAAIL,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,MAG1B,CAaI,OAXY,IAAIR,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,IAMpB,CAEA,qCAAakD,CACTd,EACAe,GAMA,SAFMlD,EAAAA,EAAaC,aAEdiD,GAAW3B,KAAKgB,6BAA6BY,IAAIhB,GAClD,OAAOZ,KAAKgB,6BAA6Ba,IAAIjB,GAGjD,GAAIZ,KAAKkB,iCAAiCW,IAAIjB,GAC1C,aAAa,IAAIkB,SAAQC,IACrB,MAAMC,EACFC,IAEAF,EAAQE,GACRjC,KAAKkC,eAAe,4BAA6BF,EAAS,EAE9DhC,KAAKmB,GAAG,4BAA6Ba,EAAS,IAMtD,IAAIxD,EAFJwB,KAAKkB,iCAAiCiB,IAAIvB,GAAY,GAGtD,IACIpC,QAAiBC,EAAAA,EAAaE,UAAWC,IAAIwD,oCAAoC,CAC7Eb,QAAS,CACLC,SAAUZ,EAAWa,aAGjC,CAAE,MAAO3C,GACL,MAAMuD,EAAM,IAAItD,EAAAA,EAA6D,CACzEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,IAIX,OAFAkB,KAAKC,KAAK,4BAA6BoC,GACvCrC,KAAKkB,iCAAiCiB,IAAIvB,GAAY,GAC/CyB,CACX,CAEA,GACS,MADD7D,EAASY,OACH,CACN,MAAMiD,EAAM,IAAItD,EAAAA,EAA4D,CACxEC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,OAMtB,OAHAS,KAAKgB,6BAA6BmB,IAAIvB,EAAYyB,GAClDrC,KAAKC,KAAK,4BAA6BoC,GACvCrC,KAAKkB,iCAAiCiB,IAAIvB,GAAY,GAC/CyB,CACX,CACS,CACL,MAAMA,EAAM,IAAItD,EAAAA,EAA6D,CACzEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKR,OAFAwB,KAAKC,KAAK,4BAA6BoC,GACvCrC,KAAKkB,iCAAiCiB,IAAIvB,GAAY,GAC/CyB,CACX,CAER,CAEA,0BAAaC,CACT1B,EACA2B,GAIA,IAAI/D,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAI4D,qCACzCD,EACA,CACIhB,QAAS,CACLC,SAAUZ,EAAWa,aAIrC,CAAE,MAAO3C,GAQL,OAPY,IAAIC,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAGf,CAEA,OAAQN,EAASY,QACb,KAAK,IAKD,OAJY,IAAIL,EAAAA,EAA4D,CACxEC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,OAI1B,KAAK,IACD,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QAYI,OAXY,IAAIR,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAMpB,CAEA,iCAAaiE,CACT7B,EACA8B,GAIA,IAAIlE,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAI+D,sCACzCD,EACA,CACInB,QAAS,CACLC,SAAUZ,EAAWa,aAIrC,CAAE,MAAO3C,GAQL,OAPY,IAAIC,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAGf,CAEA,OAAQN,EAASY,QACb,KAAK,IAKD,OAJY,IAAIL,EAAAA,EAA4D,CACxEC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,OAI1B,KAAK,IACD,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QAYI,OAXY,IAAIR,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAMpB,CAEA,iCAAaoE,CACThC,EACA8B,GAIA,IAAIlE,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAIiE,sCACzCH,EACA,CACInB,QAAS,CACLC,SAAUZ,EAAWa,aAIrC,CAAE,MAAO3C,GAQL,OAPY,IAAIC,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAGf,CAEA,OAAQN,EAASY,QACb,KAAK,IAKD,OAJY,IAAIL,EAAAA,EAA4D,CACxEC,KAAMC,EAAAA,EAAWI,GACjBC,QAASd,EAASe,OAI1B,KAAK,IACD,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QAYI,OAXY,IAAIR,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAMpB,CAEA,iCAAasE,CACTlC,EACA2B,GAIA,IAAI/D,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAImE,sCACzCR,EACA,CACIhB,QAAS,CACLC,SAAUZ,EAAWa,aAIrC,CAAE,MAAO3C,GAQL,OAPY,IAAIC,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAGf,CAEA,OAAQN,EAASY,QACb,KAAK,IACD,OAAO,IAAIL,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAAS,CAAEiD,qBAGnB,KAAK,IACD,OAAO,IAAIxD,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUS,aAAc,CAC7CC,aAAc3B,EAASe,SAGnC,QAYI,OAXY,IAAIR,EAAAA,EAGd,CACEC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAMpB,E,6ECxXJ,QAAoB,cAAyBP,EAAAA,EACzC,oBAAa+E,CACTpC,GACA,KAAEzC,EAAO,EAAC,SAAEC,EAAWC,EAAAA,GAAcC,aAAaC,QAIlD,IAAIC,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAIqE,kBACzC,CACI9E,KAAMA,EACNC,SAAUA,GAEd,CACImD,QAAS,CACLC,SAAUZ,EAAWa,aAIrC,CAAE,MAAO3C,GACL,OAAO,IAAIC,EAAAA,EAAwD,CAC/DC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CAEA,GACS,MADDN,EAASY,OACH,CACN,MAAM8D,EAAc1E,EAASe,KAA8B4D,QAAQC,KAAIC,IAC5D,IACAA,EACHzC,WAAYA,MAIpB,OAAO,IAAI7B,EAAAA,EAAwD,CAC/DC,KAAMC,EAAAA,EAAWI,GACjBC,QAAS,IACDd,EAASe,KACb4D,QAASD,IAGrB,CAEI,OAAO,IAAInE,EAAAA,EAAwD,CAC/DC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,IAKpB,CAEA,YAAa8E,CACT1C,EACA2C,GAIA,IAAI/E,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAI4E,mBAAmBD,EAAO,CACnEhC,QAAS,CACLC,SAAUZ,EAAWa,aAGjC,CAAE,MAAO3C,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CAEA,OAAQN,EAASY,QACb,KAAK,IAAK,CACN,MAAMiE,EAAM,IACJ7E,EAASe,KACbqB,WAAYA,GAEhB,OAAO,IAAI7B,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAAS+D,GAEjB,CACA,KAAK,IACD,OAAO,IAAItE,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUgE,kBAAmB,CAClDtD,aAAc3B,EAASe,SAInC,QACI,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKpB,CAEA,eAAakF,CACT9C,EACA2C,GAIA,IAAI/E,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAI+E,oBAAoBJ,EAAO,CACpEhC,QAAS,CACLC,SAAUZ,EAAWa,aAGjC,CAAE,MAAO3C,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CAEA,OAAQN,EAASY,QACb,KAAK,IAAK,CACN,MAAMiE,EAAM,IACJ7E,EAASe,KACbqB,WAAYA,GAEhB,OAAO,IAAI7B,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWI,GACjBC,QAAS+D,GAEjB,CACA,KAAK,IACD,OAAO,IAAItE,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUgE,kBAAmB,CAClDtD,aAAc3B,EAASe,SAInC,KAAK,IACD,OAAO,IAAIR,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GAAcC,EAAAA,GAAUmE,iBAAkB,CACjDC,MAAM,MAIlB,QACI,OAAO,IAAI9E,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,KAKpB,CAEA,cAAasF,CACTlD,GACA,KAAEzC,EAAO,EAAC,SAAEC,EAAWC,EAAAA,GAAcC,aAAaC,QAIlD,IAAIC,QAFEC,EAAAA,EAAaC,YAGnB,IACIF,QAAiBC,EAAAA,EAAaE,UAAWC,IAAImF,kBACzC,CACI3F,WACAD,QAEJ,CACIoD,QAAS,CACLC,SAAUZ,EAAWa,aAIrC,CAAE,MAAO3C,GACL,OAAO,IAAIC,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAOL,GAEf,CAEA,GACS,MADDN,EAASY,OACH,CACN,MAAM8D,EAAc1E,EAASe,KAA8B4D,QAAQC,KAAIC,IAC5D,IACAA,EACHzC,WAAYA,MAIpB,OAAO,IAAI7B,EAAAA,EAAwD,CAC/DC,KAAMC,EAAAA,EAAWI,GACjBC,QAAS,IACDd,EAASe,KACb4D,QAASD,IAGrB,CAEI,OAAO,IAAInE,EAAAA,EAAe,CACtBC,KAAMC,EAAAA,EAAWC,MACjBC,MAAO,IAAIK,EAAAA,GACPC,EAAAA,GAAUC,mBACV,CAAEC,cAAenB,GACjBA,IAKpB,E,yMCtNJ,cAAoB,cAA6BwF,EAAAA,aAE7C,YAAWC,CAASC,GACAC,iBACFnE,KAAKoE,qBAIfC,QAAQC,IAAI,wCAAwCJ,YACpDlE,KAAKuE,cAAgBL,QACflE,KAAKwE,cAAa,EAEvBC,EACT,CAgBA,WAAaC,CAAMC,GACfN,QAAQC,IAAI,4BACRK,IACA3E,KAAK4E,KAAO,IAAI3D,IAChBjB,KAAK6E,eAAiB,IAAI5D,KAG9B,UACUjB,KAAK8E,2BACf,CAAE,MAAOC,GAIL,YAHA/E,KAAKgF,OAAOC,KACR,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUyF,SAAU,CAAEC,QAASC,MAAML,KAG/D,OAEM/E,KAAKwE,aACf,CAEO1D,WAAAA,GACHC,QAAQ,KAhDJwD,cAAgB,EAAC,KAcjBc,YAAoB,IAAIC,KAAK,GAAE,KAChCC,oBAAsB,IAAItE,IAA+B,KAExDuE,iCAA2B,OAE5BR,OAA0B,GAAE,KAC5BS,eAAS,OACTb,KAAO,IAAI3D,IAA6B,KACxC4D,eAAiB,IAAI5D,IAA0C,KAC9DyE,YAAc,IAAIzE,IAAoD,KACtE0E,aAAe,EAAC,KAEhBC,gBAAU,EAwBd5F,KAAK4F,WAAa,KAClB5F,KAAKyF,UAAY,KACjBzF,KAAK6F,KAAO7F,KAAK6F,KAAKC,KAAK9F,MAC3BA,KAAK0E,MAAQ1E,KAAK0E,MAAMoB,KAAK9F,MAC7BA,KAAK+F,gBAAkB/F,KAAK+F,gBAAgBD,KAAK9F,MACjDA,KAAKwE,YAAcxE,KAAKwE,YAAYsB,KAAK9F,KAC7C,CAEA,6BAAcgG,GAGV,GAFA3B,QAAQC,IAAI,2CAERtE,KAAK4F,WAAY,CACjBvB,QAAQC,IACJ,0DAA0DtE,KAAK4F,WAAWK,SAE9E,MAAMC,EAAmBlG,KAAK4F,WAC9B5F,KAAK4F,WAAa,WACZM,EAAiBC,MAC3B,CACJ,CAEA,qBAAcJ,SACE/F,KAAKoE,qBAIjBC,QAAQC,IAAI,yCAENtE,KAAKgG,0BAEXhG,KAAKgF,OAAS,GACdhF,KAAKyF,UAAY,KACjBzF,KAAK4E,KAAO,IAAI3D,IAChBjB,KAAK6E,eAAiB,IAAI5D,IAC1BjB,KAAKC,KAAK,cACd,CAEOmG,IAAAA,GACHC,OAAOC,QAAwB,eAAItG,KAGnCvB,EAAAA,EAAa0C,GAAG,cAAc,KAAWnB,KAAK0E,OAAM,EAAK,IACzDjG,EAAAA,EAAa0C,GAAG,UAAU,KAAWnB,KAAK+F,iBAAiB,IAE3DQ,EAAAA,EAAepF,GAAG,kBAAkB,KAAWnB,KAAK0E,OAAM,EAAM,IAChE8B,EAAAA,EAAWC,SAAQtC,UACfE,QAAQC,IAAI,+CACNtE,KAAK0E,OAAM,EAAK,IAG1BjG,EAAAA,EAAa0C,GAAG,kBAAkB3C,IAC1BA,EAASQ,OAASC,EAAAA,EAAWI,KAE7BW,KAAKwF,6BAA8BkB,EAAAA,EAAAA,WAC/BlI,EAASc,QAAQqH,QACjB,WAER,GAER,CAEA,+BAAc7B,CAA0Be,GAAO,GAC3C,MAAMe,EAAmC,GAEnCC,QAAmBN,EAAAA,EAAerI,cAAc,CAAEE,SAAU,MAClE,GAAIyI,EAAW7H,OAASC,EAAAA,EAAWC,MAE/B,YADAc,KAAKgF,OAAOC,KAAK4B,EAAW1H,OAG5ByH,EAAa3B,QAAQ4B,EAAWvH,QAAQ6D,SAE5C,IAAK,IAAI2D,EAAI,EAAGA,GAAKD,EAAWvH,QAAQyH,WAAYD,IAAK,CACrD,MAAME,QAAmBT,EAAAA,EAAerI,cAAc,CAAEC,KAAM2I,EAAG1I,SAAU,MAC3E,GAAI4I,EAAWhI,OAASC,EAAAA,EAAWC,MAE/B,YADAc,KAAKgF,OAAOC,KAAK+B,EAAW7H,OAG5ByH,EAAa3B,QAAQ+B,EAAW1H,QAAQ6D,QAEhD,CAEA,MAAM8D,EAAa,IAAIhG,IAEjBiG,EAAON,EACRO,QAAOtH,GAAYA,EAASuH,QAAUvH,EAASwH,aAC/CjE,KAAIvD,GACMyH,EAAAA,EAA4B5F,gCAC/B7B,EAASE,IACXwH,MAAKC,IACCA,EAAcxI,OAASC,EAAAA,EAAWC,MAOtC+H,EAAW9E,IAAItC,EAASE,GAAIF,GALpB2H,EAAcrI,MAAMH,OAASS,EAAAA,GAAUgI,oBACvCzH,KAAKgF,OAAOC,KAAKuC,EAAcrI,MAIF,YAI3C2C,QAAQ4F,IAAIR,GAElBlH,KAAKuF,oBAAsB0B,EAEvBpB,GACAQ,OAAOsB,YACH,KAAW3H,KAAK8E,2BAA0B,EAAK,GAC/CzG,EAAAA,GAAcuJ,mBAAmBrJ,MAG7C,CAEA,sBAAc6F,GACV,GAAI/F,EAAAA,GAAcwJ,UAAUtJ,MACxB,OAAO,EAGX,GAAIyB,KAAK4F,WACL,OAAO,EAGX,MAAMkC,QAAmBrJ,EAAAA,EAAasJ,gBACtC,OAAID,EAAW9I,OAASC,EAAAA,EAAWI,IACxB2I,EAAAA,EAAAA,KAAUF,EAAWxI,QAAQ2I,WAAY,WAGpD5D,QAAQ6D,KAAK,iEAEN,EACX,CAEA,iBAAa1D,GAET,GADAH,QAAQC,IAAI,sCACAtE,KAAKoE,mBAAqB,CAIlC,MAAM+D,EAAW,IAAI7C,KAAKA,KAAK8C,OAU/B,OATApI,KAAKqF,YAAc8C,OACnB9B,OAAOsB,YAAW,KACd3H,KAAK6F,KAAKsC,GAAUE,OAAMtD,GACtB/E,KAAKgF,OAAOC,KACR,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUyF,SAAU,CAAEC,QAASC,MAAML,OAE9D,GACF,EAGP,OAEM/E,KAAKgG,0BAEXhG,KAAKyF,UAAY,KAEjB,IAAI6C,EAAUjK,EAAAA,GAAckK,QAAQhK,MAC/B+J,EAAQE,SAAS,OAClBF,GAAoB,KAGxB,MAAMG,EAAmBzI,KAAK4F,YAAa,IAAI8C,EAAAA,GAC1CC,QAAQ,GAAGL,iBAAwB,CAChCM,mBAAoBzE,gBACI1F,EAAAA,EAAaoK,cACpBC,OAEjBC,UAAWL,EAAAA,EAA0BM,iBACrCzH,QAAS9C,EAAAA,EAAawK,iBAEzBC,uBAAuB,CACpBC,6BAA+BC,IAC3B,GAAuC,GAAnCA,EAAaC,mBACb,OAAO,EAGX,MAAMC,EAAmE,IAArDC,KAAKC,IAAI,GAAKJ,EAAaC,mBAAoB,IAC7DI,EAAY,IAAInE,KAItB,OAHAmE,EAAUC,gBAAgBD,EAAUE,kBAAoBL,GACxDtJ,KAAKyF,UAAYgE,EACjBzJ,KAAKC,KAAK,cACHqJ,CAAW,IAGzBM,iBAAiBlB,EAAAA,EAAiBmB,OAClCC,QAELrB,EAAgBtH,GAAG,oBAAoBgD,UACnCE,QAAQC,IAAI,2BAA2BjB,EAAItD,MAC3CC,KAAK+J,YAAY1G,EAAKA,EAAI2G,YAC1BhK,KAAKC,KAAK,cACV,MAAMgK,QAAkBjK,KAAKiK,UAAU5G,EAAKrD,KAAKgF,QAC7ChF,KAAK4E,KAAKhD,IAAIyB,EAAItD,MAClBC,KAAK4E,KAAK/C,IAAIwB,EAAItD,IAAKkK,UAAYA,EACnCjK,KAAKC,KAAK,cACd,IAGJ,IAAIiK,GAAkB,EAClBC,EAA6C,KACjD1B,EAAgB2B,eAAc,KAC1BpK,KAAKyF,UAAY,KACjByE,GAAkB,EAClBlK,KAAKC,KAAK,cACVoE,QAAQC,IAAI,0DAGZ,MAAM+F,EAAgBlG,UAClBmG,aAAaH,GACbA,EAAsB,KAClB1B,EAAgBxC,QAAUyC,EAAAA,EAA2B6B,YAIzDL,GAAkB,EAElBlK,KAAKgF,OAAS,GACdhF,KAAKC,KAAK,oBACJD,KAAK8E,2BAA0B,SAC/B9E,KAAK6F,KAAM7F,KAAKqF,YAAc,IAAIC,MAAQ,EAGhD6E,GACAG,aAAaH,GAGjBA,EAAsBxC,YAAW,KAAW0C,GAAe,GAAE,IAAK,IAGtE5B,EAAgB+B,gBAAe,KAC3B,GAAIN,EAAJ,CACQC,IACAG,aAAaH,GACbA,EAAsB,MAGZhG,kBAEW1F,EAAAA,EAAagM,SACvBzL,MAAQC,EAAAA,EAAWI,GAC1BZ,EAAAA,EAAaiM,SAEbR,GAAkB,CACtB,EAGCS,EAET,MAEA3K,KAAKgF,OAAS,GACdhF,KAAKgF,OAAOC,KAAK,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUmL,mBAAoB,CAAE/G,MAAM,KACzE7D,KAAKC,KAAK,aAAa,IAG3BwI,EAAgBoC,QAAQxC,OAAMlJ,IACtBa,KAAK4F,YAAc6C,IAIvBzI,KAAKgF,OAAS,GACV7F,aAAiBiG,MACjBpF,KAAKgF,OAAOC,KACR,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUmL,mBAAoB,CAAEzF,QAAShG,KAG/Da,KAAKgF,OAAOC,KAAK,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUmL,mBAAoB,CAAE/G,MAAM,KAE7E7D,KAAKC,KAAK,cACVD,KAAK4F,WAAa,KAAI,GAE9B,CAKQkF,YAAAA,CAAaC,EAAoCnK,GACrD,MAAMyC,EAAM0H,EACZ,GAAI/K,KAAK4E,KAAKhD,IAAIyB,EAAItD,KAAOC,KAAK4E,KAAK/C,IAAIwB,EAAItD,IAAKiL,UAMhD,YALA3G,QAAQ6D,KACJ,4BAA4B7E,EAAItD,0CAC5BsD,EAAI2H,UAAY,GAAK,qBAM7BpK,IAAYyC,EAAI2G,WAAapJ,GACjC,MAAMqK,EACFjL,KAAK6E,eAAehD,IAAIwB,EAAI2G,aAAe,IAAI/I,IACnDjB,KAAK6E,eAAe1C,IAAIkB,EAAI2G,WAAYiB,GACxCA,EAAY9I,IAAIkB,EAAItD,GAAIsD,GACxBrD,KAAK4E,KAAKzC,IAAIkB,EAAItD,GAAIsD,EAC1B,CAIO0G,WAAAA,CAAYgB,EAAoCnK,GACnDZ,KAAK8K,aAAaC,EAAMnK,GAERuD,iBACAnE,KAAKoE,qBACbC,QAAQC,IACJ,oFAEEtE,KAAKwE,cACf,EAGCC,EACT,CAEA,UAAcoB,CAAKqF,GAKf,GAAIA,IAAWlL,KAAKqF,YAChB,OAIJrF,KAAKgF,OAAS,GAEd,IAAImG,EAAkB,EACtB,MAAMjE,EAAwB,GAG9B,IAAIkE,EAAkBpL,KAAK2F,YAC3B,IAAK,MAAM/E,KAAcZ,KAAKuF,oBAAoB8F,OAAQ,CACtD,MAAMC,EAAcnH,UAChB,IAAK,MAAMd,KAAOuB,EACd5E,KAAK8K,aAAazH,GAClB+H,EAAkB7B,KAAKgC,IAAIH,EAAiB/H,EAAItD,IAGpD,MAAMyL,EAAe5G,EAAKxB,KAAIC,GAAOA,EAAItD,KAKnC0L,EAJcC,MAAMC,KAAK3L,KAAK4E,KAAKgH,UACpCzE,QAAO9D,IAAQA,EAAI2H,YACnB7D,QAAO9D,GAAOA,EAAI2G,aAAepJ,IACjCwC,KAAIC,GAAOA,EAAItD,KACUoH,QAAO0E,IAAUL,EAAaM,SAASD,KAE/DZ,EACFjL,KAAK6E,eAAehD,IAAIjB,IAAe,IAAIK,IAC/CjB,KAAK6E,eAAe1C,IAAIvB,EAAYqK,GACpC,MAAM/D,EAAwB,GAC9BuE,EAAUM,SAAQF,IACd3E,EAAKjC,KACD+G,EAAAA,EAAW1I,OAAO1C,EAAYiL,GAAOtE,MAAKlE,IAClCA,EAAIrE,OAASC,EAAAA,EAAWC,OAI5B+L,EAAY9I,IAAIkB,EAAI/D,QAAQS,GAAIsD,EAAI/D,SACpCU,KAAK4E,KAAKzC,IAAIkB,EAAI/D,QAAQS,GAAIsD,EAAI/D,UAJ9BU,KAAKgF,OAAOC,KAAK5B,EAAIlE,MAIiB,IAEjD,UAEC2C,QAAQ4F,IAAIR,GAEdgE,IAAWlL,KAAKqF,cAEpB8F,GAAmBvG,EAAKqH,OAAM,EAG5BC,EAAgB/M,IAEdA,EAAMH,OAASS,EAAAA,GAAUiB,oBACzBvB,EAAMgN,sBAAsBC,YAAcC,EAAAA,GAAaC,iBAEvDjI,QAAQC,IACJ,sCAAsC1D,0BAE1CZ,KAAKuF,oBAAoBgH,OAAO3L,GAEhCZ,KAAK8E,4BAA4BuD,OAAMtD,IACnC/E,KAAKgF,OAAOC,KACR,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUyF,SAAU,CAAEC,QAASC,MAAML,KAC1D,KAGL/E,KAAKgF,OAAOC,KAAK9F,EACrB,EAGEqN,GACoB,IAAtBxM,KAAK2F,YAAqBqG,EAAAA,EAAWhJ,eAAiBgJ,EAAAA,EAAWlI,SAErEoD,EAAKjC,KACDuH,EAAU5L,EAAY,CAAEzC,KAAM,EAAGC,SAAU,KACtCmJ,MAAKpD,UAKF,GAAI+G,IAAWlL,KAAKqF,YAEpB,GAAI9G,EAAMS,OAASC,EAAAA,EAAWI,GAAI,CAC9B,IAAIoN,EAAclO,EAAMe,QAAQ6D,QAChCuJ,EAAW,IAAK,IAAI5F,EAAI,EAAGA,GAAKvI,EAAMe,QAAQyH,WAAYD,IAAK,CAC3D,IAAK,MAAMzD,KAAOoJ,EAEd,GAAIpJ,EAAItD,IAAMC,KAAK2F,YACf,MAAM+G,EAGd,MAAMC,QAAcH,EAAU5L,EAAY,CACtCzC,KAAM2I,EACN1I,SAAU,KAEd,GAAIuO,EAAM3N,OAASC,EAAAA,EAAWC,MAE1B,YADAgN,EAAaS,EAAMxN,OAGnBZ,EAAMe,QAAQ6D,QAAQ8B,QAAQ0H,EAAMrN,QAAQ6D,SAC5CsJ,EAAclO,EAAMe,QAAQ6D,OAEpC,CACA,GAAI+H,IAAWlL,KAAKqF,YAAa,aAC3BiG,EACF/M,EAAMe,QAAQ6D,QAAQgE,QAClB9D,GAAOA,EAAItD,GAAKC,KAAK2F,aAAe3F,KAAK4E,KAAKhD,IAAIyB,EAAItD,MAGlE,MACImM,EAAa3N,EAAMY,MACvB,IAEHkJ,OAAMuE,IACHvI,QAAQlF,MAAMyN,EAAO,IAGrC,OAEM9K,QAAQ4F,IAAIR,GAElBlH,KAAK2F,YAAcyF,EAEnBlE,EAAK+E,OAAS,EACd,IAAK,MAAM5I,KAAOrD,KAAK4E,KAAKgH,SAEpB5L,KAAKwF,kCACYqH,IAAjBxJ,EAAIyJ,WACHzJ,EAAI2H,WACLhL,KAAKuF,oBAAoB3D,IAAIyB,EAAI2G,aAEjC9C,EAAKjC,KACD+G,EAAAA,EAAW1I,OAAOD,EAAI2G,WAAY3G,EAAItD,IAAIwH,MAAKwF,IACvC7B,IAAWlL,KAAKqF,cAChB0H,EAAc/N,OAASC,EAAAA,EAAWI,GAClCgE,EAAIyJ,SAAWC,EAAczN,QAAQwN,SAGjCC,EAAc5N,MAAMH,OAASS,EAAAA,GAAUiB,oBACvCqM,EAAc5N,MAAMgN,sBAAsBC,YACtCC,EAAAA,GAAaC,iBAEjBjI,QAAQC,IACJ,sCAAsCjB,EAAI2G,mCAE9ChK,KAAKuF,oBAAoBgH,OAAOlJ,EAAI2G,YAEpChK,KAAK8E,4BAA4BuD,OAAMtD,IACnC/E,KAAKgF,OAAOC,KACR,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUyF,SAAU,CAClCC,QAASC,MAAML,KAEtB,KAGL/E,KAAKgF,OAAOC,KAAK8H,EAAc5N,OAEvC,KAKZ+H,EAAKjC,KACDjF,KAAKiK,UAAU5G,EAAKrD,KAAKgF,QAAQuC,MAAK0C,IAC9BiB,IAAWlL,KAAKqF,cACpBhC,EAAI4G,UAAYA,EAAS,KAOrC,SADMnI,QAAQ4F,IAAIR,GACdgE,IAAWlL,KAAKqF,YAApB,CAEArF,KAAKC,KAAK,cAEV,IAAK,MAAMoD,KAAOrD,KAAK4E,KAAKgH,SAAU,CAClC,IAAKvI,EAAI2H,UAAW,SACpB,MAAMgC,EAAYhN,KAAK0F,YAAY7D,IAAIwB,EAAItD,IAC3C,GAAKiN,EAAL,CACA,IAAK,MAAMC,KAAYD,EACnBC,EAAS5J,GAEbrD,KAAK0F,YAAY6G,OAAOlJ,EAAItD,GAJJ,CAK5B,CAEIC,KAAKuE,eAAiB2G,IAAWlL,KAAKqF,aACtCgB,OAAOsB,YAAW,KACd3H,KAAK6F,KAAKqF,GAAQ7C,OAAMtD,GACpB/E,KAAKgF,OAAOC,KACR,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUyF,SAAU,CAAEC,QAASC,MAAML,OAE9D,GACF,KACH/E,KAAKuE,gBACLF,QAAQC,IAAI,8CAA8CtE,KAAKuE,yBAE/D8B,OAAOsB,YACH,KACI3H,KAAK6F,KAAKqF,GAAQ7C,OAAMtD,GACpB/E,KAAKgF,OAAOC,KACR,IAAIzF,EAAAA,GAAcC,EAAAA,GAAUyF,SAAU,CAAEC,QAASC,MAAML,OAE9D,GAIoD,KAFxDoG,EACM9M,EAAAA,GAAc6O,cAAc3O,MAC5BF,EAAAA,GAAc8O,gBAAgB5O,OAnCN,CAsC3C,CAEA,eAAc0L,CACV5G,EACA2B,GAGA,QAAsB6H,IAAlBxJ,EAAI4G,UAAyB,OAAO5G,EAAI4G,UAE5C,QAA6B4C,IAAzBxJ,EAAI+J,iBACJ,OAAO,EAGX,OAAQ/J,EAAI+J,kBACR,KAAKC,EAAAA,GAAWC,eAAgB,CAC5B,MAAMC,QAAiBC,EAAAA,EAAWC,iBAClC,GAAIF,EAASvO,OAASC,EAAAA,EAAWI,GAAI,CACjC,MAAMqO,EAAWrK,EAAIsK,YACrB,UACIC,EAAAA,EAAAA,GAAqBL,EAASjO,SAASuO,qBAAuBH,EAEtE,CAEI,OADA1I,EAAOC,KAAKsI,EAASpO,QACd,CAEf,CACA,KAAKkO,EAAAA,GAAWS,gBAAiB,CAC7B,MAAMP,QAAiBC,EAAAA,EAAWC,iBAClC,GAAIF,EAASvO,OAASC,EAAAA,EAAWI,GAAI,CACjC,MAAMqO,EAAWrK,EAAIsK,YACrB,UACIC,EAAAA,EAAAA,GAAqBL,EAASjO,SAASyO,sBAAwBL,EAEvE,CAEI,OADA1I,EAAOC,KAAKsI,EAASpO,QACd,CAEf,CACA,KAAKkO,EAAAA,GAAWW,OAAQ,CACpB,MAAMC,QACI3G,EAAAA,EAA4B5F,gCAC9B2B,EAAI2G,YAEZ,GAAIiE,EAAsBjP,OAASC,EAAAA,EAAWI,GAAI,CAC9C,MAAMqO,EAAWrK,EAAIsK,YACrB,SAAUM,EAAsB3O,QAAQ4O,aAAeR,EAC3D,CAEI,OADA1I,EAAOC,KAAKgJ,EAAsB9O,QAC3B,CAEf,CACA,KAAKkO,EAAAA,GAAWc,SAAU,CACtB,MAAMF,QACI3G,EAAAA,EAA4B5F,gCAC9B2B,EAAI2G,YAEZ,GAAIiE,EAAsBjP,OAASC,EAAAA,EAAWI,GAAI,CAC9C,MAAMqO,EAAWrK,EAAIsK,YACrB,SAAUM,EAAsB3O,QAAQ8O,cAAgBV,EAC5D,CAEI,OADA1I,EAAOC,KAAKgJ,EAAsB9O,QAC3B,CAEf,CACA,KAAKkO,EAAAA,GAAWgB,cAAe,CAC3B,MAAMJ,QACI3G,EAAAA,EAA4B5F,gCAC9B2B,EAAI2G,YAEZ,GAAIiE,EAAsBjP,OAASC,EAAAA,EAAWI,GAAI,CAC9C,MAAMqO,EAAWrK,EAAIsK,YACrB,SAAUM,EAAsB3O,QAAQgP,oBAAsBZ,EAClE,CAEI,OADA1I,EAAOC,KAAKgJ,EAAsB9O,QAC3B,CAEf,CACA,KAAKkO,EAAAA,GAAWkB,YAAa,CACzB,MAAMN,QACI3G,EAAAA,EAA4B5F,gCAC9B2B,EAAI2G,YAEZ,GAAIiE,EAAsBjP,OAASC,EAAAA,EAAWI,GAAI,CAC9C,MAAMqO,EAAWrK,EAAIsK,YACrB,SAAUM,EAAsB3O,QAAQkP,kBAAoBd,EAChE,CAEI,OADA1I,EAAOC,KAAKgJ,EAAsB9O,QAC3B,CAEf,CACA,KAAKkO,EAAAA,GAAWoB,WAAY,CACxB,MAAMR,QACI3G,EAAAA,EAA4B5F,gCAC9B2B,EAAI2G,YAEZ,GAAIiE,EAAsBjP,OAASC,EAAAA,EAAWI,GAAI,CAC9C,MAAMqO,EAAWrK,EAAIsK,YACrB,SAAUM,EAAsB3O,QAAQoP,iBAAmBhB,EAC/D,CAEI,OADA1I,EAAOC,KAAKgJ,EAAsB9O,QAC3B,CAEf,CACA,KAAKkO,EAAAA,GAAWY,sBAAuB,CACnC,MAAMA,QACI3G,EAAAA,EAA4B5F,gCAC9B2B,EAAI2G,YAEZ,GAAIiE,EAAsBjP,OAASC,EAAAA,EAAWI,GAAI,CAC9C,MAAMqO,EAAWrK,EAAIsK,YACrB,SAAUM,EAAsB3O,QAAQqP,4BAA8BjB,EAC1E,CAEI,OADA1I,EAAOC,KAAKgJ,EAAsB9O,QAC3B,CAEf,CACA,KAAKkO,EAAAA,GAAWuB,WAAY,CACxB,MAAMX,QACI3G,EAAAA,EAA4B5F,gCAC9B2B,EAAI2G,YAEZ,GAAIiE,EAAsBjP,OAASC,EAAAA,EAAWI,GAAI,CAC9C,MAAMqO,EAAWrK,EAAIsK,YACrB,SAAUM,EAAsB3O,QAAQuP,iBAAmBnB,EAC/D,CAEI,OADA1I,EAAOC,KAAKgJ,EAAsB9O,QAC3B,CAEf,EAER,CAEA,eAAa2P,CACTvL,EACAwL,GAEA,MAAM1L,EAAMrD,KAAK4E,KAAK/C,IAAI0B,GAG1B,IAAKF,EAAK,OAAO,EAEjB,MAAM2L,QAAmBhD,EAAAA,EAAWtI,UAAUL,EAAI2G,WAAYzG,GAC9D,OAAIyL,EAAWhQ,OAASC,EAAAA,EAAWI,KAG/B0P,EAAQC,EAAW7P,QACZ,EAEf,CAEO8P,QAAAA,CAAS1L,EAAe2L,GAAS,GACpC,MAAM7L,EAAMrD,KAAK4E,KAAK/C,IAAI0B,GAG1B,QAAKF,IAELrD,KAAK6E,eAAehD,IAAIwB,EAAI2G,aAAauC,OAAOhJ,GAChDvD,KAAK4E,KAAK2H,OAAOhJ,GACZ2L,GACDlP,KAAKC,KAAK,eAEP,EACX,CAEOkP,gBAAAA,CAAiB5L,EAAe0J,GACnC,MAAM9K,EAAMnC,KAAK0F,YAAY7D,IAAI0B,IAAU,IAAI6L,IAC/CjN,EAAIkN,IAAIpC,GACRjN,KAAK0F,YAAYvD,IAAIoB,EAAOpB,EAChC,E","sources":["webpack://tgstation-server-control-panel/./src/ApiClient/InstanceClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/InstancePermissionSetClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/JobsClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/JobsController.ts"],"sourcesContent":["import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    InstanceCreateRequest,\n    InstanceResponse,\n    InstanceUpdateRequest,\n    PaginatedInstanceResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type ListInstancesErrors = GenericErrors;\nexport type CreateInstanceErrors = GenericErrors;\nexport type EditInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type GetInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type GrantPermissionsErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type DetachInstanceErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\n\ninterface IEvents {\n    instanceChange: (instanceId: number) => void;\n}\n\nexport default new (class InstanceClient extends ApiClient<IEvents> {\n    public async listInstances({\n        page = 1,\n        pageSize = configOptions.itemsperpage.value as number\n    } = {}): Promise<InternalStatus<PaginatedInstanceResponse, ListInstancesErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerList({\n                pageSize: pageSize,\n                page: page\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedInstanceResponse\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async grantPermissions(\n        instance: InstanceUpdateRequest\n    ): Promise<InternalStatus<InstanceResponse, GrantPermissionsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerGrantPermissions(\n                instance.id\n            );\n            this.emit(\"instanceChange\", instance.id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: { id: instance.id } as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async editInstance(\n        instance: InstanceUpdateRequest\n    ): Promise<InternalStatus<InstanceResponse, EditInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerUpdate(instance);\n            this.emit(\"instanceChange\", instance.id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 202: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async detachInstance(id: number): Promise<InternalStatus<null, DetachInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerDelete(id);\n            this.emit(\"instanceChange\", id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: null\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async createInstance(\n        instance: InstanceCreateRequest\n    ): Promise<InternalStatus<InstanceResponse, CreateInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerCreate(instance);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 201: {\n                const instance = response.data as InstanceResponse;\n\n                this.emit(\"instanceChange\", instance.id);\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: instance\n                });\n            }\n            case 409:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.HTTP_DATA_INEGRITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getInstance(\n        instanceid: number\n    ): Promise<InternalStatus<InstanceResponse, GetInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instanceControllerGetId(instanceid);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    InstancePermissionSetRequest,\n    InstancePermissionSetResponse,\n    PaginatedInstancePermissionSetResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\ninterface IEvents {\n    loadInstancePermissionSet: (\n        user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n    ) => void;\n}\n\nexport type getCurrentInstancePermissionSetErrors = GenericErrors;\nexport type getByPermissionSetIdErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type createInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type updateInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type deleteInstancePermissionSetErrors = GenericErrors | ErrorCode.NO_DB_ENTITY;\nexport type listInstancePermissionSetErrors = GenericErrors;\n\nexport default new (class InstancePermissionSetClient extends ApiClient<IEvents> {\n    private _cachedInstancePermissionSet: Map<\n        number,\n        InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>\n    > = new Map<number, InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>>();\n\n    private loadingInstancePermissionSetInfo: Map<number, boolean> = new Map<number, boolean>();\n\n    public constructor() {\n        super();\n\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedInstancePermissionSet.clear();\n        });\n    }\n\n    public async listInstancePermissionSets(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<\n        InternalStatus<PaginatedInstancePermissionSetResponse, listInstancePermissionSetErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerList(\n                {\n                    page: page,\n                    pageSize: pageSize\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<\n                    PaginatedInstancePermissionSetResponse,\n                    ErrorCode.OK\n                >({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedInstancePermissionSetResponse\n                });\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<\n                    PaginatedInstancePermissionSetResponse,\n                    GenericErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async getCurrentInstancePermissionSet(\n        instanceid: number,\n        noCache?: boolean\n    ): Promise<\n        InternalStatus<InstancePermissionSetResponse, getCurrentInstancePermissionSetErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        if (!noCache && this._cachedInstancePermissionSet.has(instanceid)) {\n            return this._cachedInstancePermissionSet.get(instanceid)!;\n        }\n\n        if (this.loadingInstancePermissionSetInfo.get(instanceid)) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadInstancePermissionSet\", resolver);\n                };\n                this.on(\"loadInstancePermissionSet\", resolver);\n            });\n        }\n\n        this.loadingInstancePermissionSetInfo.set(instanceid, true);\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerRead({\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadInstancePermissionSet\", res);\n            this.loadingInstancePermissionSetInfo.set(instanceid, false);\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n\n                this._cachedInstancePermissionSet.set(instanceid, res);\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n        }\n    }\n\n    public async getByPermissionSetId(\n        instanceid: number,\n        permissionSetId: number\n    ): Promise<InternalStatus<InstancePermissionSetResponse, getByPermissionSetIdErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerGetId(\n                permissionSetId,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                getByPermissionSetIdErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<getByPermissionSetIdErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    getByPermissionSetIdErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async createInstancePermissionSet(\n        instanceid: number,\n        instancePermissionSet: InstancePermissionSetRequest\n    ): Promise<InternalStatus<InstancePermissionSetResponse, createInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerCreate(\n                instancePermissionSet,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                createInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<createInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 201: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    createInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async updateInstancePermissionSet(\n        instanceid: number,\n        instancePermissionSet: InstancePermissionSetRequest\n    ): Promise<InternalStatus<InstancePermissionSetResponse, updateInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerUpdate(\n                instancePermissionSet,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                updateInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<updateInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n                return res;\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    updateInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n\n    public async deleteInstancePermissionSet(\n        instanceid: number,\n        permissionSetId: number\n    ): Promise<InternalStatus<InstancePermissionSetResponse, deleteInstancePermissionSetErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.instancePermissionSetControllerDelete(\n                permissionSetId,\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            const res = new InternalStatus<\n                InstancePermissionSetResponse,\n                deleteInstancePermissionSetErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<deleteInstancePermissionSetErrors>\n            });\n            return res;\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: { permissionSetId } as InstancePermissionSetResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                const res = new InternalStatus<\n                    InstancePermissionSetResponse,\n                    deleteInstancePermissionSetErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                return res;\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport type {\n    ErrorMessageResponse,\n    JobResponse,\n    PaginatedJobResponse\n} from \"./generatedcode/generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type listJobsErrors = GenericErrors;\nexport type getJobErrors = GenericErrors | ErrorCode.JOB_JOB_NOT_FOUND;\nexport type deleteJobErrors =\n    | GenericErrors\n    | ErrorCode.JOB_JOB_NOT_FOUND\n    | ErrorCode.JOB_JOB_COMPLETE;\n\nexport type PaginatedTGSJobResponse = Omit<PaginatedJobResponse, \"content\"> & {\n    content: TGSJobResponse[];\n};\nexport type TGSJobResponse = JobResponse & {\n    canCancel?: boolean;\n};\n\nexport default new (class JobsClient extends ApiClient {\n    public async listActiveJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, listJobsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerRead(\n                {\n                    page: page,\n                    pageSize: pageSize\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, getJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerGetId(jobid, {\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async deleteJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, deleteJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerDelete(jobid, {\n                headers: {\n                    Instance: instanceid.toString()\n                }\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_COMPLETE, {\n                        void: true\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async listJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, GenericErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.api.jobControllerList(\n                {\n                    pageSize,\n                    page\n                },\n                {\n                    headers: {\n                        Instance: instanceid.toString()\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import * as signalR from \"@microsoft/signalr\";\nimport { gte as SemVerGte, satisfies as SemverSatisfies } from \"semver\";\nimport { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { resolvePermissionSet } from \"../../utils/misc\";\nimport {\n    AdministrationRights,\n    ChatBotRights,\n    ConfigurationRights,\n    DreamDaemonRights,\n    DreamMakerRights,\n    EngineRights,\n    ErrorCode as TGSErrorCode,\n    InstanceManagerRights,\n    InstancePermissionSetRights,\n    InstanceResponse,\n    JobResponse,\n    RepositoryRights,\n    RightsType\n} from \"../generatedcode/generated\";\nimport InstanceClient from \"../InstanceClient\";\nimport InstancePermissionSetClient from \"../InstancePermissionSetClient\";\nimport JobsClient, { TGSJobResponse } from \"../JobsClient\";\nimport InternalError, { ErrorCode } from \"../models/InternalComms/InternalError\";\nimport { StatusCode } from \"../models/InternalComms/InternalStatus\";\nimport ServerClient from \"../ServerClient\";\nimport UserClient from \"../UserClient\";\nimport configOptions from \"./config\";\nimport LoginHooks from \"./LoginHooks\";\n\ninterface IEvents {\n    jobsLoaded: () => unknown;\n}\n\nexport default new (class JobsController extends TypedEmitter<IEvents> {\n    private fastmodecount = 0;\n    public set fastmode(cycles: number) {\n        const doStuff = async () => {\n            if (await this.jobsHubSupported()) {\n                return;\n            }\n\n            console.log(`JobsController going in fastmode for ${cycles} cycles`);\n            this.fastmodecount = cycles;\n            await this.restartLoop();\n        };\n        void doStuff();\n    }\n\n    private currentLoop: Date = new Date(0);\n    public accessibleInstances = new Map<number, InstanceResponse>();\n\n    private enableJobProgressWorkaround?: boolean;\n\n    public errors: InternalError[] = [];\n    public nextRetry: Date | null;\n    public jobs = new Map<number, TGSJobResponse>();\n    public jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n    private jobCallback = new Map<number, Set<(job: TGSJobResponse) => unknown>>();\n    private lastSeenJob = -1;\n\n    private connection: signalR.HubConnection | null;\n\n    public async reset(clearJobs: boolean): Promise<void> {\n        console.log(\"JobsController resetting\");\n        if (clearJobs) {\n            this.jobs = new Map<number, TGSJobResponse>();\n            this.jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n        }\n\n        try {\n            await this.reloadAccessibleInstances();\n        } catch (e) {\n            this.errors.push(\n                new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e as string) })\n            );\n            return;\n        }\n\n        await this.restartLoop();\n    }\n\n    public constructor() {\n        super();\n\n        this.connection = null;\n        this.nextRetry = null;\n        this.loop = this.loop.bind(this);\n        this.reset = this.reset.bind(this);\n        this.cleanConnection = this.cleanConnection.bind(this);\n        this.restartLoop = this.restartLoop.bind(this);\n    }\n\n    private async stopAndRemoveConnection(): Promise<void> {\n        console.log(\"JobsController: stopAndRemoveConnection\");\n\n        if (this.connection) {\n            console.log(\n                `Stopping and removing active hub connection. State is: ${this.connection.state}`\n            );\n            const connectionToStop = this.connection;\n            this.connection = null;\n            await connectionToStop.stop();\n        }\n    }\n\n    private async cleanConnection(): Promise<void> {\n        if (!(await this.jobsHubSupported())) {\n            return;\n        }\n\n        console.log(\"JobsController: cleanConnection\");\n\n        await this.stopAndRemoveConnection();\n\n        this.errors = [];\n        this.nextRetry = null;\n        this.jobs = new Map<number, TGSJobResponse>();\n        this.jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n        this.emit(\"jobsLoaded\");\n    }\n\n    public init() {\n        window.clients[\"JobsController\"] = this;\n\n        //technically not a \"cache\" but we might as well reload it\n        ServerClient.on(\"purgeCache\", () => void this.reset(true));\n        ServerClient.on(\"logout\", () => void this.cleanConnection());\n\n        InstanceClient.on(\"instanceChange\", () => void this.reset(false));\n        LoginHooks.addHook(async () => {\n            console.log(\"JobsController resetting due to login\");\n            await this.reset(true);\n        });\n\n        ServerClient.on(\"loadServerInfo\", response => {\n            if (response.code === StatusCode.OK) {\n                //A bug in versions below 4.11.0 makes it so that /Job/List doesn't report back progress. If we are running on a higher version, theres no point in enabling the workaround\n                this.enableJobProgressWorkaround = SemverSatisfies(\n                    response.payload.version,\n                    \"<4.11.0\"\n                );\n            }\n        });\n    }\n\n    private async reloadAccessibleInstances(loop = false): Promise<void> {\n        const allInstances: InstanceResponse[] = [];\n\n        const instances1 = await InstanceClient.listInstances({ pageSize: 100 });\n        if (instances1.code === StatusCode.ERROR) {\n            this.errors.push(instances1.error);\n            return;\n        } else {\n            allInstances.push(...instances1.payload.content);\n        }\n        for (let i = 2; i <= instances1.payload.totalPages; i++) {\n            const instances2 = await InstanceClient.listInstances({ page: i, pageSize: 100 });\n            if (instances2.code === StatusCode.ERROR) {\n                this.errors.push(instances2.error);\n                return;\n            } else {\n                allInstances.push(...instances2.payload.content);\n            }\n        }\n\n        const updatedSet = new Map<number, InstanceResponse>();\n\n        const work = allInstances\n            .filter(instance => instance.online && instance.accessible)\n            .map(instance => {\n                return InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    instance.id\n                ).then(permissionSet => {\n                    if (permissionSet.code === StatusCode.ERROR) {\n                        //If its access denied, it means we have view all instances but we dont have access to the instance itself\n                        if (permissionSet.error.code !== ErrorCode.HTTP_ACCESS_DENIED) {\n                            this.errors.push(permissionSet.error);\n                        }\n                        return;\n                    }\n                    updatedSet.set(instance.id, instance);\n                });\n            });\n\n        await Promise.all(work);\n\n        this.accessibleInstances = updatedSet;\n\n        if (loop) {\n            window.setTimeout(\n                () => void this.reloadAccessibleInstances(true),\n                configOptions.instanceprobetimer.value as number\n            );\n        }\n    }\n\n    private async jobsHubSupported(): Promise<boolean> {\n        if (configOptions.restjobs2.value as boolean) {\n            return false;\n        }\n\n        if (this.connection) {\n            return true;\n        }\n\n        const serverInfo = await ServerClient.getServerInfo();\n        if (serverInfo.code === StatusCode.OK) {\n            return SemVerGte(serverInfo.payload.apiVersion, \"9.13.0\");\n        }\n\n        console.warn(\"Failed to retrieve server info to determin jobs hub support!\");\n\n        return false;\n    }\n\n    public async restartLoop(): Promise<void> {\n        console.log(\"JobsController: restartLoop\");\n        if (!(await this.jobsHubSupported())) {\n            //we use an actual date object here because it could help prevent really weird timing\n            // issues as two different date objects cannot be equal\n            // despite the date being\n            const initDate = new Date(Date.now());\n            this.currentLoop = initDate;\n            window.setTimeout(() => {\n                this.loop(initDate).catch(e =>\n                    this.errors.push(\n                        new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e as string) })\n                    )\n                );\n            }, 0);\n\n            return;\n        }\n\n        await this.stopAndRemoveConnection();\n\n        this.nextRetry = null;\n\n        let apiPath = configOptions.apipath.value as string;\n        if (!apiPath.endsWith(\"/\")) {\n            apiPath = apiPath + \"/\";\n        }\n\n        const localConnection = (this.connection = new signalR.HubConnectionBuilder()\n            .withUrl(`${apiPath}api/hubs/jobs`, {\n                accessTokenFactory: async () => {\n                    const token = await ServerClient.wait4Token();\n                    return token.bearer;\n                },\n                transport: signalR.HttpTransportType.ServerSentEvents,\n                headers: ServerClient.defaultHeaders\n            })\n            .withAutomaticReconnect({\n                nextRetryDelayInMilliseconds: (retryContext: signalR.RetryContext) => {\n                    if (retryContext.previousRetryCount == 0) {\n                        return 0;\n                    }\n\n                    const nextRetryMs = Math.min(2 ** retryContext.previousRetryCount, 30) * 1000;\n                    const retryDate = new Date();\n                    retryDate.setMilliseconds(retryDate.getMilliseconds() + nextRetryMs);\n                    this.nextRetry = retryDate;\n                    this.emit(\"jobsLoaded\");\n                    return nextRetryMs;\n                }\n            })\n            .configureLogging(signalR.LogLevel.Trace)\n            .build());\n\n        localConnection.on(\"ReceiveJobUpdate\", async (job: JobResponse) => {\n            console.log(`Received update for job ${job.id}`);\n            this.registerJob(job, job.instanceId);\n            this.emit(\"jobsLoaded\");\n            const canCancel = await this.canCancel(job, this.errors);\n            if (this.jobs.has(job.id)) {\n                this.jobs.get(job.id)!.canCancel = canCancel;\n                this.emit(\"jobsLoaded\");\n            }\n        });\n\n        let justReconnected = true;\n        let reconnectionTimeout: NodeJS.Timeout | null = null;\n        localConnection.onreconnected(() => {\n            this.nextRetry = null;\n            justReconnected = true;\n            this.emit(\"jobsLoaded\");\n            console.log(\"Jobs hub connection re-established, running refresh...\");\n\n            // at this point we need to manually load all the jobs we have registered in case they've completed in the hub and are no longer receiving updates\n            const forcedRefresh = async () => {\n                clearTimeout(reconnectionTimeout!);\n                reconnectionTimeout = null;\n                if (localConnection.state !== signalR.HubConnectionState.Connected) {\n                    return;\n                }\n\n                justReconnected = false;\n\n                this.errors = [];\n                this.emit(\"jobsLoaded\");\n                await this.reloadAccessibleInstances(false);\n                await this.loop((this.currentLoop = new Date()));\n            };\n\n            if (reconnectionTimeout) {\n                clearTimeout(reconnectionTimeout);\n            }\n\n            reconnectionTimeout = setTimeout(() => void forcedRefresh(), 3000);\n        });\n\n        localConnection.onreconnecting(() => {\n            if (justReconnected) {\n                if (reconnectionTimeout) {\n                    clearTimeout(reconnectionTimeout);\n                    reconnectionTimeout = null;\n                }\n\n                const relog = async () => {\n                    // we reconnected and then got disconnected? That's an auth issue\n                    const result = await ServerClient.login();\n                    if (result.code != StatusCode.OK) {\n                        ServerClient.logout();\n                    } else {\n                        justReconnected = false;\n                    }\n                };\n\n                void relog();\n                return;\n            }\n\n            this.errors = [];\n            this.errors.push(new InternalError(ErrorCode.BAD_HUB_CONNECTION, { void: true }));\n            this.emit(\"jobsLoaded\");\n        });\n\n        localConnection.start().catch(error => {\n            if (this.connection != localConnection) {\n                return;\n            }\n\n            this.errors = [];\n            if (error instanceof Error) {\n                this.errors.push(\n                    new InternalError(ErrorCode.BAD_HUB_CONNECTION, { jsError: error })\n                );\n            } else {\n                this.errors.push(new InternalError(ErrorCode.BAD_HUB_CONNECTION, { void: true }));\n            }\n            this.emit(\"jobsLoaded\");\n            this.connection = null;\n        });\n    }\n\n    private _registerJob(job: TGSJobResponse, instanceid?: number): void;\n    // noinspection JSUnusedLocalSymbols\n    private _registerJob(job: JobResponse, instanceid: number): void;\n    private _registerJob(_job: JobResponse | TGSJobResponse, instanceid?: number) {\n        const job = _job as TGSJobResponse;\n        if (this.jobs.has(job.id) && this.jobs.get(job.id)!.stoppedAt) {\n            console.warn(\n                `Receieved job update for ${job.id} after it completed! Incoming job was${\n                    job.stoppedAt ? \"\" : \" not\"\n                } completed.`\n            );\n            return;\n        }\n\n        if (instanceid) job.instanceId = instanceid;\n        const instanceSet =\n            this.jobsByInstance.get(job.instanceId) ?? new Map<number, TGSJobResponse>();\n        this.jobsByInstance.set(job.instanceId, instanceSet);\n        instanceSet.set(job.id, job);\n        this.jobs.set(job.id, job);\n    }\n\n    public registerJob(job: TGSJobResponse, instanceid?: number): void;\n    public registerJob(job: JobResponse, instanceid: number): void;\n    public registerJob(_job: JobResponse | TGSJobResponse, instanceid?: number) {\n        this._registerJob(_job, instanceid);\n\n        const doStuff = async () => {\n            if (!(await this.jobsHubSupported())) {\n                console.log(\n                    \"Server does not support jobs hub, restarting loop due to job registration.\"\n                );\n                await this.restartLoop();\n            }\n        };\n\n        void doStuff();\n    }\n\n    private async loop(loopid: Date) {\n        //so loops get initialiazed with the current time, it keeps track of which loop to run with\n        // that initialization date in currentLoop if the currentLoop isnt equal to the one provided\n        // to the loop, it means that the loop was\n        // replaced so we dont try to call for another one\n        if (loopid !== this.currentLoop) {\n            return;\n        }\n\n        //time to clear out errors\n        this.errors = [];\n\n        let totalActiveJobs = 0;\n        const work: Promise<void>[] = [];\n\n        //We can't update the value immediatly or instances will conflict with each other and prevent some jobs from fetching\n        let tempLastSeenJob = this.lastSeenJob;\n        for (const instanceid of this.accessibleInstances.keys()) {\n            const processJobs = async (jobs: TGSJobResponse[]) => {\n                for (const job of jobs) {\n                    this._registerJob(job);\n                    tempLastSeenJob = Math.max(tempLastSeenJob, job.id);\n                }\n\n                const remoteActive = jobs.map(job => job.id);\n                const localActive = Array.from(this.jobs.values())\n                    .filter(job => !job.stoppedAt)\n                    .filter(job => job.instanceId === instanceid)\n                    .map(job => job.id);\n                const manualIds = localActive.filter(jobId => !remoteActive.includes(jobId));\n\n                const instanceSet =\n                    this.jobsByInstance.get(instanceid) ?? new Map<number, TGSJobResponse>();\n                this.jobsByInstance.set(instanceid, instanceSet);\n                const work: Promise<void>[] = [];\n                manualIds.forEach(jobId => {\n                    work.push(\n                        JobsClient.getJob(instanceid, jobId).then(job => {\n                            if (job.code === StatusCode.ERROR) {\n                                this.errors.push(job.error);\n                                return;\n                            }\n                            instanceSet.set(job.payload.id, job.payload);\n                            this.jobs.set(job.payload.id, job.payload);\n                        })\n                    );\n                });\n                await Promise.all(work);\n\n                if (loopid !== this.currentLoop) return;\n\n                totalActiveJobs += jobs.length;\n            };\n\n            const processError = (error: InternalError) => {\n                if (\n                    error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                    error.originalErrorMessage?.errorCode === TGSErrorCode.InstanceOffline\n                ) {\n                    console.log(\n                        `[JobsController] Clearing instance ${instanceid} as it is now offline`\n                    );\n                    this.accessibleInstances.delete(instanceid);\n                    //Probably a good idea to reload the list at this point\n                    this.reloadAccessibleInstances().catch(e => {\n                        this.errors.push(\n                            new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e as string) })\n                        );\n                    });\n                } else {\n                    this.errors.push(error);\n                }\n            };\n\n            const fetchJobs =\n                this.lastSeenJob === -1 ? JobsClient.listActiveJobs : JobsClient.listJobs;\n            //now since this is async, it still possible that a single fire gets done after the new loop started, theres no really much that can be done about it\n            work.push(\n                fetchJobs(instanceid, { page: 1, pageSize: 10 })\n                    .then(async value => {\n                        //this check is here because the request itself is async and could return after\n                        // the loop is terminated, we dont want to contaminate the jobs of an instance\n                        // with the jobs of another even if it is for a single fire and would eventually\n                        // get fixed on its own after a few seconds\n                        if (loopid !== this.currentLoop) return;\n\n                        if (value.code === StatusCode.OK) {\n                            let lastPayload = value.payload.content;\n                            fetchLoop: for (let i = 2; i <= value.payload.totalPages; i++) {\n                                for (const job of lastPayload) {\n                                    //We reached the last page of usable content, break the loop\n                                    if (job.id <= this.lastSeenJob) {\n                                        break fetchLoop;\n                                    }\n                                }\n                                const jobs2 = await fetchJobs(instanceid, {\n                                    page: i,\n                                    pageSize: 10\n                                });\n                                if (jobs2.code === StatusCode.ERROR) {\n                                    processError(jobs2.error);\n                                    return;\n                                } else {\n                                    value.payload.content.push(...jobs2.payload.content);\n                                    lastPayload = value.payload.content;\n                                }\n                            }\n                            if (loopid !== this.currentLoop) return;\n                            await processJobs(\n                                value.payload.content.filter(\n                                    job => job.id > this.lastSeenJob || this.jobs.has(job.id)\n                                )\n                            );\n                        } else {\n                            processError(value.error);\n                        }\n                    })\n                    .catch(reason => {\n                        console.error(reason);\n                    })\n            );\n        }\n\n        await Promise.all(work);\n\n        this.lastSeenJob = tempLastSeenJob;\n\n        work.length = 0;\n        for (const job of this.jobs.values()) {\n            if (\n                this.enableJobProgressWorkaround &&\n                job.progress === undefined &&\n                !job.stoppedAt &&\n                this.accessibleInstances.has(job.instanceId)\n            ) {\n                work.push(\n                    JobsClient.getJob(job.instanceId, job.id).then(progressedjob => {\n                        if (loopid !== this.currentLoop) return;\n                        if (progressedjob.code === StatusCode.OK) {\n                            job.progress = progressedjob.payload.progress;\n                        } else {\n                            if (\n                                progressedjob.error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                                progressedjob.error.originalErrorMessage?.errorCode ===\n                                    TGSErrorCode.InstanceOffline\n                            ) {\n                                console.log(\n                                    `[JobsController] Clearing instance ${job.instanceId} as it is now offline`\n                                );\n                                this.accessibleInstances.delete(job.instanceId);\n                                //Probably a good idea to reload the list at this point\n                                this.reloadAccessibleInstances().catch(e => {\n                                    this.errors.push(\n                                        new InternalError(ErrorCode.APP_FAIL, {\n                                            jsError: Error(e as string)\n                                        })\n                                    );\n                                });\n                            } else {\n                                this.errors.push(progressedjob.error);\n                            }\n                        }\n                    })\n                );\n            }\n\n            work.push(\n                this.canCancel(job, this.errors).then(canCancel => {\n                    if (loopid !== this.currentLoop) return;\n                    job.canCancel = canCancel;\n                })\n            );\n        }\n\n        //populate fields on jobs\n        await Promise.all(work);\n        if (loopid !== this.currentLoop) return;\n\n        this.emit(\"jobsLoaded\");\n\n        for (const job of this.jobs.values()) {\n            if (!job.stoppedAt) continue;\n            const callbacks = this.jobCallback.get(job.id);\n            if (!callbacks) continue;\n            for (const callback of callbacks) {\n                callback(job);\n            }\n            this.jobCallback.delete(job.id);\n        }\n\n        if (this.fastmodecount && loopid === this.currentLoop) {\n            window.setTimeout(() => {\n                this.loop(loopid).catch(e =>\n                    this.errors.push(\n                        new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e as string) })\n                    )\n                );\n            }, 800);\n            this.fastmodecount--;\n            console.log(`JobsController will remain in fastmode for ${this.fastmodecount} cycles`);\n        } else {\n            window.setTimeout(\n                () => {\n                    this.loop(loopid).catch(e =>\n                        this.errors.push(\n                            new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e as string) })\n                        )\n                    );\n                },\n                (totalActiveJobs\n                    ? (configOptions.jobpollactive.value as number)\n                    : (configOptions.jobpollinactive.value as number)) * 1000\n            );\n        }\n    }\n\n    private async canCancel(\n        job: Readonly<TGSJobResponse>,\n        errors: InternalError<ErrorCode>[]\n    ): Promise<boolean> {\n        //we dont need to reevalutate stuff that we already know\n        if (job.canCancel !== undefined) return job.canCancel;\n\n        if (job.cancelRightsType === undefined) {\n            return true;\n        }\n\n        switch (job.cancelRightsType as RightsType) {\n            case RightsType.Administration: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as AdministrationRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).administrationRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.InstanceManager: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstanceManagerRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).instanceManagerRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.Engine: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceId\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as EngineRights;\n                    return !!(InstancePermissionSet.payload.engineRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.ChatBots: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceId\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ChatBotRights;\n                    return !!(InstancePermissionSet.payload.chatBotRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Configuration: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceId\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ConfigurationRights;\n                    return !!(InstancePermissionSet.payload.configurationRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamDaemon: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceId\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamDaemonRights;\n                    return !!(InstancePermissionSet.payload.dreamDaemonRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamMaker: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceId\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamMakerRights;\n                    return !!(InstancePermissionSet.payload.dreamMakerRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.InstancePermissionSet: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceId\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstancePermissionSetRights;\n                    return !!(InstancePermissionSet.payload.instancePermissionSetRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Repository: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceId\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as RepositoryRights;\n                    return !!(InstancePermissionSet.payload.repositoryRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n        }\n    }\n\n    public async cancelJob(\n        jobid: number,\n        onError: (error: InternalError<ErrorCode>) => void\n    ): Promise<boolean> {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        const deleteInfo = await JobsClient.deleteJob(job.instanceId, jobid);\n        if (deleteInfo.code === StatusCode.OK) {\n            return true;\n        } else {\n            onError(deleteInfo.error);\n            return false;\n        }\n    }\n\n    public clearJob(jobid: number, noEmit = false): boolean {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        this.jobsByInstance.get(job.instanceId)?.delete(jobid);\n        this.jobs.delete(jobid);\n        if (!noEmit) {\n            this.emit(\"jobsLoaded\");\n        }\n        return true;\n    }\n\n    public registerCallback(jobid: number, callback: (job: TGSJobResponse) => unknown): void {\n        const set = this.jobCallback.get(jobid) ?? new Set();\n        set.add(callback);\n        this.jobCallback.set(jobid, set);\n    }\n})();\n"],"names":["ApiClient","listInstances","page","pageSize","configOptions","itemsperpage","value","response","ServerClient","wait4Init","apiClient","api","instanceControllerList","stat","InternalStatus","code","StatusCode","ERROR","error","status","OK","payload","data","InternalError","ErrorCode","UNHANDLED_RESPONSE","axiosResponse","grantPermissions","instance","instanceControllerGrantPermissions","id","this","emit","NO_DB_ENTITY","errorMessage","editInstance","instanceControllerUpdate","detachInstance","instanceControllerDelete","createInstance","instanceControllerCreate","HTTP_DATA_INEGRITY","getInstance","instanceid","instanceControllerGetId","constructor","super","_cachedInstancePermissionSet","Map","loadingInstancePermissionSetInfo","on","clear","listInstancePermissionSets","instancePermissionSetControllerList","headers","Instance","toString","getCurrentInstancePermissionSet","noCache","has","get","Promise","resolve","resolver","user","removeListener","set","instancePermissionSetControllerRead","res","getByPermissionSetId","permissionSetId","instancePermissionSetControllerGetId","createInstancePermissionSet","instancePermissionSet","instancePermissionSetControllerCreate","updateInstancePermissionSet","instancePermissionSetControllerUpdate","deleteInstancePermissionSet","instancePermissionSetControllerDelete","listActiveJobs","jobControllerRead","newContent","content","map","job","getJob","jobid","jobControllerGetId","JOB_JOB_NOT_FOUND","deleteJob","jobControllerDelete","JOB_JOB_COMPLETE","void","listJobs","jobControllerList","TypedEmitter","fastmode","cycles","async","jobsHubSupported","console","log","fastmodecount","restartLoop","doStuff","reset","clearJobs","jobs","jobsByInstance","reloadAccessibleInstances","e","errors","push","APP_FAIL","jsError","Error","currentLoop","Date","accessibleInstances","enableJobProgressWorkaround","nextRetry","jobCallback","lastSeenJob","connection","loop","bind","cleanConnection","stopAndRemoveConnection","state","connectionToStop","stop","init","window","clients","InstanceClient","LoginHooks","addHook","SemverSatisfies","version","allInstances","instances1","i","totalPages","instances2","updatedSet","work","filter","online","accessible","InstancePermissionSetClient","then","permissionSet","HTTP_ACCESS_DENIED","all","setTimeout","instanceprobetimer","restjobs2","serverInfo","getServerInfo","SemVerGte","apiVersion","warn","initDate","now","catch","apiPath","apipath","endsWith","localConnection","signalR","withUrl","accessTokenFactory","wait4Token","bearer","transport","ServerSentEvents","defaultHeaders","withAutomaticReconnect","nextRetryDelayInMilliseconds","retryContext","previousRetryCount","nextRetryMs","Math","min","retryDate","setMilliseconds","getMilliseconds","configureLogging","Trace","build","registerJob","instanceId","canCancel","justReconnected","reconnectionTimeout","onreconnected","forcedRefresh","clearTimeout","Connected","onreconnecting","login","logout","relog","BAD_HUB_CONNECTION","start","_registerJob","_job","stoppedAt","instanceSet","loopid","totalActiveJobs","tempLastSeenJob","keys","processJobs","max","remoteActive","manualIds","Array","from","values","jobId","includes","forEach","JobsClient","length","processError","originalErrorMessage","errorCode","TGSErrorCode","InstanceOffline","delete","fetchJobs","lastPayload","fetchLoop","jobs2","reason","undefined","progress","progressedjob","callbacks","callback","jobpollactive","jobpollinactive","cancelRightsType","RightsType","Administration","userInfo","UserClient","getCurrentUser","required","cancelRight","resolvePermissionSet","administrationRights","InstanceManager","instanceManagerRights","Engine","InstancePermissionSet","engineRights","ChatBots","chatBotRights","Configuration","configurationRights","DreamDaemon","dreamDaemonRights","DreamMaker","dreamMakerRights","instancePermissionSetRights","Repository","repositoryRights","cancelJob","onError","deleteInfo","clearJob","noEmit","registerCallback","Set","add"],"sourceRoot":""}